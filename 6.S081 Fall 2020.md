# Lecture - 1

## 1.1OverView

### 课程目标

1.理解操作系统的设计和实现

2.动手扩展操作系统，编写操作系统软件

### 操作系统的目的

1.抽象硬件，方便应用开发，提高可移植性，譬如软件并不关心它在和哪种类型的硬盘交互

2.在多个应用程序中共用硬件资源，一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。操作系统能在不相互干扰的前提下，同时运行这些程序。这里通常被称为multiplex。

3.由于操作系统可以同时运行许多应用程序，所以必须保证某个程序出现bug时，不会干扰到其他程序，也即隔离应用程序以容许bug

4.允许相互协作的应用程序之间共享资源，如编辑器和编译器，我们希望编辑器和编译器能共享文本文件

5.访问控制,处于安全性的考虑我们会希望某些时候我们不与其他人或者应用共享文件数据等， Control sharing for security，称为Access Control System。

6.帮助应用程序榨取硬件的最佳性能，至少不要妨碍软件获得高性能

7.希望操作系统能支持大量不同类型的应用程序。因为开发一个可用的操作系统代价极大，所以希望操作系统能万能一点

## 1.2操作系统结构

#### 内核

用一个矩形表示计算机，硬件资源包括CPU，内存，磁盘，网卡，硬件资源在最底层，这个架构的最上层我们运行各种应用程序，这些程序运行在同一个空间中，这个空间通常被称为用户空间

与运行在用户空间的应用程序不同，有一个特殊的程序总会运行，我们称之为内核，内核是计算机资源的守护者，当打开计算机时内核第一个启动。内核只有一个，负责维护数据以及管理用户空间的进程。内核还具有大量的服务，如文件系统，用户空间的程序与内核的文件系统交互，文件系统再与磁盘交互。

每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。同时，Kernel会管理内存的分配。不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。

文件系统通常有一些逻辑分区。目前而言，可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有这些都被文件系统所管理。

处于安全考虑的访问控制系统，当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control机制会决定是否允许这样的操作。

当然在一个真实的完备的操作系统中，会有很多很多其他的服务，比如在不同进程之间通信的进程间通信服务，比如一大票与网络关联的软件（TCP/IP协议栈），比如支持声卡的软件，比如支持数百种不同磁盘，不同网卡的驱动。所以在一个完备的系统中，Kernel会包含大量的内容，数百万行代码。

```c
* What services does an O/S kernel typically provide?
  * process (a running program)//进程管理
  * memory allocation//内存分配，内存管理
  * file contents//文件系统
  * file names, directories//文件系统相关
  * access control (security)//访问控制，安全性
  * many others: users, IPC, network, time, terminals
```

![image (64)](D:\Pictures Of Markdown\6.S081\image (64).png)

#### 应用程序与内核交互（快速预览）

应用程序通过内核的API与内核交互，API决定了应用程序如何访问内核，一般来说是通过系统调用(System Call)来完成，系统调用与程序中的函数调用看起来是一样的，但是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现

```c
* What's the application / kernel interface?
  * "System calls"
  * Examples, in C, from UNIX (e.g. Linux, macOS, FreeBSD):

            fd = open("out", 1);
            write(fd, "hello\n", 6);
            pid = fork();

  * These look like function calls but they aren't 
```

## 1.3 Why Hard and Interesting（学生提问）

1.

编写、修改，扩展内核，或者写一个新的操作系统内核时，你实际上在提供一个基础设施让别人来运行他们的程序。当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。

2.在设计一个操作系统时，我们我们需要满足一系列相互对立的需求

- 操作系统既高效又易用，高效意味着操作系统需要在贴近硬件的低层次进行操作，而易用又需要操作系统提供抽象的高级可移植接口，所以供一个简单可移植，同时又高效的抽象接口需要一定的技巧。
- 我们想要提供一个非常强大的操作系统服务，这样操作系统才能分担运行应用程序的负担，所以我们需要强大的操作系统服务。但同时，我们也想要有简单的接口。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。所以，我们也想要简单的API。实际上是有可能提供既简单，同时又包含强大功能的接口。所以，这里要提供一个简单的接口，同时又包含了强大的功能。
- 最后一个矛盾点是所有的操作系统需要满足的。一方面给应用程序尽可能多的灵活性，你不会想要限制应用程序，所以你需要内核具备灵活的接口。但是另一方面，出于安全性考虑，又需要在某种程度上限制应用程序。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为

```
学生提问：系统调用跳到内核与标准的函数调用跳到另一个函数相比，区别是什么？

Robert教授：Kernel的代码总是有特殊的权限。当机器启动Kernel时，Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。我们之后会介绍更多有关的细节。
```

另一件使得操作系统的设计难且有趣的点是：**操作系统提供了大量的特性和大量的服务，但是它们趋向于相互交互。有时，这种交互以奇怪的方式进行，并且需要你大量的思考。**即使在我之前给出的一个简单例子中，对于open和fork，它们之间也可能有交互。如果一个应用程序通过open系统调用得到了一个文件描述符fd。之后这个应用程序调用了fork系统调用。fork的语义是创建一个当前进程的拷贝进程。而对于一个真正的拷贝进程，父进程中的文件描述符也必须存在且可用。所以在这里，一个通过open获得的文件描述符，与fork以这种有趣的方式进行交互。当然，你需要想明白，子进程是否能够访问到在fork之前创建的文件描述符fd。在我们要研究的操作系统中答案是，Yes，需要能够访问。

另一件有趣的事情，我之前也提到过，操作系统需要能够满足广泛的使用场景。相同的操作系统需要既给数据库服务器使用，又给智能手机使用。随着时间的推移，你的计算机所使用的硬件也在变化，所有的这些都需要时不时的重新思考，操作系统是如何被设计的。

```
学生提问：对于应用程序开发人员来说，他们会基于一些操作系统做开发，真正的深入理解这些操作系统有多重要？他们需要成为操作系统的专家吗？

Robert教授：你不必成为一个专家。但是如果你花费大量时间来开发，维护并调试应用程序，你最终还是会知道大量操作系统的知识。不论你是否是有意要掌握这些知识，它们就是出现了，而你不得不去理解它们。

学生提问：对于一些例如Python的高阶编程语言（高阶是指离自然语言更接近，低阶是指离机器语言更接近如C，汇编），它们是直接执行系统调用呢，还是内部对系统调用进行了封装呢？

Robert教授：许多高阶的编程语言都离系统调用较远，这是一个事实。部分原因是很多编程语言想要提供可以在多个操作系统上运行的可移植的环境，所以它们不能依赖特定的系统调用。所以，对于这个问题的答案我认为是，如果你使用了Python，你在某种程度上就与系统调用接口隔离了。当然，在Python内部，最终还是要执行系统调用来完成相应的工作。当然，Python和许多其他的编程语言通常都有方法能直接访问系统调用。
```

## 1.4一些系统调用

你会在第一个lab中使用我们在这里介绍的系统调用，并且在后续的lab中，扩展并提升这些系统调用的内部实现。

我们的操作系统是XV6，它运行在RISC-V微处理器上，当然不只是RISC-V微处理器，我们假设有一定数量的其他硬件存在，例如内存，磁盘和一个console接口，这样我们才能跟操作系统进行交互。但是实际上，XV6运行在QEMU模拟器之上。这样你们都能在没有特定硬件的前提下，运行XV6。

首先在shell输入make clean，这样就能看到完整的编译过程。之后输入make qemu，这条指令会编译并构建xv6内核和所有的用户进程，并将它们运行在QEMU模拟器下。$表示Shell，XV6本身很小，并且自带了一小部分的工具程序，例如ls。
