# OverView

```
浮点数不满足结合律
而整型由于范围有限，导致乘积溢出，正值变负值
```

![屏幕截图 2021-10-02 221755](D:\MarkDowns\Pictures Of Markdown\操作系统基础\屏幕截图 2021-10-02 221755.png)

# Part1

## Example Data Representations

| C Data Type | Typical 32-bit | Typical 64-bit |
| ----------- | -------------- | -------------- |
| **char**    | 1              | 1              |
| **short**   | 2              | 2              |
| **int**     | 4              | 4              |
| **long**    | 4              | 8              |
| **float**   | 4              | 4              |
| **double**  | 8              | 8              |
| pointer     | 4              | 8              |
|             | “ILP32”        | “LP64”         |

## Boolean Algebra

![屏幕截图 2021-10-03 132243](D:\MarkDowns\Pictures Of Markdown\操作系统基础\屏幕截图 2021-10-03 132243.png)

### Bit-Level Operations in C

这个是位级别的运算，不是C中的逻辑运算

**Operations &,  |,  ~,  ^ Available in C**

- 将参数看作位向量
- 适用于C中的任何“整型”，包括char
- 参数按位运算
- 注意与C的逻辑运算&&、|| 、!区分，这个是逻辑运算，上面的是位向量运算
- 确定一个位级表达式的结果的最好方法是将其他进制转换为二进制并执行二进制运算，然后再转换回十六进制

## Shift Operations 移位运算

### Left Shift: 	x << y

- x左移y位，丢弃最高的y位（也就是最左侧的y位），并在右端补上y个0
- 移位量y应该是一个0到w-1之间的值，w为操作数x的宽度
- 移位运算是从左向右结合的，也就是说x << y << z等价于(x << y) << z

3 << 2

首先把3转换为二进制数字**00**00 0000 0000 0000 0000 0000 0000 0011，然后把该数字**高位(最左侧)**的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12。

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。

### Right Shift: 	x >> y

- x右移y位
- 机器支持两种形式的右移：逻辑右移和算术右移

11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 10**11**，然后把低位的最后两个数字**11**移出，因为该数字是正数，所以在高位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。转换为十进制是2。

右移一位相当于除以2，右移n位相当于除以2的n次方。

#### 逻辑右移

逻辑右移在左端补y个0，丢弃操作数低位（最右侧）的y位，与左移恰好相反

#### 算术右移

- 算术右移在左端补y个最高有效位的值，丢弃操作数最右侧的y位
- 对有符号整数的运算很有用
- 最高位为0补0，为1补1

[01100011] 算术右移4位====》[00000110]，最高位为0

[10010101]算术右移4位====》[11111001]，最高位为1

- 几乎所有的编译器/机器都对有符号树使用算术右移，许多程序员也如此假设
- 对于无符号数，右移必须是逻辑右移

### Undefined Behavior

- Shift amount < 0 or ≥ word size

- 对于宽度为w的数据类型移动k（k >= w）位，许多机器计算位移量为k对w的余数

- 不过对于C来说这是未定义的行为，所以要保证位移量大于零小于宽度w

### 运算优先级问题

在C语言中，加减法的优先级是高于移位运算符的

1 << 2 + 3 << 4 等效于1 << (2+3) << 4，所以在拿捏不准的时候，加上括号 

## Integers

负数的范围比正数大一

### 无符号数的编码

- BInary to Unsigned==》B2U，宽度为w作为下标

- 对于宽度为w的无符号数，它的范围为0到2^w - 1 

- 介于这个范围内的每个数都有唯一的编码

### 补码(two‘ s -complement)

B2T ===》Binary to two ’ s complement，跨度w作为T的下标

- 在补码中将字的最高有效位定义为负权，最高有效位也称为符号位，值为 - 2 ^(w-1)

- 符号位为1时表示的是负数，为零时表示的是正值

- 补码的范围：正数最大为 2 ^ (w -1) -1 ，负数最小为 - 2^(w - 1)，正数比负数少一个

- 分别对应符号位为0，其他位为1，以及符号位为1，其他位为0

- 在表示的范围内补码编码也具有唯一性

- -1表示为全1串

### 有符号数和无符号数之间的转换

强制类型转换的结果保持位值不变，只是改变解释这些位的方式。

对于处理**相同字长**的有符号数和无符号数的相互转换，一般规则是:

- 数值可能会改变，但位模式不变

```c
//举例,下列转换过程中位值没变，而解释位的方式改变了
short v = -12345//-12345 == [1100111111000111];，有符号数，补码最高位为符号位
unsigned uv = (unsigned)v;//uv == 532191 == [1100111111000111]，无符号数，最高位不是符号位
```

有符号数（补码）到无符号数的转换:非负数不变而负数变成了大的正数

- 如果要转换的有符号数是正数或0，那么转换后的无符号数与有符号数相等
- 待转换的有符号数为负数，且其二进制为w位，其对应的无符号数等于有符号数加上2^w

无符号数到有符号数(补码)的转换：

- 待转换的无符号数小于有符号数能表示的最大正数时，其对应的有符号数不变
- 待转换的无符号数大于有符号数能表示的最大正数时，其对应的有符号数等于无符号数减去2^w

**当执行一个运算时，如果它的一个运算数是有符号数而另外一个是无符号数，那么C语言会隐式地将有符号数强制转换为无符号数，并且假设两个数都是非负的，来执行这个运算**

- 在标准算术运算中可能差异不大
- 在   <  和  >  这样的运算符中，会出现意料之外的结果

```c
//举例，假设在32位机器上
//比较有符号的-1和无符号的0：-1 < 	0U
//由于第二个参数0是无符号的，所以-1被隐式转换为无符号数
//而-1的32位补码对应的无符号数是（2^32 - 1）U ，远大于0U
//因此表达式等价于4294967295U < 0U
//表达式结果为false，与预期的true完全不符合
```

## 扩展一个数字的位表示

