# 0.操作系统的前世今生

- 讲历史咯

# 1.操作系统简介

- 第一个问题，什么是操作系统？这实际上是一个很难定义的问题，究竟如何定义操作系统？这个其实是可以不断扩展操作系统的内涵和外延的。
- 给出一个定义：操作系统是在硬件和应用之间的软件层。硬件是身体，而操作系统是灵魂。
- 给出一个更加广泛的定义：操作系统是管理硬件资源、控制程序运行、改善人机界面和为应用软件提供支持的一种系统软件。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041404379.png" alt="image-20220704140419211" style="zoom: 67%;" />

- 操作系统为应用提供的服务：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041406052.png" alt="image-20220704140625966" style="zoom: 67%;" />
- 操作系统对应用的管理：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041412271.png" alt="image-20220704141215182" style="zoom:67%;" />

- 操作系统 = 管理 + 服务：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041421150.png" alt="image-20220704142123076" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041433754.png" alt="image-20220704143343681" style="zoom:67%;" />

- 操作系统能够避免一个应用独占所有资源：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041441883.png" alt="image-20220704144143796" style="zoom:67%;" />
- 如何卡死一个OS？
  - 资源配额可以将影响降到最小，限定某个应用能够占用的资源的上限。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041446008.png" alt="image-20220704144653923" style="zoom:67%;" />
- 为什么学习操作系统？因为并不是我们不需要新的操作系统了，永远会有新的除了PC之外的其他硬件出现，它们也需要操作系统。
- 微内核和宏内核，为什么选择微内核而不是宏内核？
  - 比较类似选择发送更小的数据包而不是更大的数据包，因为数据包越大，其完好无损的概率就越低。
  - 宏内核其复杂性更高，模块数更多，其崩溃的概率就更大。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041553441.png" alt="image-20220704155349303" style="zoom:50%;" />



# 2.ARM64硬件结构与系统接口

## ARM64体系结构

- 指令长度也有可能是64位的。B：Branch，L：Load，X：Extend。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041741332.png" style="zoom: 50%;" />

- 寄存器：
  - 4个栈寄存器用于保存栈顶指针，每个寄存器用于不同的特权级。EL0用于用户态，EL2用于操作系统，etc。
  - ELR: Exception Link Register
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041743793.png" alt="image-20220704174306699" style="zoom: 50%;" />
- 特权级：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041754869.png" alt="image-20220704175400777" style="zoom:50%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207041754532.png" alt="image-20220704175452435" style="zoom: 50%;" />



# 3.中断、异常与系统调用

- **通用的**（因为不同架构对这俩有不同的名称）中断和异常的概念：
  - 中断顾名思义，是被打断，产生原因和当前执行指令无关，由外部硬件设备所产生的信号打断。
  - 异常：由于软件的程序执行而产生的事件，异常的产生和当前执行或试图执行的指令相关。**系统调用也是异常的一种**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042120455.png" alt="image-20220704212049357" style="zoom:67%;" />
- 不同体系结构下对中断和异常有不同的称呼及分类。
  - ARM架构则用中断和异常的同步和非同步这个特征分类。
  - x86-64则和通用概念比较接近
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091640088.png" alt="image-20220704212858881" style="zoom: 67%;" />

## ARM64的中断和异常

- 中断
  - 看门狗可能会在硬件出现状况的时候触发重置中断。
  - 中断就是普通的中断。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042134424.png" alt="image-20220704213452342" style="zoom:67%;" />
- 异常：
  - 终止：诸如除零、Page Fault、访问不可读的地址等等问题。
  - 异常产生指令：SVC（系统调用）从用户态进入操作系统，HVC：从操作系统进入虚拟机监视器，SMC：从非安全（正常）分区进入安全分区，如手机使用指纹解锁的时候，指纹是存储在安全分区的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042135002.png" alt="image-20220704213511925" style="zoom: 67%;" />

## X86-64的中断和异常

- 可屏蔽中断和不可屏蔽中断区别在于优先级的高低。
- Trap属于是系统有意而为的异常，可能是为了达成某种目的，比如调用系统调用、比如打断点debug。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042145288.png" alt="image-20220704214503202" style="zoom:67%;" />

## 中断的产生

- 中断控制器需要考虑的问题：
  - 低优先级中断中要处理新出现的高优先级中断，就出现了嵌套中断。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042152901.png" alt="image-20220704215251822" style="zoom:67%;" />
- ARM64的中断分类
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042154863.png" alt="image-20220704215401779" style="zoom:67%;" />
- 多个中断的（优先级）仲裁：IRQ级联起来，FIQ直通CPU。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042207724.png" alt="image-20220704220746630" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042216946.png" alt="image-20220704221602865" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042216852.png" alt="image-20220704221626773" style="zoom:67%;" />
- GIC中断来源：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042217971.png" alt="image-20220704221717909" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207042217171.png" alt="image-20220704221740104" style="zoom:67%;" />
- 中断处理中不能做太多的事情，怎么办？
  - 因为中断处理的时候，CPU和操作系统实际上是不能做其他事情的，所以如果中断系统做太多的事情就会效率非常低。
  - Linux的中断处理的理念：及时处理关键的行为，把非关键的行为推迟。注：ISR：中断服务程序
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051118399.png" alt="image-20220705111835243" style="zoom: 50%;" />
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051127040.png" alt="image-20220705112739948" style="zoom: 50%;" />
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051128071.png" alt="image-20220705112806988" style="zoom: 50%;" />
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051129783.png" alt="image-20220705112919706" style="zoom: 50%;" />
- **中断处理没有进程上下文**，因为中断和具体的某条指令无关、和中断时正在跑的进程、用户程序无关。
- **中断处理中的一些约束：**
  - 不能睡眠或者调用可能睡眠的任务。
  - 不能调用`schedule()`来进行调度，因为可能会回到上一条。
  - 不能释放信号或调用可能睡眠的操作。
  - 不能和用户地址空间交换数据。

## 中断和异常的处理

- 中断和异常的处理流程是同一套机制，区别在于其对应的处理函数（Handler）不同
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051230082.png" alt="image-20220705123058976" style="zoom:50%;" />
- 中断和异常处理时的必做事项：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051350839.png" alt="image-20220705135028743" style="zoom:50%;" />
- ARM64下：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051351319.png" alt="image-20220705135111233" style="zoom:50%;" />
- 异常或中断发生后的第一件事：信息保存，即保存当前环境，即上下文信息等。
  - MMIO: Memory Map IO。用于保存上下文信息的寄存器均不可在用户态访问。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051354981.png" alt="image-20220705135455895" style="zoom:50%;" />

- 异常发生后的第二件事：进入EL1（内核态）
  - 栈指针会自动切换成内核态的栈的栈顶指针，实现用户栈到内核栈的切换。
  - 如果在内核态需要使用用户态的栈顶指针，可配置（比如需要用到用户态的栈的数据）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051357203.png" alt="image-20220705135715124" style="zoom:50%;" />

- 异常发生后的第三件事：寻找到处理这个异常的代码（异常Handler）
  - VBAR: Vector Base Address Register
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051359707.png" alt="image-20220705135925613" style="zoom: 50%;" />
- 以发生ARM64，EL0状态下发生同步异常（比如缺页）为例：
  - 找到第三大栏，`EL0 运行于AArch64状态`，找到这一栏的`Synchronous`，地址（偏移量）为0x400。
  - IRQ是普通的中断，FIQ是快速中断，`SError`是系统错误。
  - 保存好上下文，将PC的值置为VBAR_EL1 + 偏移量0x400。开始执行Handler。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051407032.png" alt="image-20220705140752927" style="zoom: 50%;" />

- 中断执行之后的返回：
  - `eret`。
  - ELR_EL1寄存器此前保存的断点，恢复至PC。
  - SPSR_EL1寄存器此前保存处理器状态，恢复至处理器。
  - 从内核态EL1切换至用户态EL0，硬件自动使用用户态指针。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051413179.png" alt="image-20220705141333089" style="zoom:50%;" />

- X86-64的中断和异常处理：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051415146.png" alt="image-20220705141522059" style="zoom:50%;" />



## 系统调用

- 什么是系统调用：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051424639.png" alt="image-20220705142429564" style="zoom:50%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051424104.png" alt="image-20220705142448020" style="zoom:50%;" />

- Linux常用系统调用：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051425675.png" alt="image-20220705142520589" style="zoom:50%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051430596.png" alt="image-20220705143039497" style="zoom:50%;" />



### 系统调用与安全

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051550415.png" alt="image-20220705155050316" style="zoom:50%;" />

- 对用户指针进行检测：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051551031.png" alt="image-20220705155143942" style="zoom:50%;" />

# 4.操作系统结构

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051738323.png" alt="image-20220705173855204" style="zoom: 80%;" />

## 宏内核(MONOLITHIC-KERNEL)

- 什么是宏内核

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051810226.png" alt="image-20220705181030134" style="zoom:67%;" />

- 宏内核的优缺点：
  - 好处是多年的积淀，完备的生态和社区，针对场景的优化。
  - 缺点是是安全性与可靠性不足，模块之间没有强力的隔离机制。
  - 同时对实时性支持不足，不能满足低时延情况下的最坏情况时延分析（比如航空航天、汽车）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051811968.png" alt="image-20220705181107887" style="zoom:67%;" />
- 宏内核难以满足的场景：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051858962.png" alt="image-20220705185819855" style="zoom:67%;" />

## 微内核(MICRO-KERNEL)

- 微内核的系统架构：
  - 基本思想是将操作系统的功能移到用户态，称作服务（sever），在用户模块之间，使用消息传递机制通信。
  - IPC: Inter Process Communication，进程间通信。IPC比较慢。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051946290.png" alt="image-20220705194625192" style="zoom:67%;" />
- 例子：创建一个文件。
  - 左侧是宏内核下的流程，右侧是微内核下的流程。
  - 宏内核下，应用通过处于内核中的文件系统和硬盘驱动来达成目的
  - 微内核下，文件系统和硬盘驱动都处于和应用同样的特权级下，应用借由微内核使用文件系统的服务。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051948384.png" alt="image-20220705194817287" style="zoom:67%;" />
- 讲了一些微内核的历史，典型的微内核Mach、 QNX、 Fuchsia（Zircon）、MINIX。
- **微内核的优点：**
  - 易于扩展：因为服务都是一个处于用户态的模块，新增服务的时候不需要对内核进行修改
  - 易于移植：移植八千七百行代码比移植两千万行代码容易得多。
  - 可靠：微内核的代码量相比宏内核少很多，复杂度低很多，出现问题的概率就低。
  - 安全和健壮：模块与模块之间的隔离做的更好，即使有一个模块崩溃了（某个服务崩了），也只需要重启这个模块，而不是重启整个内核。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051953454.png" alt="image-20220705195318363" style="zoom:67%;" />
- **微内核的缺点**：
  - 最主要的缺点就是性能太差，因为不同服务模块之间的交互由函数调用变成了进程间的通信。
    - 宏内核内函数调用的方式交互可能只要30个时钟周期，微内核下需要4500个。
    - 服务A到内核到服务B的4500个，一部分是上下文切换，状态保存和恢复，进程的调度，参数的复制等等。
  - 生态不完善。
  - 重用问题：为了给宏内核系统提供兼容性（比如兼容为宏内核设计的应用），重用宏内核的代码，带来的新问题，典型的例子Mach2.5。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052004051.png" alt="image-20220705200433961" style="zoom: 67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207051958613.png" alt="image-20220705195817521" style="zoom:67%;" />

## 混合内核架构

- 将宏内核与微内核的优点结合起来。需要性能的模块重新放回内核态。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052011079.png" alt="image-20220705201112980" style="zoom:67%;" />
- Windows NT:随便看看吧
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052012217.png" alt="image-20220705201207116" style="zoom:67%;" />
- macOS：也随便看看
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052012366.png" alt="image-20220705201233261" style="zoom:67%;" />

## 外核架构(EXOKERNEL)

- 基本思想：
  - **外核不提供对硬件的抽象，而是将锅甩给应用本身。**
  - **外核只负责管理应用，不负责管理资源，但是负责将资源与应用的绑定，以及资源的回收**
  - 但是操作系统是服务应用加管理应用，其中管理应用由外核负责了，针对服务应用部分，外核也提供一个用户态下的库，libOS。
  - 如果应用不愿意自己去抽象硬件资源，就可以使用libOS提供的库（抽象）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052043533.png" alt="image-20220705204337441" style="zoom:67%;" />
- 关于库OS：
  - 对硬件的抽象以库的形式提供，带来了更高的性能以及更高的可定制性。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052046489.png" alt="image-20220705204652393" style="zoom:67%;" />

- 外核架构的设计：
  - 目的应该就是能够完成外核的管理应用、回收和绑定应用与资源的功能。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052048311.png" alt="image-20220705204857228" style="zoom:67%;" />
- 安全绑定：
  - 允许某个LibOS访问某些计算资源，同时防止其他LibOS访问。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052050053.png" alt="image-20220705205011955" style="zoom:67%;" />
- 显式回收：
  - 应用应该在租期结束之前主动归还资源，如果超时不归还资源，则强制中止，主动解除资源与应用之间的绑定。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052052791.png" alt="image-20220705205252699" style="zoom:67%;" />
- Unikernel（单内核）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052054484.png" alt="image-20220705205453393" style="zoom:67%;" />
- 外核的优缺点分析：
  - 它的优点同样也带来了它的缺点。
  - 由于外核不对硬件资源做抽象，所以应用可以针对自己的需求做最符合自己的抽象，理论上能有最优性能，应用也对硬件有更精确的控制。
  - 但是由于对硬件资源的抽象是由应用本身来做的，所以对计算资源的利用效率主要取决于应用本身，如果应用本身实现的抽象不好，就寄。
  - 定制化过多也导致维护的问题。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052110548.png" alt="image-20220705211052452" style="zoom:67%;" />

## 多内核/复内核(MULTI-KERNEL)

- 背景：
  - 硬件上有多个核心，每个核心的架构可能不一样。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052121773.png" alt="image-20220705212149675" style="zoom:67%;" />

- 大概的思路：
  - 每个核心上运行一个属于自己的内核，但是这个细节对于上层的应用来说是不可见的（透明的），整个OS是个分布式系统，但是应用程序看来和非多内核架构没有什么区别。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207052122098.png" alt="image-20220705212213002" style="zoom:67%;" />





# 5.内存管理1

- 对于内存来说，使用物理地址的缺点：
  - 一个应用会因为其他应用的加载而受影响，例子：
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207060122179.png" alt="image-20220706012245110" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207060122135.png" alt="image-20220706012210030" style="zoom:67%;" />
- 引进一个方法，让进程“看不见”物理地址：于是就引出了以虚拟内存抽象为核心的内存管理。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207060123072.png" alt="image-20220706012349989" style="zoom:67%;" />
- 以虚拟内存为核心的内存管理：
  - 虚拟内存这个功能是CPU提供的，是属于硬件层次提供的，而不是OS提供的。（当然你非得写一个软件来模拟这个过程也是可以的）
  - 所有的软件，**包括操作系统本身**，都使用虚拟地址，无法直接访问物理地址。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207060125431.png" alt="image-20220706012556353" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207060133965.png" alt="image-20220706013326866" style="zoom:67%;" />

## 地址翻译过程

### 分段机制

- MMU: Memory Manage Unit
- 分段机制属于是历史遗留，现在实践中使用最多的是分页机制。
- 基本原理：
  - 虚拟地址分为两部分：段号 + 段内地址，其中段内地址是相对于本段起始地址的偏移量，段号可以看做是相对于段表起始地址的偏移量。
  - CPU中新增一个段表基址寄存器，用于保存段表的起始地址。
  - 由虚拟地址翻译为物理地址的过程如下：
    1. 段号加上段表基址寄存器中的段表起始地址，得到本段在段表中所在的位置。
    2. 查表得到本段的段起始地址和本段长度，将本段的段起始地址加上段内地址，得到真实的物理地址。
    3. 通过本段长度，能够判断得到的物理地址是否处于不可访问的内存位置（超出可以访问的地址范围）。
  - 物理内存也以段为单位进行分配，**但虚拟地址空间中相邻的段，对应的物理内存可以在物理位置上不相邻**。
  - 缺点：粒度太粗，分配不够精细。由此引入粒度更细的虚拟地址机制：分页。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207060147351.png" alt="image-20220706014733246" style="zoom: 80%;" />

### 分页机制

- 将物理内存划分为粒度更小的单位来管理，可以更好地解决分段机制带来的外部碎片问题。
- 将物理内存划分为等长的、连续的物理页，一般以4KB为一页，也即$2^{12}B$，所以32位的机器，20位页号，12位页内地址。
- **虚拟页和物理页的页长相等，任意虚拟页可以映射到任意物理页。**
- 虚拟地址分为两部分：页号 + 页内地址（页内偏移）
- 主流CPU均支持分页机制，可以完全替代掉分段机制。

#### 页表：分页机制的核心数据结构

- **每个进程都有属于自己的独立的页表**，因为每个进程它的地址空间的使用情况是不一样的。
- 页表是虚拟页号和物理页号的一个映射关系。可以将页表看作是一个物理页号的数组，虚拟页号则将其看作是数组的index。
  - 所以一般不是将虚拟页号和物理页号都显式存起来，而使用一个数组，数组的下标是虚拟页号，对应下标单元的值是物理页号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207070939483.png" alt="image-20220707093901249" style="zoom:67%;" />

#### 单级页表的问题

- 假定是32位的地址，12位页内地址 + 20位页号，每一页是$4KB(2^{12}B)$。
  - 32位地址，总共按字节编址可以有$2^{32}$字节的物理内存。
  - 这么多物理内存，按照4KB一页，可以划分出$2^{20}$页。
  - 而假定使用`int`作为页号（实际上4B并不是一个`int`，只是为了简化问题），则页表数组的大小为$2^{20} * 4$字节，也即$4MB$。
- 假定是64位的地址，按字节编址，同样按照4KB一页来分页，但是不能同样使用`int`来做页号（因为不够，当然也是为了简化问题），使用8B的`long`。
  - $2^{64}$字节物理内存可以分为$2^{52}$页，则页表数组需要$2^{52} * 8$字节，即$2^{15}TB,33554432GB$。
  - 因此对于64位的机器来说，单级的页表是不可接受的，光页表本身的大小就超出一般电脑的硬盘空间。
- 引出多级页表：虽然并没有讲清楚多级页表是怎么工作的
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207070958981.png" alt="image-20220707095859844" style="zoom:67%;" />
- ARM64的四级页表：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071001792.png" alt="image-20220707100116637" style="zoom:67%;" />

#### 64位虚拟地址翻译

- 虚拟地址空间的大小并不是64位，而是48位（剩余的没用到的空位为全0或者全1），因为64位真的太多了，没这个必要。
- 页表基址寄存器：X86-64中只有一个CR3，而ARM64架构下有两个，TTBR0_EL1和TTBR1_EL1，内核和应用各用一个。
- 64位这么划分：
  - 63-48位，共16位，全0或者全1
  - 47-39位，0级页表索引，以此类推
  - 最低的12位（0-11）为页内偏移。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071007703.png" alt="image-20220707100709528" style="zoom:67%;" />

#### 页表使能

- CPU通电的初期是使用的物理寻址模式，此时OS使用的是物理寻址（因为虚拟地址还没配置）
- 系统软件配置好控制寄存器，使能页表，才进入虚拟寻址模式。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071039781.png" alt="image-20220707103959620" style="zoom:67%;" />

#### 页表页

- 这两部分没太听明白。看CS162补吧。
- 每个页表页有512个页表项：
  - 虚拟页表和物理页表是一样大的，都是4KB，每个页表项8B，4K / 8 = 512项。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071042108.png" alt="image-20220707104203967" style="zoom:67%;" />

#### 

#### ARM64的页表项

- 没太听明白，先放这里。

### ARM的Cache Lockdown特性

- 就是把某些数据锁定在Cache里面，使得它永远不会被替换出去。
- 没有统一的标准，取决于具体的实现，也可以不实现。
- 只有ARM有，X86-64架构无。
- 可以提高性能，加强安全性。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071051274.png" alt="image-20220707105123108" style="zoom:67%;" />

### TLB：地址翻译的加速器

- 多级页表是不完美的，是典型的用时间换空间的设计。
  - 减小了页表所占的空间，但是增加了访存的次数。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071052413.png" alt="image-20220707105258271" style="zoom:67%;" />

- 因此才有了TLB，用来加速访存

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071054411.png" alt="image-20220707105410249" style="zoom:67%;" />

- TLB的设计思想就是Cache。
- TLB位于CPU的内部，缓存了虚拟页号到物理页号的映射。
  - 有限数目的TLB缓存项
  - 在地址翻译的过程中，内存管理单元MMU首先访问TLB，如果TLB命中，则不再查询页表，未命中则查询页表。
- TLB管理：应该缓存哪些映射？
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071056617.png" alt="image-20220707105653459" style="zoom:67%;" />

# 6.内存管理2

## TLB刷新

- TLB使用的是虚拟地址索引，所以在切换页表的时候，由于切换了虚拟地址空间，所以需要对TLB全部进行刷新
- 但是如果每次都对TLB全部进行刷新的话，效率会低一些（比如一个还没执行多久的进程被调度走，TLB没用多久就被刷新了，然后下次轮到这个进程，又要重新完全刷新），所以会有一些优化。
- 基于架构的一些优化：
  - ARM架构下，内核和进程使用的是不同的页表，使得在系统调用的过程中不需要进行页表的切换（也即不需要刷新TLB）
  - X86-64架构下，内核映射到应用页表的高地址，避免系统调用的时候刷新TLB的开销。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071649301.png" alt="image-20220707164923126" style="zoom:67%;" />
- 如何降低TLB刷新的开销：没太听明白（）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071701916.png" alt="image-20220707170140790" style="zoom:67%;" />

## 物理内存的超售(Over-commit)和按需分配

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071705778.png" alt="image-20220707170510674" style="zoom:50%;" />

## 换页机制（Swapping）

- 解决情景一的方法之一，换页机制。
- 基本思想：将物理内存存不下的内容先存放到磁盘上（专门划分出一个Swap分区），需要的时候再取回来放回内存里。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071709074.png" alt="image-20220707170937967" style="zoom:67%;" />

### 缺页异常

- 需要提前写好（注册）处理缺页异常的处理函数，发生缺页异常时CPU将控制流传递给这个函数
- X86-64架构下，缺页异常#PF,异常号13，错误地址在CR2寄存器。
- ARM64架构下，触发通用的同步异常（8号），根据ESR信息判断是否缺页，错误地址在FAR_EL1
- ESR: Exception State Register
- FAR_EL1: Fault Address Register，EL1是内核态。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071713080.png" alt="image-20220707171318960" style="zoom:67%;" />



### 按需分配中的权衡

- 换页机制所带来的的问题是缺页异常所导致的的访问延迟增加。
- 为了解决这个问题，在缺页异常处理函数中采用预取机制。
  - 因为时间和空间上的局部性原理，所以可以在取某一页的时候，把这一页附近的页也一并提前取出来。
  - 这样可以减少缺页异常的次数
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071736482.png" alt="image-20220707173640350" style="zoom:67%;" />

### 页替换策略

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207071737910.png" alt="image-20220707173712804" style="zoom:67%;" />

### Thrashing Problem

- 直接导致这个问题的原因：过于频繁的缺页异常（对物理内存的需求总和过大）
- 由于所有上层应用对物理内存的需求过大，导致各个应用都求助于缺页机制。
- 于是CPU的大部分时间都在用于处理缺页异常，这段时间内CPU会等待缓慢的IO，而调度器则可能会调度其他进程，但是其他进程也缺页，触发更多的缺页异常，情况恶化。最终CPU仅有小部分时间用于执行有用的工作。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072018522.png" alt="image-20220707201846373" style="zoom: 60%;" />

- 解决这个问题的模型：工作集模型

### 工作集模型（Working Set Model）

- 一个进程在时间t的工作集$W(t,x)$：
  - 一个进程的工作集是这个进程在时间$(t -x,t)$内使用的内存页的集合。
  - 这个工作集也被视为这个进程在未来的时间内（下一个x）会访问的页的集合。
  - 如果希望进程工作顺利，则需要将这个进程的工作集保持在内存中。
- 工作集在内存中是一种*all or nothing*的模型，要么全部都在内存中，要么全部不在内存中，一部分在一部分不在只会导致颠簸。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072112467.png" alt="image-20220707211223341" style="zoom:67%;" />

- 跟踪工作集$W(t,x)$：
  - 处理函数定期扫描进程的内存页，然后更新时间戳以及标记。
  - 访问位为1的（说明最近被访问过），将其最近使用时间置为当前时间。
  - 访问位为0的（说明最近没被访问过），计算其上一次使用到现在已经过了多久（多久没使用了），如果时间差大于x，则视为不在工作集内。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072114077.png" alt="image-20220707211437951" style="zoom:67%;" />

## 物理内存管理

- 内存控制器将内存抽象为一个大的可按字节寻址的数组。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072123675.png" alt="image-20220707212355553" style="zoom:67%;" />
- 物理内存中存在的碎片问题：
  - 外部碎片：空闲的但是不连续的空间，每个单独的空闲碎片都不足以满足某个应用的内存需求，因此只能空闲在那里。
  - 内部碎片：给应用分配的内存大小大于实际需要。
- 物理内存管理的评价指标：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072126774.png" alt="image-20220707212616655" style="zoom:67%;" />

### Buddy System

- 将一块大的物理内存一分为二，互为兄弟块，每块兄弟块又可以再一分为二，变为更小兄弟块。兄弟块又可以合并，二合一得到一个更大的兄弟块。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072155766.png" alt="image-20220707215533637" style="zoom:67%;" />
- Buddy System的例子：
  - 首先确定一个问题：分配合适大小的块，什么是“合适”？
    - 就是比需求更大的，但是又是最接近它的。
    - 比如需求15K内存，以页表的4K为单位，16K内存分配是最合适的。
  - Buddy System分配的最小单位是一个物理页。
  - 下图的链表数组，每个2的幂次表示的是以页表为单位的个数（1个表，4K，2个表，8K,etc)。
  - 以分配15K内存为例，最合适的大小是16K，4个页表。
  - 于是将$2^3$对应的一个32K的块拆分成两个16K的块，其中一个分配掉，另外一个插入$2^2(4片 * 4KB/片 = 16)$对应的链表。
  - 小的块可以反过来合并，当然也可以继续拆分，比如需要一个1K的内存，那就把8K的拆出一个4K给它。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072157003.png" alt="image-20220707215753881" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072209230.png" alt="image-20220707220939111" style="zoom:67%;" />

### 建立在伙伴系统上的分配器

- 伙伴系统只缓解了外部碎片的问题，但是内部碎片的问题没有得到很好的缓解。
- 由于操作系统中的某些数据结构常为几十或者几百字节（而一个页4KB），所以需要有办法避免内部碎片。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072223028.png" alt="image-20220707222352897" style="zoom:67%;" />
- SLUB的基本思想和设计：
  - 由于操作系统是提前写好的，在操作系统写好的那一刻起，我们可以知道操作系统频繁分配的对象有哪些，大小固定在哪个范围。
  - 所以可以针对内核进行优化。基本思想看图
  - n小于12，是因为n等于12的时候内存恰好是4KB，这种情况下Buddy System可以解决问题。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072224741.png" alt="image-20220707222429625" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072224106.png" alt="image-20220707222444985" style="zoom:67%;" />

## 物理内存管理的其它问题

### 安全问题

- 科普性质

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072238734.png" alt="image-20220707223809618" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072238317.png" alt="image-20220707223830206" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072238499.png" alt="image-20220707223843391" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072238355.png" alt="image-20220707223859245" style="zoom:67%;" />

### 操作系统内存管理的功能

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072239217.png" alt="image-20220707223923092" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072239710.png" alt="image-20220707223940588" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072239642.png" alt="image-20220707223958522" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072240050.png" alt="image-20220707224014939" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072240582.png" alt="image-20220707224046477" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207072241568.png" alt="image-20220707224113434" style="zoom:67%;" />

# 7.进程管理

- 早期的计算机是只能一次执行一个任务，多任务是随计算机的发展历程演变而来的

## 进程的诞生





<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207080938222.png" alt="image-20220708093807984" style="zoom:67%;" />

## 进程：运行中的程序

- 进程是运行中的程序的抽象，每个进程包括两部分
  - 静态的部分：程序运行需要的代码和数据
  - 动态部分：程序运行期间的状态（程序计数器的值、堆、栈）
- 每个进程都有独立的虚拟地址空间，给进程一种独占全部内存的假象
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207080950333.png" alt="image-20220708095003104" style="zoom:67%;" />

## 简化

- 简化模型，假定每个进程都只有单一的线程。更加便于理解操作系统中的各种概念。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207080953244.png" alt="image-20220708095339030" style="zoom:67%;" />

## 进程的状态

- 除了下图的五种状态，还有一种Zombie状态，僵尸进程。
  - 僵尸进程：那些已经完成了任务的执行，等待进程的某些资源被回收的进程。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207080957239.png" alt="image-20220708095742020" style="zoom:67%;" />

- 当一个进程被初始化，它进入预备状态，当被调度器调度到时，进入运行状态。如果运行的过程中出现外部事件，如IO，则进入阻塞态等待外部事件，外部事件完成后回到预备态（而不是运行态，因为会被调度）

## 进程的相关数据结构：Process Control Block

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081003596.png" alt="image-20220708100342372" style="zoom:67%;" />

- PCB，进程控制块。用于存放进程的状态，进程切换时会用到。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081006879.png" alt="image-20220708100622629" style="zoom:67%;" />

## fork()

- 父进程和子进程共享文件描述符，会导致它们在文件中的偏移量也共享。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081008586.png" alt="image-20220708100802376" style="zoom:67%;" />

- 示例，输出是那样是因为文件描述符共享，偏移量也共享
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081016530.png" alt="image-20220708101617304" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081016761.png" alt="image-20220708101634559" style="zoom:67%;" />

- 进程树与进程组：
  - 子进程默认与父进程一个进程组。可以向同一进程组中的所有进程发送信号。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081019520.png" alt="image-20220708101925275" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081022733.png" alt="image-20220708102211515" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081022566.png" alt="image-20220708102231339" style="zoom:67%;" />

## exec()

- `exec()`在载入可执行文件后会重置地址空间。

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081020432.png" alt="image-20220708102035234" style="zoom: 67%;" />

## fork的替代接口

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081027852.png" alt="image-20220708102721644" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081027660.png" alt="image-20220708102740461" style="zoom:67%;" />

## 线程

- 为什么需要线程？
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081039824.png" alt="image-20220708103933622" style="zoom:67%;" />
- 线程是更加轻量级的运行时抽象。
  - 线程只包含运行时状态（执行时所需要的最小状态），静态的部分由进程提供。
  - 一个进程可以包含多个线程，每个线程共享同一地址空间，方便数据共享和交互
  - 允许进程内通过多线程并行，占用多个CPU。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081043317.png" alt="image-20220708104304134" style="zoom:67%;" />
- 一个进程可以有多个线程，每个线程可以在不同的处理器上同时执行，调度的基本单位由进程变成线程，每个线程都有状态，上下文切换的单位也变为了线程。
- 多线程的地址空间：
  - 每个线程有自己的栈
  - 内核中也有为线程准备的内核栈。
  - 数据和代码以及堆共享。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081051869.png" alt="image-20220708105157698" style="zoom: 67%;" />
- 用户态线程与内核态线程
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081054794.png" alt="image-20220708105407579" style="zoom:67%;" />

### 线程模型

- **线程模型表示了用户态线程与内核态线程之间的联系**主要是为了调度
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081058342.png" alt="image-20220708105818134" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081118179.png" alt="image-20220708111759949" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081118166.png" alt="image-20220708111820917" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081118717.png" alt="image-20220708111838516" style="zoom:67%;" />

### 线程相关的数据结构：TCB

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081120235.png" alt="image-20220708112021051" style="zoom:67%;" />

### 线程本地存储

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081122658.png" alt="image-20220708112255450" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081122440.png" alt="image-20220708112241239" style="zoom:67%;" />

### 线程操作

- 反正就是些API呗。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091640151.png" alt="image-20220708141712701" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081419622.png" alt="image-20220708141924437" style="zoom:67%;" />

### 线程的上下文切换

- 线程的上下文：即一些重要的寄存器信息等
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081421374.png" alt="image-20220708142105221" style="zoom:67%;" />
- 上下文切换共三步：
  - 进入内核态，保存上下文
  - 切换页表与内核栈（通过切换栈指针）
  - 恢复上下文，返回用户态

#### 1.进入内核态，保存上下文

- 线程可以通过系统调用、异常、中断进入内核态
  - 运行状态切换为内核态（EL_1)
  - 开始使用SP_EL1作为栈指针
  - 保存应用线程的PC的值（elr_el1）
  - 保存应用的CPU状态（spsr_EL1）
  - 均由硬件完成
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081433416.png" alt="image-20220708143355208" style="zoom:67%;" />

#### 2.切换页表和内核栈

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081434101.png" alt="image-20220708143446911" style="zoom:67%;" />

#### 3.上下文恢复，返回用户态

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081435705.png" alt="image-20220708143557520" style="zoom:67%;" />



<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081437355.png" alt="image-20220708143750160" style="zoom:67%;" />

## 纤程

- 纤程的存在是由于一对一线程模型存在的局限性。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081440578.png" alt="image-20220708144058374" style="zoom:67%;" />



- 纤程是更加轻量级的运行时抽象。
  - 它不单独对应内核线程
  - 一个内核线程可以对应多个纤程（多对一模型）。

- 纤程的优点:
  - 不需要创建内核线程，开销小
  - 上下文切换快
  - 允许用户态自主调度，有助于做出更优的调度决策。

#### Linux对纤程的支持

- 每个ucontext可以看作一个用户态线程
  - makecontext: 创建新的ucontext
  -  setcontext:纤程上下文切换
  - getcontext:保存当前的ucontext
- 栗子：
  - 生产者-消费者模型。
  - 主纤程看做`main()`。
  - 主纤程先创建生产者纤程，然后创建消费者纤程。创建完两个纤程之后，调用`setcontext()`将纤程上下文切换为生产者纤程。
  - 生产者在进行生产后，调用`setcontext()`将纤程上下文立即切换为消费者。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081448673.png" alt="image-20220708144838466" style="zoom:67%;" />
- 从栗子来看，纤程的优势：
  - 纤程的切换及时，生产者生产完毕后立即切换到消费者，并且对于该进程来说是最优的调度选择。
  - 上下文切换高效，切换不进入内核态，开销小。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081451238.png" alt="image-20220708145154987" style="zoom:67%;" />



# 8.进程/线程调度

- 什么是调度？
  - 协调请求对于资源的使用。可能会有很多个请求和很多个资源，如何协调请求与资源之间的关系。
- 调度需要做的决策？
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081523584.png" alt="image-20220708152330377" style="zoom:67%;" />
- 什么时候一个进程/线程执行结束（能够被调度走）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081523245.png" alt="image-20220708152348094" style="zoom:67%;" />

- 调度器在不同的场景下有不同的目标，所以不存在处处适用的调度器
  - 但是都有一些共有的目标：高资源利用率、多任务公平性、低调度开销。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081531136.png" alt="image-20220708153123920" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081530422.png" alt="image-20220708153020234" style="zoom:67%;" />
- 调度存在的挑战：
  - 缺少信息，永远不可能有完整的信息，这一秒的最佳决策可能下一秒就不适用了。
  - 线程、任务之间的复杂交互
  - 调度目标的多样性，面向不同的场景会有不同的调度目标。
  - 由于调度要考虑的因素很多，往往存在大量的tradeoff。
- 调度：策略 $\ Versus\ $机制
  - 策略是要做什么，从上层去分析问题、提出解决问题的方法。
  - 机制是怎么做，怎么去实现这个提出来的方法。



## Linux中的调度策略

- 满足不同的需求提供多种不同的调度策略
- Linux的一种调度器对应多个调度策略。
  - 完全公平的调度器：三种
  - 实时调度器：两种
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081537961.png" alt="image-20220708153743743" style="zoom:67%;" />

##  经典的调度策略

- 接下来的调度策略都以学霸给同学解答问题的模型来比喻
  - 学霸相当于CPU，同学相当于用户，同学的问题相当于任务，学霸调度问题相当于CPU调度任务
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081553164.png" alt="image-20220708155303947" style="zoom:67%;" />

### First Come First Served

- 先来先服务策略。
- 优点和缺点都很明显。
- 优点是简单直观，调度很简单。
- 问题在于，平均的周转和响应时间过长。对于C这样问题简单用时少但是来得晚的用户来说，响应时间太长。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081556944.png" alt="image-20220708155616734" style="zoom:67%;" />

### Shortest Job First

- 用时最短的工作优先策略。
- 相对于先来先服务策略，优化了同学C这样的用户的平均周转和响应时间。
- 第一个服务的是A，是因为A是第一个到达的，A到达之前没有任务，A到达的时候它就是最短的那个任务。
- B和C到达之后，由于C的工作量（问题需要的时间）短于B，所以C先于B得到调度。
- 优点是优化了C这样的情况，但是带来了新的问题。
- 像B同学这样的情况就很容易陷入被饿死的境地
  - 假定后续来了多个同学DEFG，他们每个人的任务的用时都短于B，则它们会被优先于B调度。
  - 而B虽然是最先到达的，但是却等待了极长的时间，陷入了饿死的境地。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081600871.png" alt="image-20220708160049630" style="zoom:67%;" />

### 抢占式调度(Preemptive Scheduling)/Round Robin (时间片轮转)

- 就是时间分片，然后每个同学轮流抢占一个时间片。时间片到头之后不管任务有没有执行完，都直接调度到下一个同学（任务）
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081611012.png" alt="image-20220708161111819" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081611045.png" alt="image-20220708161144848" style="zoom:67%;" />

- 关于时间片轮转的一些思考题：
  - 过长的时间片会导致回归到先来先服务的策略（比如时间片的长度比所有任务所需时间的最大值还长）
  - 过短的时间片会导致CPU陷入频繁的上下文切换（调度）中，大部分时间在上下文切换（调度），小部分时间干活。
  - 当一堆任务用时差不多的任务同时需要调度时，RR的周转时间问题最为明显（因为每个人都要等到最后一轮才能完成工作）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081612446.png" alt="image-20220708161230260" style="zoom:67%;" />

## 优先级调度

- 操作系统中不同的任务的优先级是不同的，正处于前台的任务一般来说优先级更高
- 如果不对任务的优先级加以区分，系统的关键任务就无法处理。体验会很差
- 优先级用于确保重要的任务被优先调度

### 添加优先级

- 使用同样的学霸和问题的比喻，加入优先级：女生优先。
- 于是会有多个任务队列，高优先级的队列中的任务优先于低优先级队列中的任务执行。
- 处于同一个优先级队列的任务之间使用时间片轮转的方式调度。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207081641597.png" alt="image-20220708164111379" style="zoom:67%;" />

### 添加条件

- 采用同样的比喻，这次还添加一个条件：阅读OS书 （类比I/O操作）
- 阅读完OS书之后，同学才能和学霸交流。

- 但是这样带来了一系列的问题：
  - 低资源利用率，多种资源（学霸和OS书）没有同时被利用起来。
  - 优先级反转

#### 问题1，低资源利用率

- A和C需要看书，但是A和C的优先级低于B和D，只有调度到低优先级的AC的时候书才会被使用。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082017373.png" alt="image-20220708201738136" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082020961.png" alt="image-20220708202040815" style="zoom:67%;" />

#### 问题2，优先级反转

- 不管高优先级任务还是低优先级任务，都需要独占共享资源。当低优先级任务占用资源时，会导致高优先级的任务被阻塞。
- 假定优先级A>B>C，且只有A和C需要共享书。
- 由于C最开始占有了共享资源书，导致A被阻塞，而B不需要OS书且优先级又高于C，则B先于A运行（而不是最高优先级的A先运行）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082021071.png" alt="image-20220708202156858" style="zoom:67%;" />

- 解决方法：优先级继承
  - A在发现自己需要的书被低优先级的C占用之后，先让C继承自己的优先级，以使得C能够尽快归还书。
  - 由于C继承了A的优先级，所以C先于B运行，则B不会成为第一个运行的。
  - C运行完毕之后，将书以及优先级归还给A，A就可以开始运行。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082027301.png" alt="image-20220708202719117" style="zoom:67%;" />

## 公平共享调度

- 这种调度是有意义的。
- 场景：在云计算平台多租户共享处理器的情况下，每个租户交的钱是一样的，需要保持每个用户占用的CPU时间应该也是一样的。
- 不能因为其中一个用户发起的进程更多而分配给它更多的CPU时间。资源的分配应该按照比例来进行。
- 这种情况下就不能使用时间片轮转的调度策略
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082036774.png" alt="image-20220708203614595" style="zoom:67%;" />
- 什么是公平共享：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082038425.png" alt="image-20220708203814282" style="zoom:67%;" />
- 公平共享的方法：
  - 随机抽奖调度：
    - 每次调度生成一个随机数，落在哪个任务所在的区间内，就执行哪个任务。
    - 比如A1 A2 B1的资源比例是2 3 5。
    - 随机一个100以内的随机数，落在0-19则执行A1，20-49则执行A2，否则B1。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082051522.png" alt="image-20220708205156366" style="zoom: 50%;" />
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207082047333.png" alt="image-20220708204747163" style="zoom:67%;" />
- **优先级与权重的异同？**
  - 二者都是资源占比的一种反映。
  - 权重影响任务对CPU的使用比例，但是能保证不管多低的权重，都一定有CPU时间分配给你，你不会饿死。
  - 优先级影响任务对CPU的使用顺序，但是不能保证低优先级的任务一定会有CPU时间分配给你（比你优先级高的任务源源不断），这个低优先级的任务可能会饿死。
- 对抽奖调度做改进得到的确定性版本的抽奖调度
  - Stride Scheduling
  - ticket是各个用户所占资源的比例。步幅 = 最大步幅 / 比例。
  - 步幅是任务每执行一次增加的虚拟时间，比例越小步幅越大，每执行一次增加的虚拟时间就越多。
  - 保证每个任务的总虚拟时间一样的情况下，即可保证按比例公平分配资源（CPU时间）
  - **Pass / stride = 执行次数 = Pass * ticket / MaxStride，执行次数与ticket成正比。**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091443909.png" alt="image-20220709144301710" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091447055.png" alt="image-20220709144708923" style="zoom:67%;" />

# 9.进程间通信

- 独立进程所带来的问题（进程直接完全独立）
  - 大量重复实现。聊天软件和邮件软件都依赖数据库，各自实现一份在自己的进程中
  - 低效实现。聊天软件的数据库实现经过精心的优化，邮件软件团队的开发重心在其他组件上。
  - 没有信息共享。邮件和聊天软件都需要监控系统资源信息，即使邮件软件已经完成了计算，聊天软件也要重新计算一遍。
- 进程协作的好处：
  - 模块化: 数据库单独在一个进程中，可以被复用
  - 加速计算: 不同进程专注于特定的计算任务，性能更好
  - 信息共享: 直接共享已经计算好的数据，避免重复计算

## 进程间通信(Inter-process Communication, IPC)

- **进程协作的达成依赖于进程间通信**。
- **进程间通信**：两个或多个不同的进程，通过**内核或其他共享资源**进行通信，来传递控制信息或数据
  - 交互的双方: 发送者/接收者、客户端/服务端、调用者/被调用者
  - 通信的内容一般叫做“消息”
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091520944.png" alt="image-20220709152015806" style="zoom:67%;" />

### 共享内存

- 系统内核为两个进程映射共同的内存区域。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091557090.png" alt="image-20220709155729942" style="zoom:67%;" />
- 共享内存所带来的挑战：
  - 发送者不能覆盖掉未读取的数据
  - 接收者不能读取别的数据
- 基础实现：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091557380.png" alt="image-20220709155755233" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091558751.png" alt="image-20220709155811606" style="zoom:67%;" />
- 基础实现的问题：
  - 发送者和接收者都存在空等待的情况，在这种情况下大部分时间都处于空等待占用CPU资源浪费时间之中。
  - 发送者在缓冲区满时要一直轮询，接收者在缓冲区空时要一直轮询。
  - 不是很好的解决办法：固定一个时间检查，但是时延会长，比如早上发的消息，晚上才能被检查到，如果缓冲区满了，则有相当一段时间不能发送方在干等。
  - 解决方法：加入消息系统。通过中间层保证通信时延，消息本身的传递仍然使用共享内存。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091616632.png" alt="image-20220709161616482" style="zoom:67%;" />

### 消息传递

- 基本操作：发送消息和接收消息。
- 如果两个进程P和Q希望通过消息传递进行通信，需要建立一个通信连接，通过Send/Recv接口进行消息传递。
- 直接通信：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091617808.png" alt="image-20220709161745654" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091618734.png" alt="image-20220709161815586" style="zoom:67%;" />

### 间接通信

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091619249.png" alt="image-20220709161906100" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091625803.png" alt="image-20220709162528652" style="zoom:67%;" />

- 间接通信：
  - 服务原语需要指定一个信箱，从哪个信箱接收，发送给哪个信箱。
  - 进程之间共享一个信箱时，这两个进程建立连接。
  - 每对进程可以有多个连接。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091619125.png" alt="image-20220709161927976" style="zoom:67%;" />

- 通过信箱间接通信可能存在的问题：
  - 用快递员和收快递的小明和妈妈为例。
  - 三者属于同一个信箱，每次有小明的快递时，快递员往信箱发送消息，小明和妈妈会同时收到消息。
  - 由于小明和妈妈彼此都不知道对方是否会去拿快递，就有可能两个人会同时出门取快递。
- 间接通信带来的挑战以及可能的解决办法：
  - 第一个方法没有解决最开始的问题（小明不看手机）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091626479.png" alt="image-20220709162635338" style="zoom:67%;" />

### 消息传递的同步与异步

- 还是以快递为例
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091628655.png" alt="image-20220709162801508" style="zoom:67%;" />
- **消息的传递可以是阻塞的，也可以是非阻塞的**
- **阻塞通常被认为是同步通信**
  - 阻塞的发送/接收: 发送者/接收者一直处于阻塞状态，直到消息发出/到来
  - 同步通信通常有着更低时延和易用的编程模型

- **非阻塞通常被认为是异步通信** 
  - 发送者/接收者不等待操作结果，直接返回
  - 异步通信的带宽一般更高 (快递员可以送更多的快递)
- 使用超时机制可以将阻塞的通信和非阻塞的通信结合起来：
  - 阻塞一段时间，超时之后就不再阻塞，返回一个错误信息。
  - 将超时时间设置为0，就是不等待的非阻塞（异步）通信。
  - 将超时时间设置为无穷，就是一直等待的阻塞（同步）通信。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091632074.png" alt="image-20220709163252902" style="zoom:67%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091635964.png" alt="image-20220709163552798" style="zoom:67%;" />

### 缓冲区

- 桌子的作用就相当于缓冲区

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091636553.png" alt="image-20220709163620397" style="zoom:67%;" />

- 缓冲区：缓存已经收到但是还没有被处理的消息。
- 常见的三种缓冲区设计：
  - 零缓冲、有限缓冲、无限缓冲
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207091639772.png" alt="image-20220709163723614" style="zoom:67%;" />

## UNIX经典IPC

### 管道

- 管道(Pipe): 两个进程间的一根通信通道
  - 一端向里投递，另一端接收
  - 管道是间接消息传递方式，通过共享一个管道来建立连接 
  - 例子: 我们常见的命令 ls | grep，将ls的输出传递给grep作为输入，grep是在给定输入中查找含有给定字符串（作为子串）的程序
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092059787.png" alt="image-20220709205931647" style="zoom:67%;" />
- 管道的特点：
  - 单向通信，当缓冲区满时阻塞，只有一个发送方和一个接收方。
  - 一个管道有且只能有两个端口: 一个负责输入 (发送数据)，一个负责输出 (接收数据)，两个端口都是进程。
  - **数据不带类型，即字节流**
  - 基于Unix的文件描述符使用。一个描述符负责读，另外一个描述符负责写。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092100846.png" alt="image-20220709210055717" style="zoom:67%;" /> 
- 管道数据结构，以Unix xv6为例：
  - 一个互斥锁，用于同步。
  - 第一个`uint`是要读出的字节数
  - 第二个`unit nwrite`是要写入的字节数
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092101029.png" alt="image-20220709210156866" style="zoom:67%;" />

- 管道的写操作的实现：
  - `acquire()`用于获取一个互斥锁。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092104142.png" alt="image-20220709210439986" style="zoom:67%;" />
- 管道写操作的实现：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092106729.png" alt="image-20220709210655574" style="zoom:67%;" />
- 关于`sleep()`和`wakeup()`：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092107824.png" alt="image-20220709210753669" style="zoom:67%;" />
- 管道的优缺点：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092108533.png" alt="image-20220709210830390" style="zoom:67%;" />

### 消息队列: 带类型的消息传递

- 消息队列是共享的，间接的消息传递方式，任何一个有权限的进程都可以访问，写入或者读取。支持异步通信
- 消息队列是带类型的，格式为数据类型 + 数据，一个链表。类型由一个整数表示。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092110863.png" alt="image-20220709211049696" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092111035.png" alt="image-20220709211123886" style="zoom:67%;" />

- 消息队列对比管道：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092111107.png" alt="image-20220709211146958" style="zoom:67%;" />

## 轻量级远程方法调用 (LRPC)

- Unix进程间通信机制通常十分重量级。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092112718.png" alt="image-20220709211235565" style="zoom:67%;" />

- 轻量级远程方法调用主要解决的问题：
  - 控制流转换: 调用者进程快速通知被调用者进程
  - 数据传输: 将栈和寄存器参数传递给被调用者进程
- 一般的控制流转换会由于调度导致不确定的时延
  - 用户期望的控制流转换是调用者进程==>内核==>被调用者进程。
  - 而由于调度器的原因，实际的控制流转换，在内核和被调用者进程之间可能会有多个无关的进程被调度，导致不确定的时延。
  - 解决这个问题的方法：线程迁移。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092114183.png" alt="image-20220709211417010" style="zoom:67%;" />
- 线程迁移：将调用者运行在被调用上下文
  - 可以看做调用者并没有被调度器调度，而是直接将属于它自己的时间片让给了被调用者进程。让被调用者进程运行在属于它的时间片上。
  - 只切换地址空间、权限表等状态，不做调度和真正的线程切换
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092119301.png" alt="image-20220709211946159" style="zoom:67%;" />
- 数据传输：数据拷贝的性能损失。
  - 大部分的数据在进程间传输时至少需要两次拷贝，调用者进程==>内核、内核==>被调用者进程。
  - 而拷贝本身性能不高，且不具有扩展性。
  - 解决这个问题的方法：共享参数栈和寄存器。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092121395.png" alt="image-20220709212126214" style="zoom:67%;" />
- 共享参数栈和寄存器：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207092122382.png" alt="image-20220709212219228" style="zoom:67%;" />

# 10.
