# CS162 Lecture 1: What is an Operating System?

- 一些课程提供的资料：
  - ![image-20220712165459645](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121655779.png)
- 教学大纲
  - ![image-20220712165524048](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121655112.png)
- Homework & Project
  - ![image-20220712165635837](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121656911.png)
- What is a OS?
  - ![image-20220712171723257](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121717309.png)
  - ![image-20220712171707991](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121717063.png)

# CS162 Lecture 2: Four Fundamental OS Concepts

- OS提供了位于应用和物理机器之间的一层抽象机器。
  - 处理器：抽象为线程
  - 内存：地址空间
  - 磁盘、固态：文件
  - 网络：Socket
  - 机器：进程
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131343362.png" alt="image-20220713134314241" style="zoom:67%;" />
- 四个基础的OS概念：
  - 线程：程序的执行上下文。
    - 完整描述程序状态，包含PC的值、寄存器的值、标志位的值（0、溢出,etc）、栈
  - 地址空间（不管有或者没有地址翻译）
    - 程序能访问的一系列的内存地址（用于读写）
    - 可能和物理机器的内存空间不同（使用虚拟地址）
  - 进程：一个正在运行的程序的实例
    - 受保护的地址空间以及一个或多个线程
  - 双模式运转：
    - 一个典型的处理器有两种状态：用户态和内核态
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131345895.png" alt="image-20220713134510818" style="zoom:67%;" />

## First OS Concept: Thread of Control

- 线程：单个执行上下文。
  - 程序计数器、寄存器、标志位、栈、内存状态
- 当一个线程位于处理器中时，它就处于执行中的状态。
- 什么叫位于处理器中：
  - 寄存器保存了线程的上下文
    - 包含PC、当前正在执行的指令。
  - 包含正在进行的计算的立即数。有真的值也有指针值。
  - 栈指针指向栈顶。
  - 其余的位于内存中。
- 当一个线程的状态没有被加载到处理器中时，它就是被挂起的。
  - 此时处理器指向其他的线程。
  - 当一个线程被挂起时，它被保存在内存中，以TCB($Thread \ Control \ Block$)的形式。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131418075.png" alt="image-20220713141801983" style="zoom:67%;" />

- 可以将线程看做位于一个个的虚拟核上。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131427942.png" alt="image-20220713142748867" style="zoom:67%;" />
- 情境演示，当发生上下文切换时发生了什么：
  - 宏观上来看，从T1切换到T2的这段时间，发生的是上下文切换。
  - 具体来说，将`vCPU1`的PC的值、栈指针的值等等存入`vCPU1`的TCB放入内存。
  - 将位于`vCPU2`的TCB中的PC的值/栈指针等等加载到对应的地方（寄存器等）。
  - **目前暂且可以认为TCB是存储在内核所在的内存空间中的**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131429278.png" alt="image-20220713142908190" style="zoom:67%;" />

- 当有多个线程时，内存中是什么样的（线程这个抽象能够带给我们什么？）：
  - 每个线程都有自己的堆、栈、数据、指令
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131440749.png" alt="image-20220713144032648" style="zoom:67%;" />

## Second OS Concept: Address Space

- 一个线程的内存是分段的：
  - 代码段：代码
  - 静态数据段：全局变量、静态变量、字符串等
  - 栈：本地变量（比如当函数调用前将本地的变量入栈）
  - 堆：使用`malloc()`分配的内存，比如带指针的结构，链表之类的。
  - 关于堆和栈的分配，以后再说。



<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131554912.png" alt="image-20220713155410805" style="zoom:67%;" />

- 如果采用最原始的，所有的`vCPU`共享所有的非CPU资源，比如I/O、内存。那么会存在很多安全问题。
  - 每个线程可能会覆写其他线程的内存，甚至是覆写操作系统的内存。
  - 这种只使用物理内存空间的方法用于早期的操作系统，但是这种方法风险很大。
  - 所以我们需要操作系统提供一些保护措施。
- 简单的复用是没有保护措施的。
  - 操作系统必须保护自身免受其他用户程序的危害。
    - 限制线程能够访问的数据以及线程能够做的事情的尺度。
    - 保证每个线程都能够分到合适的系统资源比例（公平性，不会饿死是底线）。
  - 操作系统同样需要保证用户程序彼此之间不存在危害。
  - ![image-20220713160523548](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131605640.png)

### Simple Protection: Base and Bound (B&B)

- 借助硬件帮助OS提供保护。
- Base寄存器保存线程能够访问的内存的起始地址，Bound寄存器保存程序能够访问的内存的上限地址。
  - 每当要访问一个地址前，先检查其是否处于$[Base,Bound)$区间内。不处于的话可能就杀掉进程。
  - 但是由于可执行文件中的所有的地址都看上去是从地址`00000000`开始加载的，所以需要一个`重定位加载器`（软件性的重定位）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131623288.png" alt="image-20220713162341210" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131608432.png" alt="image-20220713160857343" style="zoom: 80%;" />

### Simple address translation with Base and Bound

- 基于上一个的基础上，使用硬件来做地址转换（那个加号就是）。
- 传入的地址类似偏移量，由硬件加上基址做地址转换。地址合法性检查同前。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131639954.png" alt="image-20220713163902857" style="zoom:80%;" />

### Another idea: Address Space Translation

- 程序运行在和物理内存完全分离的地址空间上。虚拟地址经过硬件翻译得到物理地址。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131710679.png" alt="image-20220713171017584" style="zoom:67%;" />

- 分页虚拟地址空间

  - 将整个虚拟地址空间划分为等尺寸的块（页），每一页有一个`Base`
  - 每页的大小一样，所以很容易把每页放入内存。
  - 硬件利用页表实现地址翻译。
  - 每页有一个独立的`Base`，每页的`Bound`是页面的尺寸。
  - 特殊的硬件寄存器保存指向页表的指针。
  - **将内存也分页为与虚拟页等尺寸的帧，这样就可以把任意页放入任意帧**
  - 分页后，指令运行在虚拟地址上。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131711366.png" alt="image-20220713171121273" style="zoom:67%;" />

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131715030.png" alt="image-20220713171528931" style="zoom:67%;" />

## Third OS Concept: Process

- 一个进程是具有受限制的权利的执行环境。
- 一个进程包含的资源有：
  - 受保护的地址空间，带有一个或多个线程。
  - 内存（地址空间）
  - 文件描述符、文件系统上下文，etc
  - 进程将一个或多个**共享进程资源**的线程封装起来。
- 应用程序作为进程启动，应用程序还可以启动子进程（使用`fork()`/`exec()`。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207140943847.png" alt="image-20220714094253633" style="zoom:80%;" />
- 为什么需要进程？
  - 它提供了受保护的地址空间，能够使得进程与进程之间相互隔离开（不互相伤害，比如覆写对方内存），能保护操作系统不受其他进程危害。
  - 进程之内的线程之间是有可能覆写内存的。
- 在保护性与效率之间存在一个很重要的`tradeoff`，在进程内的通信更加容易（但是更危险），在进程之间的通信更难（但是更安全）

- 单线程和多线程的进程：
  - 不管是单线程还是多线程。**每个线程都有属于自己的堆、栈（因为每个线程至少都需要保存自己的函数调用栈）**
  - 线程封装了并发（还有并行）。
  - 地址空间封装了保护，使得有bug的软件不会导致系统崩溃。
  - 我们为什么需要多线程？
    - 并行性。如果有多个核，那么使用多线程，每个核上运行一个线程，这样可以利用硬件优势提高针对同一个任务的效率。
    - 并发性。比如一个线程负责监听鼠标事件，一个线程负责监听窗口事件，一个线程负责网络连接。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207140947196.png" alt="image-20220714094759028" style="zoom:67%;" />

- Why do we need Process?Protection and Isolation.
  - ![image-20220714095549569](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207140955719.png)

## Fourth OS Concept:  Dual Mode Operation

- 注：`w/:with`,`w/o: without`。

- 硬件至少提供两种运行模式（至少一比特的模式位）

  - 内核模式，内核态。（监管者模式，超级用户模式？）
  - 用户模式，用户态。

- 当处于用户态时，某些特定的操作是被禁止的。

  - 比如改变页表指针，关闭中断，直接与硬件交互，写入内核内存。

- 用户态与内核态的转换是严格受控的。

  - 中断、系统调用、异常。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141014411.png" alt="image-20220714101408224" style="zoom:80%;" />

- 以Unix的宏内核为例:

  - 应用、标准库等等处于用户态。
  - 系统调用、中断、陷阱、异常等属于内核态。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141018300.png" alt="image-20220714101841138" style="zoom:80%;" />

- 用户态下有受限的硬件(HW)访问，内核态下则是完全的访问权限。

  - `exec()`:内核态===>用户态
  - 系统调用:用户态===>内核态
  - `rtn`:指的是从内核态的`return`。
  - 中断:用户态==>内核态
  - 其他的看图吧。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141020955.png" alt="image-20220714102006825" style="zoom: 67%;" />

- 能够通过容器技术和虚拟机等提供额外的保护：

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141025853.png" alt="image-20220714102514701" style="zoom:80%;" />

- 三类 用户态$\Rightarrow$内核态的转换：

  - 系统调用：类似函数调用，但是是在进程外部的。当进程需要操作系统服务时。
  - 中断：外部非同步的事件触发。
  - 陷阱或者异常：进程内部的同步事件触发，如除0、`segmentation fault`。
  - **三种都是unprogrammed control transfer**（未编程的控制转移？）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141026623.png" alt="image-20220714102615481" style="zoom:80%;" />

- Process Control Block：PCB，进程控制块。
  - PCB保存了进程的状态信息，内核以PCB的形式代表每个进程。
    - 进程的状态：正在运行、就绪、阻塞,etc。
    - 进程的PID、用户、可执行文件、优先级
    - 执行时间
    - 内存空间...
  - 内核调度器维持一个包含许多PCB的数据结构。
  - 调度策略选择下一个要运行的进程。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141029563.png" alt="image-20220714102956440" style="zoom:80%;" />

## Conclusion: Four Fundamental OS Concepts

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141045234.png" alt="image-20220714104514072" style="zoom:80%;" />

# CS162 Lecture 3: Abstractions 1: Threads and Processes

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141046144.png" alt="image-20220714104604015" style="zoom: 80%;" />

- Goals for today:
  - **What** threads are
    - –And what they are not
  - **Why** threads are useful (motivation)
  - **How** to write a program using threads
  - **Alternatives** to using threads



## What Threads Are

- 线程：单个的执行上下文。
- 线程：代表一个能被**独立调度**的任务的执行序列。
- 线程可以用于并发，也可以用于并行。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141544546.png" alt="image-20220714154448374" style="zoom: 67%;" />



## Motivation for Threads

- 概括起来就是我们需求一个程序能一次处理多件事。

- Threads are a unit of *concurrency* provided by the OS

  Each thread can represent one thing or one task

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141550036.png" alt="image-20220714155013916" style="zoom:67%;" />

## Multiprocessing vs. Multiprogramming

- Multiprocessing：有多个CPU或者核心，同时致力于同一个任务。
- Multiprogramming：多个任务或进程，不一定要同时进行。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141553782.png" alt="image-20220714155331674" style="zoom: 80%;" />

- 并发与并行的区别：
  - 并发是一次能够处理多件事情，而并行是指同一个时刻有多个任务同时执行。
  - 例如，两个线程运行在一个单核CPU上，这两个线程是并发的，但是并不是并行的（因为是两个线程轮流切换）。
  - 每个线程能处理一个独立的任务，但是这些任务并不一定是同时执行的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141603707.png" alt="image-20220714160331599" style="zoom:67%;" />

## Threads Mask I/O Latency

- 一个线程的三个状态：正在运行、就绪、阻塞
- 如果一个线程在等待I/O完成，那么OS会将其标记为阻塞，并且将其移除到就绪表。当I/O完成，OS将其标记为就绪。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141622404.png" alt="image-20220714162201315" style="zoom: 60%;" />
- **一个被阻塞的线程并不能直接从阻塞态跳转到运行态，因为需要给调度器一个调度它的机会**，不能越过调度器直接运行。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141618840.png" alt="image-20220714161832740" style="zoom: 67%;" />

## OS Library API for Threads: *pthreads*

- P：指的是[POSIX](https://baike.baidu.com/item/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/12718298?fromtitle=POSIX&fromid=3792413&fr=aladdin)。
- **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为**POSIX**）是[IEEE](https://baike.baidu.com/item/IEEE)为要在各种[UNIX](https://baike.baidu.com/item/UNIX)[操作系统](https://baike.baidu.com/item/操作系统)上运行软件，而定义API的一系列互相关联的标准的总称
- 但是其实目前并没有完全标准化的接口。
- 关于C的函数指针[Function Pointer in C](https://www.geeksforgeeks.org/function-pointer-in-c/)

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void*), void *arg);
//void *(*start_routine)(void*)
//函数指针，指向一个函数void* func(void* )

int pthread_join(pthread_t thread, void **value_ptr);
//暂停调用线程的执行，直到目标线程终止。
```

![image-20220714172035800](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141720923.png)

- What happens when pthread_create(…) is called in a process?
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141737228.png" alt="image-20220714173728124" style="zoom:67%;" />
- Fork-Join Pattern：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141737162.png" alt="image-20220714173752054" style="zoom:67%;" />

## Thread State

- 线程间共享的：
  - 共享内存（全局变量、**堆(Heap)**、静态变量）
  - I/O状态（文件描述符、**网络连接**,ect）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141740675.png" alt="image-20220714174026576" style="zoom: 80%;" />
- 线程私有的：
  - 都保存在TCB中
  - 寄存器的值，包括PC
  - 调用栈
- 调用栈：
  - 参数、临时变量
  - 函数调用的返回位置

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141753865.png" alt="image-20220714175317749" style="zoom:67%;" />

## Thread Abstraction

- 程序员视角：有无限多个处理器，可以满足多线程的要求。
- 现实：有一部分线程在运行，有一部分线程没有运行，线程轮换。
- 程序员期待的代码运行于实际调度的不确定性：
  - 程序员看来每行代码是连续执行的，但是在实际的调度中，可能确实是连续执行的，也可能是执行一行就被挂起。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141804787.png" alt="image-20220714180455671" style="zoom: 67%;" />

## Correctness with Concurrent Threads

- 非确定性：
  - 调度器可以以任何顺序运行线程。
  - 调度器可以在任何时候切换线程。
  - 这使得测试非常困难。
  - 但是我们要保证我们的程序在这种非确定性之下永远是正确的。
- 独立线程：
  - 线程之间没有共享的状态
  - 确定性的、可以复现的情况
- 协作线程：
  - 多个线程之间共享状态。

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141806125.png" alt="image-20220714180617033" style="zoom:67%;" />

## Race Conditions

- 不存在Race Condition：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141917029.png" alt="image-20220714191747923" style="zoom:67%;" />
- 存在Race Condition：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141918269.png" alt="image-20220714191809174" style="zoom: 67%;" />

## Relevant Definitions(关于锁和同步的)

- 同步：线程之间的协作，通常与共享的数据有关。
- 互斥：保证一次只有一个线程能做某个特定的操作
- 临界区：一次只能有一个线程运行的代码
- 锁：一次只能有一个线程持有的对象。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141919671.png" alt="image-20220714191906567" style="zoom:67%;" />



## Locks

- 锁提供两个原子操作：
  - 获取锁：等待直到锁是空闲的，然后将其标记为占用。称作这个线程持有这个锁。
  - 释放锁：只能被目前持有这个锁的线程调用。调用返回后，这个线程不再持有这个锁。
- 目前暂不关心锁的具体实现。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141948898.png" alt="image-20220714194832793" style="zoom:67%;" />

## OS Library Locks: *pthreads*

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141950618.png" alt="image-20220714195040516" style="zoom:67%;" />

## Processes

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207142011692.png" alt="image-20220714201130594" style="zoom:80%;" />

- 所有的进程都是被其他进程创建的，那么第一个进程是如何来的？
  - `Bootstrapping`：自举。
  - 第一个进程是被内核启动的，常称作`init`。在此之后所有的进程都被其他进程所创建。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150914103.png" alt="image-20220715091436908" style="zoom: 80%;" />

## Process Management API

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150918074.png" alt="image-20220715091858929" style="zoom:67%;" />

### exit()

- 当没有显式调用`exit()`时，OS库会隐式调用。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150920201.png" alt="image-20220715092014032" style="zoom:80%;" />

### fork()

- `fork()`会将当前进程的内存复制一个副本，放入一个新的地址空间。
  - 新的进程有不同的PID，但是内存和父进程是完全一样的。
  - 新的进程最开始只有一个线程。
  - `fork()`在子进程中返回0，在父进程中返回子进程的PID。
  - 如果`fork()`失败，则返回一个负数。
  - 子进程和父进程之间构成一棵进程树，如果子进程再`fork()`则它也变为父进程
  - 当父进程被`kill()`，子进程不会被`kill()`，会被父进程的父进程接管，一直`Kill()`最终由`init`进程接管。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150923297.png" alt="image-20220715092331114" style="zoom: 67%;" />

- C:Child，P:Parent
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150927729.png" alt="image-20220715092731554" style="zoom: 60%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150928490.png" alt="image-20220715092809318" style="zoom:60%;" />

- 在这种情况下两个`i`并不会发生竞争冒险，因为是不同的`i`，处于不同的地址空间。但是输出的顺序会因为调度的原因变化多样。
  - 完全独立的地址空间，因为是两个进程而不是线程。所以只存在对标准输出流的竞争。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150933928.png" alt="image-20220715093329735" style="zoom:67%;" />

### exec()

- `exec()`会将当前进程的内存内容全部清空，使用新进程覆盖。
- 下图的情况下，正常情况下`execv()`是不会`return`的（都全部覆盖了还return干嘛）。只有出错的时候才会`return`。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151005384.png" alt="image-20220715100537180" style="zoom:67%;" />
- `Shell`是如何利用`fork()`和`exec()`实现的：
  - 每当敲入一个命令，终端`fork`出一个新的终端，然后新的终端`exec`出命令对应的进程，旧终端则等待其返回。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151007207.png" alt="image-20220715100744017" style="zoom:67%;" />

### wait()

- `wait()`会一直等待子进程直到其结束，并将子进程`exit()`的参数值填充到`status`中去（图中是42），同时返回子进程的`PID`。
- 如果有多个子进程，可以指定等待哪一个子进程。`wait()`能起作用是因为内核维护了父子进程关系。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151009986.png" alt="image-20220715100944814" style="zoom:67%;" />

### kill() & sigaction()

- `sigation()`：设定收到相应的信号时的处理器。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151020424.png" alt="image-20220715102033267" style="zoom:67%;" />

- POSIX SIGNAL：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151023717.png" alt="image-20220715102305568" style="zoom:67%;" />
- 下面这个当收到`Ctrl + C`时会调用`signal_callback_handler()`

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151022931.png" alt="image-20220715102226740" style="zoom:67%;" />



## Conclusion

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150937087.png" alt="image-20220715093743899" style="zoom:80%;" />

# CS162 Lecture 4: Abstractions 2: Files and I/O

![image-20220715102856207](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151028413.png)

- Goals for Today: The File Abstraction
  - High-Level File I/O: Streams
  - Low-Level File I/O: File Descriptors
  - *How* and *Why* of High-Level File I/O
  - Process State for File Descriptors
  - Common Pitfalls with OS Abstractions

## Unix/POSIX Idea: Everything is a “File”

- 一切都是文件，因此有很多东西有相似的接口
  - 硬盘上的文件
  - 设备
  - 普通文件
  - 网络（Socket）
  - 本地进程间通信的手段
- 这些接口是基于系统调用的：`open()、read()、write()、close()`
- `ioctl()`用于配置那些不太符合的。
- 一切皆文件的思想在提出来的时候是相当激进的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151057805.png" alt="image-20220715105725593" style="zoom:67%;" />

## The File System Abstraction

- 文件：
  - 一个字节流序列，可以是文本文件、二进制文件、序列化对象。
  - 元数据：描述文件本身的数据，包括其大小、最后一次编辑的时间、所有者、安全信息、访问权限等。
- 目录：
  - 包含文件和目录的文件夹。
  - 在内核中，文件夹也只是一个将文件名与实际的文件内容映射起来的一个文件。
  - 目前暂时不深入讲解。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151104711.png" alt="image-20220715110445508" style="zoom:67%;" />

## Connecting Processes, File Systems, and Users

- 每个进程都有一个工作目录($CWD$)，工作目录可以使用系统调用更改。
- 绝对路径会忽略掉$CWD$。
- 相对路径是相对$CWD$来说的。
- `~`是`home`目录。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151504704.png" alt="image-20220715150403517" style="zoom: 67%;" />

## C High-Level File API – Streams

- 字节流：未格式化的字节序列（不存在关于它是文本文件还是二进制数据的信息），带有一个指针指向当前阅读的位置。
- 打开的字节流使用一个`FILE`结构体指针来代表。
- `fopen()`返回的是一个`FILE`结构体指针，打开文件后的后续操作都是使用这个指向文件的指针。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151514270.png" alt="image-20220715151416132" style="zoom:67%;" />

## C API Standard Streams – stdio.h

- 三种预定义的标准流：
  - 标准输出流：一般是屏幕
  - 标准输入流：一般是键盘
  - 标准错误流：一般也是屏幕
- 三种标准流都是可以被重定向的。比如使用管道进行输入重定向和输出重定向。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151545084.png" alt="image-20220715154518953" style="zoom:67%;" />

## C High-Level File API

```c
// character oriented  
//返回值是int而不是char,是因为EOF是-1，-1并不是任何一个char
int fputc( int c, FILE *fp );			// rtn c or EOF on err,put a char
int fputs( const char *s, FILE *fp );	// rtn > 0 or EOF,put a String

int fgetc( FILE * fp );
char *fgets( char *buf, int n, FILE *fp );

// block oriented
//一块一块的读取或写入字节流，在这种情况下需要一个缓冲区。
size_t fread(void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
size_t fwrite(const void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);

// formatted
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int fscanf(FILE *restrict stream, const char *restrict format, ... );

```

```c
int main(void) {
  FILE* input = fopen(“input.txt”, “r”);
  FILE* output = fopen(“output.txt”, “w”);
  int c;
//这里使用int来接收读取到的字符是因为fgetc()会返回EOF,而EOF不是一个char,EOF是-1
  c = fgetc(input);
  while (c != EOF) {
    fputc(output, c);
    c = fgetc(input);
  }
  fclose(input);
  fclose(output);
}

#define BUFFER_SIZE 1024
int main(void) {
  FILE* input = fopen("input.txt", "r");
  FILE* output = fopen("output.txt", "w");
  char buffer[BUFFER_SIZE];
  size_t length;
    //返回值是读取到的字符的个数，不一定和缓冲区的大小一模一样。
    //第二个参数是一次读取多少个字符，应该看做是一次读取字符数的上限。
  length = fread(buffer, BUFFER_SIZE, sizeof(char), input);
  while (length > 0) {
    fwrite(buffer, length, sizeof(char), output);
    length = fread(buffer, BUFFER_SIZE, sizeof(char), input);
  }
  fclose(input);
  fclose(output);
}
```

## C High-Level File API: Positioning The Pointer

- 用于调整指针位置的`fseek()`
  - 针对偏移量是相对谁的偏移量有三种选项，三种选项都是定义在`stdio.h`中的常量。
  - `SEEK_SET`:相对起点的偏移量
  - `SEEK_END`:相对终点的偏移量
  - `SEEK_CUR`:相对当前位置的偏移量
- 用于查看当前指针位置的`ftell()`
- 用于重置指针到流的起点的`rewind()`

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151614056.png" alt="image-20220715161426880" style="zoom:67%;" />

## Key Unix I/O Design Concepts

- 一切皆文件
- 使用之前先打开
- 面向字节：一切都是字节流，内核对任何数据或文件的结构和格式一无所知，除了一个特例：目录。
- 内核缓存读和写：
  - 一部分原因是为了缓存和性能
  - 还有一部分原因是硬盘之类的是面向块的，所以一次只能向硬盘写入一块字节。
- 显式关闭

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151631757.png" alt="image-20220715163154598" style="zoom:80%;" />

## Low-Level File I/O: The RAW system-call interface

- `open()`返回的是一个文件描述符，当返回值小于零时出错。
  - Open system call created an *open file description* entry in system-wide table of open files
  - –*Open* *file description* object in the kernel represents an instance of an open file
  - 为什么返回给用户的是一个文件描述符，而不是一个指向文件描述对象的指针？安全，防止用户访问不该访问的东西。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151651393.png" alt="image-20220715165122226" style="zoom:80%;" />

## C Low-Level (pre-opened) Standard Descriptors

- 在`unistd.h`中预定义了三个标准流所对应的文件描述符。
  - 标准输入流：0
  - 标准输出流：1
  - 标准错误流：2
- `FILE`结构体中是记录了文件的文件描述符的，能够通过`fileno()`得到。
- 第三个函数看图

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151656906.png" alt="image-20220715165633769" style="zoom:80%;" />

## Low-Level File API

- 三个都和高等级下的FILE API相似，只不过是有些地方将`FILE*`替换成文件描述符。
- 注：`filedes`:file descriptor.
- `read()`返回读到的字符的个数，不超过`maxsize`指定的个数。返回0代表EOF，-0代表出错。
- `write()`返回写入的字符的个数。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151659892.png" alt="image-20220715165926744" style="zoom:80%;" />

## POSIX I/O: Kernel Buffering

- 读和写都是缓存在内核中的，原因之前已经说过。
  - 内核会一次从磁盘读取一大块的数据缓存起来。

- 其他的以后深入。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151702326.png" alt="image-20220715170245179" style="zoom:67%;" />

## Low-Level I/O: Other Operations

- 最后两个以后深入讲
- Pipe那个用来建立一条管道。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151722243.png" alt="image-20220715172211093" style="zoom: 80%;" />

## High-Level vs. Low-Level File API

- `fread()`并不是传入需要读取的字符个数，就向内核请求多少字符个数，而是会一次请求比如4KB，然后缓存起来，然后从缓存里读。
  - 假如你要读13个字节，`fread()`并不是从内核里请求出13个字节，而是直接带出一大块数据（比如4KB）缓存起来，然后从缓存读取前13个字节。
- 流是被缓存在用户内存中的，而针对文件描述符的操作是立即可见的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151740017.png" alt="image-20220715173959863" style="zoom:67%;" />

## What’s in a FILE?

- FILE结构中有什么：
  - 文件描述符
  - 缓冲区（用户缓冲区，之前提到的）
  - 锁（同步用的，防止多个线程同时访问这个结构）
  - 其他东西不重要。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151742047.png" alt="image-20220715174215905" style="zoom:67%;" />

## FILE Buffering

- 当你借助`FILE`结构使用`fwrite()`向文件中写入数据时，你的数据实际上发生了什么？
  - 数据先被缓存到`FILE`结构体的缓冲区中去。
  - 如果缓冲区满，就刷新缓冲区（把缓冲区现有的内容写入文件）
    - 也就是说你给的数据其实不一定会立即写入文件。
    - 所以不要指望FILE帮你及时写入，而是在有需要的时候人为刷新`fflush()`。
  - C标准库可能会更频繁的刷新缓冲区。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151742950.png" alt="image-20220715174250811" style="zoom:67%;" />



- 例子1：
  - 写入的字符`b`可能已经被写入文件了，也可能只是被缓存在`f1`的缓冲区中，所以`fread()`可能读到`b`也可能没读到。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151745624.png" alt="image-20220715174546474" style="zoom: 80%;" />

- 例子2：人为立即刷新了缓冲区
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151747058.png" alt="image-20220715174709911" style="zoom:80%;" />
- Writing Correct Code with FILE：
  - 根据需要加入人为的`fflush()`去刷新缓冲区
  - 调用`fclose()`时会先刷新缓冲区，然后再回收资源。
  - **当使用低等级的file API，就不存在上述问题**（但是也同样没有那么好的性能）
  - `fgetc()`等的性能这么好是因为：你要读的第一个字节会进入内核顺便带回来一大块数据缓存起来，然后后续的读取都直接从缓冲区读取，直到缓冲区耗尽，才会有第二次系统调用（再一次带回一大块数据）。
  - ![image-20220715174817608](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151748755.png)

## Why Buffer in Userspace?

- 在用户空间使用缓存的原因有两个
  - 一是开销，系统调用的开销比函数调用大很多。使用`read()`读取一个字节的开销比使用`fget()`大得多，因为后者会缓存（前面讲过的那种缓存）
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151759515.png" alt="image-20220715175918346" style="zoom:67%;" />
  - 二是为了功能性。比如内核是完全不知道字节流的类型的，它只知道字节流，所以诸如读取一行这样的操作是没办法由内核完成的，因为内核不知道什么是换行符，这种操作就只能在更高层级完成。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151800581.png" alt="image-20220715180037425" style="zoom:80%;" />

## State Maintained by the Kernel

- 当成功打开一个文件时，`open()`返回一个文件描述符，同时在内核创建其对应的文件描述对象。
- 对于每个进程，内核维持一个文件描述符到其所对应的打开的文件描述对象的映射。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152038562.png" alt="image-20220715203822384" style="zoom: 80%;" />



- What’s in an Open File Description？
  - 最重要的两个，一个是用来记录在硬盘上的哪个地方找到对应的文件，另外一个是位置指针在文件中的当前位置。

## Abstract Representation of a Process

- 举例：
- 最开始的时候，进程打开一个文件：
  - 文件描述符是3，是因为0、1、2分别是预定义的标准流。
  - Open File Description记录了文件描述符对应的文件，以及当前位置。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152044610.png" alt="image-20220715204407435" style="zoom:67%;" />
- 然后进程往后读了100字节，此时Position变为100。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152046685.png" alt="image-20220715204601512" style="zoom: 67%;" />
- 假如下一步执行`close(3)`，那么变为：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152049517.png" alt="image-20220715204914329" style="zoom:50%;" />
- 假如下一步`fork()`出一个子进程2，**那么子进程2会复制父进程的文件描述符**
  - **并且父子进程共享同一个Open FILE Description**。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152050152.png" alt="image-20220715205042989" style="zoom:67%;" />
- 然后子进程往后读取一百字节，那么Position变为200。
  - **假如父进程要读取一百字节，那么父进程读取的是200-300的那一百字节。**（也就是说Position是共享的）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152052280.png" alt="image-20220715205231116" style="zoom:67%;" />
- 假如父进程关闭了它的文件描述符，此时对于的文件描述并不会直接被清理：
  - **只会清理掉父进程的指向对应文件描述的指针。**
  - 抓住一点就是父子进程共享`打开文件表(Open file Description)`
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152053322.png" alt="image-20220715205339169" style="zoom:67%;" />

- 对于从同一个终端打开的两个进程来说，他们的三个标准流都会指向同一个终端。
  - 因为这两个进程是终端`fork()`而来的，它们会有同样的文件描述符。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152057325.png" alt="image-20220715205747156" style="zoom: 80%;" />

## Other Syscalls: dup and dup2

- `dup(fd)`：得到一个新的描述符，指向`fd`所对应的打开文件描述，得到的文件描述符不一定就是`fd + 1`。
- `dup2(fd1,fd2)`：指定得到的新的文件描述符为`fd2`

![image-20220715210116397](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152101572.png)

## fork() in Multithreaded Processes

- 概括来说，当在多线程中使用`fork()`时，子进程中永远只有一个线程，那就是调用`fork()`的那个线程。
- 其他线程会直接消失。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152110927.png" alt="image-20220715211054759" style="zoom:80%;" />

## Possible Problems with Multithreaded fork()

- 当在多线程中调用`fork()`时，除了那个调用`fork()`的线程，其他线程都直接消失。这就会带来一些问题。
  - 万一消失的线程有一个正持有锁？
  - 万一消失的线程有一个正处于修改某个数据结构的中途？
  - 总之会有很多乱七八糟的问题。
- **当然如果多线程`fork()`之后子进程直接`exec()`是安全的**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152112438.png" alt="image-20220715211249283" style="zoom:80%;" />

## Conclusion

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152116472.png" alt="image-20220715211636301" style="zoom: 67%;" />

# CS162 Lecture 5: Abstractions 3: IPC, Pipes and Sockets

## Goals for Today: IPC and Sockets

- 进程间的通信机制以及跨越世界的通信是怎么样看起来想文件I/O的。
  - Socket是如何使得位于网络两端的两个进程像读写文件那样借助read()和write()进行通信的。
- 介绍管道和Socket
- TCP/IP

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207192122765.png" alt="image-20220719212155532" style="zoom: 67%;" />

## Why do we need IPC?

- 比如进程之间需要交流以相互协作完成任务，所以需要进程间通信。
- 但是进程这一抽象本身就是不鼓励进程之间的相互通信的，所以我们必须使用特殊的技巧。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201421859.png" alt="image-20220720142103535" style="zoom:67%;" />



## Use a file

- 最简单的实现进程间通信的方法是使用一个文件，一个进程往文件写入，另外一个进程从文件读取。
  - 但是这种方法时间开销很大，因为通过硬盘读写文件的速度是远小于读写内存的。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201431038.png" alt="image-20220720143030778" style="zoom:67%;" />





## Shared Memory: Better Option? Topic for another day!

- 当然一个更好的选择是使用共享的内存，将两个进程的地址空间都映射到同一块内存。
  - 需要锁



<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201449160.png" alt="image-20220720144922876" style="zoom:67%;" />

## Communication Between Processes (Another Option)

- 在内存中维持一个队列，**这个队列是使用系统调用才能访问的**
  - 也就是说我们向内核求助，这个内存中的队列应该是由内核来管理的。
  - **由内核管理，使用系统调用是处于安全原因**
  - **需要和前面提到的共享内存区分开，在这个方法之下，队列是处于内核的管理之下的，而前面提到的共享内存是在用户态的**
- 进程A向内存中的队列`write()`，进程B从内存中的队列`read()`。
  - A产生的数据会保存在内存中，直到B读取它。
  - 这样比使用文件要更高效因为我们不会访问硬盘。
  - 所使用的接口和文件读写是一样的。
- 但是还有一些问题：
  - 怎么建立这个连接？
  - 如果生产者（A）生产数据的速率高于B能够消耗的速率呢？
    - 这样队列会满，所以在队列满时，如果A调用了`write()`，A就要陷入休眠，直到队列中有足够的空间为止。
    - 当队列变空时要唤醒Ａ，完成写入。
    - 当然，假定B永远不读取数据，A不可能永远等待下去，所以需要设置一定的超时值。
  - 如果生产者A的生产速率低于B消耗的速率？
    - 这样队列会空，所以在队列空时，如果B调用了`read()`，B就要陷入休眠，直到队列中变为不空。
    - 当队列变为非空时要唤醒B，完成读取。
    - 如果Ａ永远不写入新的数据，B也不可能一直等待下去，所以也需要一个超时值。
  - 但是不管怎么样，两个进程之间不会有过大的危害，也不会有死锁。
- **于是这就引出了我们的pipe**，管道就是一个内存中的队列，并且也是缓冲在内核中的。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201454951.png" alt="image-20220720145428666" style="zoom:67%;" />

### One example of this pattern: POSIX/Unix PIPE

- 系统调用`pipe(int fileds[2])`，参数是一个`int`型数组，这个数组会被`pipe()`填充好两个文件描述符，两个文件描述符分别对应管道的读端和写端。
  - **fileds[0]是读端，fileds[1]是写端**
  - 当生产者试图在缓冲区满时写入，它陷入阻塞（休眠直到缓冲区有空间）
  - 当消费者试图在缓冲区空时读取，它陷入阻塞（休眠直到缓冲区有数据）
  - 缓冲区（内存中的队列，位于内核）是固定尺寸的。
  - **问题：生产者陷入休眠以后是怎么队列空的，消费者陷入休眠以后是怎么知道队列有新的数据的**
    - 换句话说，我们怎么知道管道里有没有数据的？难道要时不时去检查？
    - 内核知道，当有新的数据的到来时通知休眠的消费者，有空间。内核全都知道。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201516449.png" alt="image-20220720151625157" style="zoom:67%;" />



- 栗子1，使用管道在进程内部通信：

  - 从管道的两端的读和写都是调用文件读写的系统调用`read()`和`write()`.

  - **在通信结束后要关闭两个文件描述符**。

  - 这个例子在管道的写入端写入后立即在管道的读取端读取。

  - ```c
    #include <unistd.h>
    int main(int argc, char *argv[])
    {
      char *msg = "Message in a pipe.\n";
      char buf[BUFSIZE];
      int pipe_fd[2];
      if (pipe(pipe_fd) == -1) {
        fprintf (stderr, "Pipe failed.\n"); return EXIT_FAILURE;
      }
      ssize_t writelen = write(pipe_fd[1], msg, strlen(msg)+1);
      printf("Sent: %s [%ld, %ld]\n", msg, strlen(msg)+1, writelen);
    
      ssize_t readlen  = read(pipe_fd[0], buf, BUFSIZE);
      printf("Rcvd: %s [%ld]\n", msg, readlen);
    
      close(pipe_fd[0]);
      close(pipe_fd[1]);
    }
    
    ```

    

- 栗子2，进程间的管道通信：

  - 先打开管道，然后使用`fork()`生成子进程，然后两个进程会共享文件描述符，像下图那样

    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201545616.png" alt="image-20220720154530290" style="zoom: 50%;" />

  - 然后可以选择在父进程关闭写入端的文件描述符，在子进程关闭读取端的文件描述符，就得到了一个子进程写入，父进程读取的单向管道。当然，也可以反过来，就长下面那样。

    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201546060.png" alt="image-20220720154652754" style="zoom: 50%;" />

  - ```c
    #include <unistd.h>
    int main(int argc, char *argv[])
    {
      char *msg = "Message in a pipe.\n";
      char buf[BUFSIZE];
      int pipe_fd[2];
      if (pipe(pipe_fd) == -1) {
        fprintf (stderr, "Pipe failed.\n"); return EXIT_FAILURE;
      }
      pid_t pid = fork();
      if (pid < 0) {
        fprintf (stderr, "Fork failed.\n");
        return EXIT_FAILURE;
      }
      if (pid != 0) {
        ssize_t writelen = write(pipe_fd[1], msg, msglen);
        printf("Parent: %s [%ld, %ld]\n", msg, msglen, writelen);
        close(pipe_fd[0]);
      } else {
        ssize_t readlen  = read(pipe_fd[0], buf, BUFSIZE);
        printf("Child Rcvd: %s [%ld]\n", msg, readlen);
        close(pipe_fd[1]);
    }
    ```

## When do we get EOF on a pipe?

- 当最后一个写入端的文件描述符被关闭之后，再从管道读取数据，就只能读取到EOF，像下面那样。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201600355.png" alt="image-20220720160035048" style="zoom: 67%;" />

- 在最后一个读取端的文件描述符被关闭之后，再向管道写入数据就会生成一个`SIGPIPE(sig-pipe)`信号。
  - 如果进程忽略这个信号，这个写入会失败，并且出现`EPIPE(e-pipe)`错误

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207201558103.png" alt="image-20220720155800799" style="zoom:67%;" />



## What is a Network Connection?

- 两个处于不同机器上的进程之间的双向的字节流
  - 目前只讨论TCP
- 一个处于两个端点A和端点B之间的连接由：
  - 从A到B的用于数据传输的队列（有限缓冲区）
  - 从B到A的用于数据传输的队列（有缓冲区）构成。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211119287.png" alt="image-20220721111940045" style="zoom:67%;" />

## The Socket Abstraction: Endpoint for Communication

- 中心思想：跨越网络的进程间通信也像文件读写（有`read()`和`write()`）
- Socket是通信的两个端点，每个Socket都有缓冲区用来暂存数据。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211125495.png" alt="image-20220721112510294" style="zoom:67%;" />

### Sockets: More Details

- Socket是另外一种实现进程间通信的机制
- Socket几乎出现在所有类型的操作系统上，分布及其广泛。
- Socket在BSD Unix4.2上被引入
- 在任意种类的网络上Socket的抽象都是一致的

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211128563.png" alt="image-20220721112854366" style="zoom:67%;" />

- Socket看上去就和带有文件描述符的文件是一样的，`write()`写入，`read()`读出
- **有一些文件操作不适用于Socket，比如调整字节流指针的`lseek()`**
  - 和调整文件字节流指针的操作都没有，因为Socket总是在尾部加入新数据，另外一端尾部读取。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211132637.png" alt="image-20220721113219462" style="zoom:67%;" />

### Socket Creation

- 文件系统在一个结构化的命名空间内提供了永久的对象的集合
  - 进程能够打开、读写、关闭文件
  - 文件的存在独立于进程
  - 能够通过指定文件名地方式轻易打开文件(`open()`)
- 管道：为处于同一台物理机器上的两个进程之间的单向的通信。
  - 单个的队列
  - 通过系统调用`pipe()`创建的暂时性的东西
  - 文件描述符是从父进程传递给子进程的
  - **不是一个全双工的通道，因为如果两个进程同时借助写入端的文件描述符写入的话，写入的字节流会互相穿插在一起。**
- 而Socket：双向的，两个进程之间的通信，这两个进程可能不在同一台机器上
  - 两个队列，每个方向上一个，分别处于两端的Socket
  - 第一个问题：使用IP来解决命名空间的问题
  - 第二个问题：使用端口号来定位要通信的进程

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211547477.png" alt="image-20220721154756257" style="zoom:67%;" />

### Connection Setup over TCP/IP

- 一个CS架构的模型
- 服务器端的`sever socket`负责监听和接收来自客户端的连接，**但并不负责处理连接建立后的事务**
  - 每当`sever socket`accept()之后，一个新的socket会被创建出来处理这个连接。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211555345.png" alt="image-20220721155511161" style="zoom:67%;" />

#### Client Protocol

```c
char *host_name, *port_name;

// Create a socket
struct addrinfo *server = lookup_host(host_name, port_name);
int sock_fd = socket(server->ai_family, server->ai_socktype,
                     server->ai_protocol);

// Connect to specified host and port
connect(sock_fd, server->ai_addr, server->ai_addrlen);

// Carry out Client-Server protocol
run_client(sock_fd);

/* Clean up on termination */
close(sock_fd);

```



#### Server Protocol (v1)

- 缺点：
  - 一次只能处理一个连接，当当前连接没有处理完时，其他连接没办法处理
  - 服务器进程没办法保护自己

```c
// Create socket to listen for client connections
char *port_name;
struct addrinfo *server = setup_address(port_name);
int server_socket = socket(server->ai_family,	server->ai_socktype, server->ai_protocol);
// Bind socket to specific port
bind(server_socket, server->ai_addr, server->ai_addrlen);
// Start listening for new client connections
listen(server_socket, MAX_QUEUE);

while (1) {
  // Accept a new client connection, obtaining a new socket
  int conn_socket = accept(server_socket, NULL, NULL);
  serve_client(conn_socket);
  close(conn_socket);
}
close(server_socket);

```

#### Server Protocol (v2)，Sockets With Protection (each connection has own process)

- 改进：
  - 每当`accept()`一个连接之后，`fork()`一个子进程出来，由子进程来处理连接后的事务。
  - 父进程则`wait()`直到子进程结束。
  - 由于子进程不需要`sever socket`（不需要接受新的连接），所以子进程会关闭自己对应的文件描述符。
  - 由于父进程不需要去处理连接后的事务（不需要服务客户端），所以父进程会关闭自己对应的文件描述符。
- 缺点：并发性要求没有得到满足
  - A concurrent server can handle and service a new connection before the previous client disconnects

```c
char *port_name;
struct addrinfo *server = setup_address(port_name);
int server_socket = socket(server->ai_family,	server->ai_socktype, server->ai_protocol);
// Bind socket to specific port
bind(server_socket, server->ai_addr, server->ai_addrlen);
// Start listening for new client connections
listen(server_socket, MAX_QUEUE);
while (1) {
  // Accept a new client connection, obtaining a new socket
  int conn_socket = accept(server_socket, NULL, NULL);
  pid_t pid = fork();
  if (pid == 0) {
    close(server_socket);
    serve_client(conn_socket);
    close(conn_socket);
    exit(0);
  } else {
    close(conn_socket);
    wait(NULL);
  }
}
close(server_socket);
```

#### Server Protocol (v3)

```c
// Socket setup code elided…
while (1) {
  // Accept a new client connection, obtaining a new socket
  int conn_socket = accept(server_socket, NULL, NULL);
  pid_t pid = fork();
  if (pid == 0) {
    close(server_socket);
    serve_client(conn_socket);
    close(conn_socket);
    exit(0);
  } else {
    close(conn_socket);
    //wait(NULL);
  }
}
close(server_socket);
```

- 改进：父进程不再`wait()`子进程结束，而是直接进入下一个循环来接收新的连接。
- 缺点：使用子进程的开销太大了，可以改为使用多线程。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211608959.png" alt="image-20220721160848758" style="zoom: 67%;" />
- 使用多线程会带来另外一个问题：
  - 服务器可能会在短时间内接收高并发的访问，导致线程数量高速增长，最终导致内核崩溃。
  - 解决方法：使用线程池，限制线程的数量。
  - 每当来一个新的连接请求，将其插入队列等待，当有一个线程空闲，出队下一个连接。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211612097.png" alt="image-20220721161247885" style="zoom:67%;" />

## Conclusion

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211614738.png" alt="image-20220721161454443" style="zoom:67%;" />

# CS162: Lecture 6: Synchronization 1: Concurrency and Mutual Exclusion

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211910978.png" alt="image-20220721191006770" style="zoom:67%;" />

## Goals for Today: Synchronization

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211922208.png" alt="image-20220721192205983" style="zoom:67%;" />

## Multiplexing Processes: The Process Control Block

- 复习了一下PCB

- 内核使用PCB来代表每个进程，PCB中存储了这个进程的：

  - 状态（运行中、阻塞、就绪，etc）
  - 寄存器状态
  - PID、用户、可执行文件、优先级等
  - 启动时间
  - 内存空间、地址翻译等等

  

- 略微讲了一下内核调度器。
  - 调度器维护了一个数据结构，这个数据结构包含了每个进程的PCB，调度器负责调度CPU资源和非CPU资源。

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211935990.png" alt="image-20220721193505768" style="zoom:67%;" />

## Context Switch

- 上下文切换：
  - 保存进程状态到PCB
  - 从另外一个PCB加载另外一个进程的状态
  - 运行另外一个进程
  - 另外一个进程再上下文切换
  - **过于频繁的上下文切换会导致程序实际运行的时间占比很小，而上下文切换的开销占比极大**
  - 进程运行在用户态，而上下文切换（保存和恢复PCB等等）是属于内核态（红框）。
  - x86实际上有四种权限，但是当做是两种就行了。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207211949598.png" alt="image-20220721194944387" style="zoom:67%;" />

## Lifecycle of a Process or Thread

- 适用于线程和进程。
- 直接以进程为例来说明它们的生命周期：
  - 新建：进程刚被创建出来的时候
  - 就绪：进程可以运行，但还没有运行，当一个进程被创建出来，插入就绪队列之后，就是就绪。
  - 运行：进程正在占用CPU
  - 等待：由于I/O或者某些事件，进程进入阻塞
  - 终止：进程执行完毕，但是还没有被释放掉（僵尸进程状态，已经终止但是没有被再分配）
    - 为什么？因为父进程需要得到子进程的结果 
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212000668.png" alt="image-20220721200012449" style="zoom:67%;" />

## Scheduling: All About Queues

- PCB总是从一个队列移到另外一个队列

- 一个PCB从就绪队列移到CPU，然后可能因为I/O移到I/O队列再回到就绪队列，也有可能因为时间片到期而回到就绪队列，等等原因。
- **当启用fork()得到子进程时，不能想当然认为子进程会进入就绪队列或者是父进程会进入就绪队列，这个和调度策略有关，永远不能假设哪个先运行**
- 目前所说的调度指的仅仅是决定就绪队列中谁是下一个得到CPU时间的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212006571.png" alt="image-20220721200623344" style="zoom:67%;" />

## Ready Queue And Various I/O Device Queues

- 每个队列都代表了一系列的被暂时挂起的进程。
- 每个队列实际上是链表，调度器只与就绪队列交互，其他的队列通过设备驱动来交互

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212039467.png" alt="image-20220721203919243" style="zoom:67%;" />

## The Core of Concurrency: the Dispatch Loop

- 首先复习一下线程相关：
  - 为什么多线程一个地址空间？为了共享
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212057185.png" alt="image-20220721205700970" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212057720.png" alt="image-20220721205750487" style="zoom:67%;" />
- 进入正题：
  - 从概念上来说，其实调度就是一个死循环：
    1. 运行线程
    2. 选定下一个线程
    3. 保存当前线程的状态
    4. 加载新线程的状态
    5. 回到1。
  - 甚至可以说这就是操作系统的全部工作。只有在机器关机或者机器崩溃的时候退出这个循环。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212103406.png" alt="image-20220721210341189" style="zoom:67%;" />

## Running a thread

- 运行一个线程很简单，保存旧状态，加载新状态，加载运行时环境，跳转到PC。
- 但是有个问题，假如只有一个CPU的情况下，OS和其他线程都是运行在这个CPU上的，当OS运行的时候其他线程就不运行，其他线程运行的时候OS就不能运行，这意味着OS在其他线程运行的时候是给出了CPU的控制权的，如果应用程序陷入死循环，OS需要想办法把控制权拿回来。
- 调度器如何把控制权拿回来？
  - 内部事件：（当每个线程都协作得很好，没有bug时）线程自愿返回控制权
  - 外部事件：线程被抢占

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212117448.png" alt="image-20220721211750135" style="zoom:67%;" />

### Internal Events

- I/O阻塞，等待硬盘读写时线程可以让出CPU
- 等待其他线程的信号，此时线程可以让出CPU
- 使用系统调用`yield()`自愿让出CPU
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207212146593.png" alt="image-20220721214656367" style="zoom:67%;" />
- 新加入两个POSIX API:自愿让出CPU的`yield()`
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221342639.png" alt="image-20220722134216354" style="zoom:67%;" />

### Stack for Yielding Thread

- 蓝色部分是用户栈，红色部分是内核栈
  - 对于每一个线程（每一个用户栈），都有一个与之一一对应的内核栈。
  - 为什么使用内核栈而不是直接使用用户栈？安全，内核不相信用户。

- 运行一个新线程的过程：
  - 选择下一个要运行的线程
  - 做好上下文切换工作
    - 保存现有线程状态，加载下一个线程的状态
  - 做好后续清理和善后工作（比如资源回收）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221345259.png" alt="image-20220722134550029" style="zoom:67%;" />

### What Do the Stacks Look Like?

- 两个假设：
  - 只有两个线程S和T，最开始是线程S在运行。
  - 两个线程S和T的源代码是一样的。
- 最开始，线程S调用A函数，A调用B，B调用`yield()`。
  - `yield()`陷入内核栈，调用`run_new_thread()`
  - `run_new_thread()`调用`switch()`
  - **`switch()`执行完毕后从线程T的调用栈返回到`yield()`，`yield()`返回B**。
  - 然后线程T的B再调用`yield()`，然后调用`run_new_thread()`，然后调用`switch()`，然后从线程S的调用栈返回，如此循环往复。
- 为什么在线程S调用`switch()`之后，栈是先从线程T的底部返回，然后到达顶部后再自顶向下？
  - 因为`switch()`执行完毕后是需要执行`ret`指令的，而`switch()`本身在执行的过程中是会更改栈指针的（将`%rsp`的值由S的栈顶指针改为T的栈顶指针），也就是说`switch()`在执行完毕后，地址空间内实际上现存的栈是线程T的栈，而`ret`指令是从栈里`pop()`出一些东西，这个操作最终实际上是在线程T的栈上执行的。
- **在执行`switch()`之后，线程相对应的内核栈也是进行了切换的，保持用户栈和内核栈的一一对应的关系。**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221500295.png" alt="image-20220722150008045" style="zoom:67%;" />

### Switch Details (continued)

- `switch()` 的伪代码（伪汇编代码？）。
  - 大概就是保存现有寄存器值到TCB，加载新TCB的值到CPU
  - `switch()`执行完毕后会返回的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221530494.png" alt="image-20220722153033265" style="zoom:67%;" />
- 如果在实现`switch()`的时候出错了会怎么样？
  - 可能会出错，也可能不会，取决于你犯错的那个地方有没有被用到
- 能否完全全面的测试`switch()`的代码？不可以。
- 最后一点是小故事，不用看
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221531069.png" alt="image-20220722153150845" style="zoom:67%;" />

### Aren't we still switching contexts?

- 线程间的上下文切换要比进程间的上下文切换开销要小得多，因为不需要改变地址空间。
- 甚至可以让开销更小：
  - 典型的情况下，一个用户栈有一个与之对应的内核栈，在进行上下文切换的时候需要进入内核
  - 但是我们可以使用多个线程对应一个内核线程的情况，这种情况下上下文切换的开销更加小（不需要进入内核），但是代价是如果其中一个用户线程进入内核线程，被阻塞，其余用户线程也会被挂起。
  - 所以有了多对多模型。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221613116.png" alt="image-20220722161348884" style="zoom:67%;" />

### Processes vs. Threads

- **Concurrency** is when two or more tasks can start, run, and complete in overlapping time **periods**. It doesn't necessarily mean they'll ever both be running **at the same instant**. For example, *multitasking* on a single-core machine.
- **Parallelism** is when tasks *literally* run at the same time, e.g., on a multicore processor.

- No Parallelism，ONLY concurrency

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221620435.png" alt="image-20220722162043196" style="zoom:67%;" />

- Parallelism

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221620374.png" alt="image-20220722162055152" style="zoom:67%;" />

### Simultaneous MultiThreading/Hyperthreading

- 超线程：大概就是一个核上同时运行两个线程？使用流水线

### External Events

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221711245.png" alt="image-20220722171159004" style="zoom:67%;" />

- 外部事件用于保证即使程序出现了bug，调度器也可以成功地取回控制权。
  - 使用中断或者定时器来确保。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221715262.png" style="zoom:67%;" />

### How do we initialize TCB and Stack?

- 初始化TCB的寄存器域：
  - 栈指针指向栈
  - PC返回地址置为OS的程序`ThreadRoot()`
  - 两个参数寄存器被初始化为函数指针和函数参数指针。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221729597.png" alt="image-20220722172902380" style="zoom:67%;" />



## How does Thread get started?

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221731785.png" alt="image-20220722173116567" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221732192.png" alt="image-20220722173200968" style="zoom:67%;" />

## Correctness with Concurrent Threads?



### Atomic Operations

- 原子操作：总是运行到完成或者干脆一点都不运行的操作。
  - 无法在运行的中途被停下来，也无法在中途改变其状态
  - 如果没有原子操作，无法完成多线程同步
  - 目前只有load和store是原子操作。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221801063.png" alt="image-20220722180118799" style="zoom:67%;" />

- 复习了一下锁：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221805527.png" alt="image-20220722180536300" style="zoom:67%;" />
- 复习了几个和同步相关的定义：
  - 同步：使用原子操作来保证线程之间的协作
  - 互斥：保证一次只有一个线程能做某件特定的事
  - 临界区：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207221806586.png" alt="image-20220722180601356" style="zoom:67%;" />

# CS162: Lecture 6.5: Concurrency and Mutual Exclusion (Supplemental)

# CS162 Lecture 7: Synchronization 2: Semaphores (Con't), Lock Implementation, Atomic Instructions



<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231315083.png" alt="image-20220723131501765" style="zoom:67%;" />

## Producer-Consumer with a Bounded Buffer

- 生产者消费者模型：
  - 有多个生产者和多个消费者，生产者将东西放入缓冲区，消费者从缓冲区取东西
  - 缓冲区是有限容量的。
  - 放东西和取东西都是随时可能发生的
  - 当缓冲区满时，生产者要放东西，就让他休眠
  - 当缓冲区空时，消费者要取东西，也让他休眠。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231601131.png" alt="image-20220723160119866" style="zoom: 67%;" />

## Circular Buffer Data Structure (sequential case)

- 我们的缓冲区对象的结构：
  - 两个index，一个是写入index，一个是读取index，这个index是可以回绕的（也就类似ArrayList）。
  - 一个存放东西的缓冲区`entries`
  - 可以看做是一个有两头index的环形数组（`ArrayList<T>`），写入就是入队，读取就是出队。
  - 存入东西就是写入，然后把`write_index`修改一下，读取类似。
- 现在需要做的就是保证对这个缓冲区的操作都是原子性的。



<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231602330.png" alt="image-20220723160252112" style="zoom:67%;" />

## Circular Buffer – first cut

- 基本思想就是先加锁，假如缓冲区空或者满，消费者或者生产者就使用空`while()`等待直到缓冲区不空或者不满，然后再做操作，最后释放锁。
- **但是这样的思路有两个问题**：
  - 对于生产者来说，缓冲区永远不会有空位。因为生产者在`while()`循环等待缓冲区变空的时候，它是给缓冲区加了锁的，此时其他的消费者是没办法访问缓冲区的，所以缓冲区也永远不会变得有空位，生产者也永远跳不出`while()`循环。
  - 对于消费者来说，缓冲区永远不会有东西。原因与生产者类似。
  - 上述问题引出了一个新问题，那就是关于那个`while()`循环浪费CPU时间，等待的时候完全可以休眠而不是`while()`忙等

```c
mutex buf_lock = <initially unlocked>

Producer(item) {
  acquire(&buf_lock);//加锁
  while (buffer full) {}; // Wait for a free slot，假如缓冲区满，就一直在循环结构空转，直到缓冲区不满，跳出循环
  enqueue(item);//缓冲区有空位，插入
  release(&buf_lock);//释放锁
}
//类似
Consumer() {
  acquire(&buf_lock);
  while (buffer empty) {}; // Wait for arrival
  item = dequeue();
  release(&buf_lock);
  return item
}

```

## Circular Buffer – 2nd cut

- 第二版好一点，**至少能用了**。
- 但是除了能用，缺点也很明显：
  - 还是忙等问题。假如缓冲区是满的，并且长时间都没有消费者来取东西，那么生产者就一直处于`释放锁-拿锁` 循环中，一直在浪费CPU的时间，但是什么都没做，这部分时间本来是可以让出去的。
  - 对于消费者来说也存在类似的问题。

```c
mutex buf_lock = <initially unlocked>

Producer(item) {
  acquire(&buf_lock);
  while (buffer full) {release(&buf_lock); acquire(&buf_lock);} 
  enqueue(item);
  release(&buf_lock);
}

Consumer() {
  acquire(&buf_lock);
  while (buffer empty) {release(&buf_lock); acquire(&buf_lock);} 
  item = dequeue();
  release(&buf_lock);
  return item
}

```

## Recall: Semaphores

- 信号量，最初由Dijkstra定义。
- 定义：一个信号量有一个非负的整数值，并且支持以下两个操作：
  - Dwon()，或者说P()，一个原子操作，等待信号量变为正数，然后将其减一（如果信号量本来就是正的，不需要等待）
  - Up()，或者说V()，一个原子操作，将信号量的值加一，然后唤醒正在等待的P()，如果有的话。
  - P和V都是Dutch。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231721989.png" alt="image-20220723172134698" style="zoom:67%;" />

### Semaphores Like Integers Except…

- 信号量很像整数，但是：
  - 是非负的整数
  - 只支持P和V运算，而不支持读写值，除了初始化的时候
  - 运算必须是原子化的
    - 两个P()一起，不能将信号量减至零以下。
    - 调用P进入休眠的线程不会错失来自V的唤醒，即便两个操作同时发生
  - POSIX支持查看值，但是。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231725639.png" alt="image-20220723172527415" style="zoom:67%;" />

### Two Uses of Semaphores

- 信号量的两个应用

- 互斥锁：也叫二进制信号量，互斥锁
  - 初始值为1。
  - 能够应用于实现互斥，就是一个锁。
  - 进入临界区时执行`P()`(将值减为0，如果当前值为0就等待)
  - 出临界区时执行`V()`。
- 调度约束：
  - 允许线程1等待来自线程2的信号，线程2会在给定事件出现时调度线程1。
  - 比如`ThreadJoin()`:
    - 初始值为0
    - 父进程等待子进程结束，父进程执行`P()`，由于初始值为0，父进程陷入等待。
    - 子进程结束的时候执行`V()`，将信号量置为1同时唤醒父进程。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231731778.png" alt="image-20220723173143519" style="zoom:67%;" />

## Revisit Bounded Buffer: Correctness constraints for solution

- 给出缓冲区保证正确性的多个限制条件，以及完整的解决方法。
- 限制条件：
  - 如果缓冲区完全空，消费者必须等待生产者填充缓冲区
  - 如果缓冲区完全满，生产者必须等待消费者腾空缓冲区
  - 一次只能有一个线程能够操纵缓冲区
- **对于每个限制条件，应该使用一个单独的信号量**。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231747112.png" alt="image-20220723174659876" style="zoom:67%;" />

### Full Solution to Bounded Buffer (coke machine)

- 三个限制，所以三个信号量。
- `fullSlot`记录填充了多少格子
- `emptySlot`记录还有多少个空格子
- `mutex`是信号量，作为互斥锁
- 生产者：
  - 先检查是否还有空格子（对`emptySlot`执行`P()`，如果`emptySlot`等于0，陷入等待）
  - 被来自消费者的`V()`唤醒之后加锁，然后插入东西
  - 插入完毕之后放锁，然后执行`V()`操作将`fullSlot`加一，同时给消费者发出信号，告知消费者缓冲区有东西可以取
- 消费者：
  - 先检缓冲区是否为空（对`fullSlot`执行`P()`，如果`fullSlot`等于0，陷入等待）
  - 被来自生产者的`V()`唤醒之后，加锁，然后拿走一个东西。
  - 插入完毕之后放锁，然后对`emptySlot`执行`V()`将其加一，同时给生产者发出信号，唤醒生产者等待空格的`P()`
- 生产者的`semaV(&fullSlots)`唤醒的是消费者的`semaP(&fullSlots)`，意思就是生产者唤醒消费者告诉它有东西可以取了
- 消费者的`semaV(&emptySlots)`唤醒的是生产者的`semaP(&emptySlots)`，意思是消费者唤醒生产者告知它有空格子可以放东西了。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207231820674.png" alt="image-20220723182005414" style="zoom:67%;" />

### Discussion about Solution

- 为什么不对称？废话
- P的顺序重要吗？很重要，不然会导致死锁。
  - 生产者如果先获取互斥锁，然后再检查是否还有空位，当没有空位的时候就会死锁，因为消费者没办法在拿不到锁的情况下给缓冲区腾出空间。
- V的顺序（也就是是先释放互斥锁还是先修改格子的 不重要，就是可能会影响调度效率

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207232032263.png" alt="image-20220723203201989" style="zoom:67%;" />

## Motivating Example: “Too Much Milk”

- 背景大概就是，A和B是舍友，二者共用一个冰箱，二者都需要喝牛奶，如果冰箱里没有牛奶，二者都会去买牛奶。
- 表格里是没有同步的时候会发生的情况：A先发现没有牛奶，去买牛奶了，然后B才发现没有牛奶，但是此时A还没把牛奶买回来，于是二者都去买牛奶了，于是冰箱里就会有多余的牛奶。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241208604.png" alt="image-20220724120800270" style="zoom:67%;" />

### Too Much Milk: Correctness Properties

- 为了保证冰箱里不会有太多的牛奶，我们做出如下的限制：
  - 永远不超过一个人去买牛奶
  - 如果没有牛奶，要有人去买。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241211748.png" alt="image-20220724121102512" style="zoom:67%;" />

### Too Much Milk: Solution #1

- 去买牛奶的人在出发之前留下一张便条表示自己去买了。
  - 先留下便条，说自己买牛奶去了
  - 然后买牛奶
  - 买回来之后把便条去掉。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241211851.png" alt="image-20220724121152610" style="zoom:67%;" />

- 问题：
  - 假如出现以下情况：线程A和B代表两个人
  - 线程A检查到没有牛奶，没来得及检查是否有便条就被调度走。
  - 调度到线程B，线程B也检查到没有牛奶，同时检查到没有便条，然后没来得及留便条就被调度走。
  - 调度回线程A，A检查到没有便条，于是出门把牛奶买回来。
  - 然后调度回到B，B由于已经通过了`If()` 检查，也去买牛奶。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241226598.png" alt="image-20220724122635346" style="zoom:67%;" />
- 结果：
  - 偶尔仍然会出现牛奶过量的情况，因为线程可能会在恰好通过检查且没来得及放便条的时候被调度走。
  - 这种方法并没有改善问题，而是让问题更加难以被解决，因为出现更加少，更加难以复现和debug。
  - **我们的解决方法应该保证不管调度器如何调度都不会出错**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241232872.png" alt="image-20220724123219649" style="zoom:67%;" />

### Too Much Milk: Solution #1½ 

- 既然会来不及放便条，那轮到我的时候我第一件事就是放便条？
- 直接死锁，因为先放了便条，然后再去检查是否有便条，这样永远都有便条，没有任何人能够去买牛奶。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241238261.png" alt="image-20220724123857018" style="zoom:67%;" />

### Too Much Milk Solution #2

- 第三种方法也不行。考虑下列情况：
  - A先留下A的便条，然后被调度走。
  - 调度到B，B留下便条，然后被调度走。
  - 调度回A，此时AB都留下了便条，A不能去买牛奶。
  - 调度到B，B也不能去买牛奶，因为A留下了便条。
  - 于是大伙都喝不到牛奶。
- 这种情况叫做饥饿锁。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241349817.png" alt="image-20220724134907540" style="zoom:67%;" />

### Too Much Milk Solution #3

- 能够解决牛奶过多的问题，但是存在一些缺点。
  - 可以穷举每一种情况，都是能够解决问题的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241359262.png" alt="image-20220724135900997" style="zoom: 67%;" />
- 缺点：
  - 最主要的缺点就是线程A在有noteB的时候在忙等（wasting cycles）
  - 代码非常复杂，但是解决的问题却很简单
  - A和B的代码是不一样的
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241404805.png" alt="image-20220724140431562" style="zoom:67%;" />

### Too Much Milk: Solution #4?

- 加锁
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241408270.png" alt="image-20220724140809016" style="zoom:67%;" />

## Back to: How to Implement Locks?

- 如果使用原子的Load和Store指令来实现锁，会很复杂而且容易出错
- 使用硬件锁指令？
  - 复杂度很高，并且不好实现线程的休眠。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241413111.png" alt="image-20220724141300793" style="zoom:67%;" />

### Naïve use of Interrupt Enable/Disable

- 直接把开关中断当做是一个锁。

  - 因为把中断关了，外部事件就无法夺取线程的控制权了
  - 只要保证不出现内部事件，那么就不会出现线程被调度走的情况（保证了线程可以执行完临界区的代码而不被打断，也就是一次只有一个线程进入临界区）。
  - 也就等于是变相加锁。

- 因此，加锁的实现就是把中断给禁用了，放锁的实现就是把中断重新启用。

- 这个方法的问题：

  - **绝对不能让用户以这样的方式加锁**：因为加了锁之后就没有中断了，那么假如用户陷入死循环，没有办法把CPU的控制权拿回来。

    - ```c
      LockAcquire();//加锁，关闭了中断，外部事件没办法夺取控制权
      while(1){
          ;
      }//一直死循环，没办法放锁，中断没办法重新启用
      ```

  - 对于实时系统来说，没有办法满足实时性的要求，这可能是很大的安全问题。

    - 比如汽车的系统，对延迟的要求很高，实时性是安全性的保证。

  - 对于I/O这样的事件无法及时响应

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241418176.png" alt="image-20220724141825852" style="zoom:67%;" />

### Better Implementation of Locks by Disabling Interrupts

- 基本思想：使用一个锁变量，而不是使用中断的开关本身来作为锁。只有在加锁和放锁的过程中关中断。
- 加锁：
  - 关中断，检查锁变量是否是BUSY。
  - 如果不是，将其置为BUSY，拿到锁，开中断。
  - 如果是，将线程放入等待队列，陷入休眠，但是不开中断（为什么？带着关中断休眠？）。**休眠结束后开中断。**
- 放锁：
  - 关中断，检查等待这个锁的等待队列中是否有其他线程在等待这个锁。
  - 如果有，将这个线程放入就绪队列（唤醒其休眠），但是不修改锁变量为FREE，保留其为BUSY。（为什么？）
    - 因为其实没有必要先把`value`修改为FREE，然后再由拿到锁的线程修改为BUSY。保留`value`本身为BUSY，同时将线程放入就绪队列，实际上就是将锁给它了。其他要锁的线程是要不到锁的，因为检查到`value`是BUSY。
  - 如果没有，修改锁变量的值为FREE。
  - 不管有没有，最终都要开中断。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241430614.png" alt="image-20220724143042328" style="zoom:67%;" />

- 为什么需要关中断？
  - 检查和修改锁变量`value` 值相当于临界区，开关中断相当于在给临界区加锁。
  - 开中断是为了保证在检查和修改`value`的值的时候不会被调度走，防止同时多个线程拿锁。
  - 这里开关中断包括的临界区很短，中断被禁用的时间不长，关键中断能及时响应。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241439483.png" alt="image-20220724143955190" style="zoom:67%;" />
- 为什么在加锁的时候，没拿到锁去休眠，不把中断重新启用？
  - 把线程放到等待队列之前开中断：
    - 线程发现锁是BUSY，开中断，准备把线程放到锁的等待队列上，然后调度器调度。
    - 新的线程将锁释放，并且发现等待队列上没有线程等待，直接将锁置为FREE。
    - 回到旧线程，就线程将自己放入队列，进入休眠，但是这时候，锁却是FREE的。
  - `GotoSleep()`之前开中断：
    - 线程这次把自己放入等待队列了，然后开中断，调度器调度。
    - 新的线程释放锁，并且发现等待队列上旧线程在等待，于是把其放入就绪队列。
    - 旧的线程从就绪队列进入运行状态，然后下一步运行的是`sleep()`。
    - 情况变成了，旧的线程拿到了锁，但是它陷入了休眠，成了死锁。
  - `GotoSleep()`之后开中断？怎么开？这个线程本身休眠了，肯定没办法让它负责开
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241502903.png" alt="image-20220724150248578" style="zoom:67%;" />
- `GotoSleep()`之后开中断？
  - 线程A关中断==>上下文切换==>线程B开中断,运行一段时间==>关中断>上下文切换==>A开中断。
  - 意思就是说，由上下文切换之后的新线程负责开中断。这本身也是很合理的，因为上下文切换的时候本身就是需要关中断的，保存和加载状态的时候是不能被中断打断的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207241528139.png" alt="image-20220724152819824" style="zoom:67%;" />
