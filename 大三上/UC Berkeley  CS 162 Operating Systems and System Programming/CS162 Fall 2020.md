# CS162 Lecture 1: What is an Operating System?

- 一些课程提供的资料：
  - ![image-20220712165459645](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121655779.png)
- 教学大纲
  - ![image-20220712165524048](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121655112.png)
- Homework & Project
  - ![image-20220712165635837](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121656911.png)
- What is a OS?
  - ![image-20220712171723257](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121717309.png)
  - ![image-20220712171707991](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207121717063.png)

# CS162 Lecture 2: Four Fundamental OS Concepts

- OS提供了位于应用和物理机器之间的一层抽象机器。
  - 处理器：抽象为线程
  - 内存：地址空间
  - 磁盘、固态：文件
  - 网络：Socket
  - 机器：进程
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131343362.png" alt="image-20220713134314241" style="zoom:67%;" />
- 四个基础的OS概念：
  - 线程：程序的执行上下文。
    - 完整描述程序状态，包含PC的值、寄存器的值、标志位的值（0、溢出,etc）、栈
  - 地址空间（不管有或者没有地址翻译）
    - 程序能访问的一系列的内存地址（用于读写）
    - 可能和物理机器的内存空间不同（使用虚拟地址）
  - 进程：一个正在运行的程序的实例
    - 受保护的地址空间以及一个或多个线程
  - 双模式运转：
    - 一个典型的处理器有两种状态：用户态和内核态
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131345895.png" alt="image-20220713134510818" style="zoom:67%;" />

## First OS Concept: Thread of Control

- 线程：单个执行上下文。
  - 程序计数器、寄存器、标志位、栈、内存状态
- 当一个线程位于处理器中时，它就处于执行中的状态。
- 什么叫位于处理器中：
  - 寄存器保存了线程的上下文
    - 包含PC、当前正在执行的指令。
  - 包含正在进行的计算的立即数。有真的值也有指针值。
  - 栈指针指向栈顶。
  - 其余的位于内存中。
- 当一个线程的状态没有被加载到处理器中时，它就是被挂起的。
  - 此时处理器指向其他的线程。
  - 当一个线程被挂起时，它被保存在内存中，以TCB($Thread \ Control \ Block$)的形式。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131418075.png" alt="image-20220713141801983" style="zoom:67%;" />

- 可以将线程看做位于一个个的虚拟核上。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131427942.png" alt="image-20220713142748867" style="zoom:67%;" />
- 情境演示，当发生上下文切换时发生了什么：
  - 宏观上来看，从T1切换到T2的这段时间，发生的是上下文切换。
  - 具体来说，将`vCPU1`的PC的值、栈指针的值等等存入`vCPU1`的TCB放入内存。
  - 将位于`vCPU2`的TCB中的PC的值/栈指针等等加载到对应的地方（寄存器等）。
  - **目前暂且可以认为TCB是存储在内核所在的内存空间中的**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131429278.png" alt="image-20220713142908190" style="zoom:67%;" />

- 当有多个线程时，内存中是什么样的（线程这个抽象能够带给我们什么？）：
  - 每个线程都有自己的堆、栈、数据、指令
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131440749.png" alt="image-20220713144032648" style="zoom:67%;" />

## Second OS Concept: Address Space

- 一个线程的内存是分段的：
  - 代码段：代码
  - 静态数据段：全局变量、静态变量、字符串等
  - 栈：本地变量（比如当函数调用前将本地的变量入栈）
  - 堆：使用`malloc()`分配的内存，比如带指针的结构，链表之类的。
  - 关于堆和栈的分配，以后再说。



<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131554912.png" alt="image-20220713155410805" style="zoom:67%;" />

- 如果采用最原始的，所有的`vCPU`共享所有的非CPU资源，比如I/O、内存。那么会存在很多安全问题。
  - 每个线程可能会覆写其他线程的内存，甚至是覆写操作系统的内存。
  - 这种只使用物理内存空间的方法用于早期的操作系统，但是这种方法风险很大。
  - 所以我们需要操作系统提供一些保护措施。
- 简单的复用是没有保护措施的。
  - 操作系统必须保护自身免受其他用户程序的危害。
    - 限制线程能够访问的数据以及线程能够做的事情的尺度。
    - 保证每个线程都能够分到合适的系统资源比例（公平性，不会饿死是底线）。
  - 操作系统同样需要保证用户程序彼此之间不存在危害。
  - ![image-20220713160523548](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131605640.png)

### Simple Protection: Base and Bound (B&B)

- 借助硬件帮助OS提供保护。
- Base寄存器保存线程能够访问的内存的起始地址，Bound寄存器保存程序能够访问的内存的上限地址。
  - 每当要访问一个地址前，先检查其是否处于$[Base,Bound)$区间内。不处于的话可能就杀掉进程。
  - 但是由于可执行文件中的所有的地址都看上去是从地址`00000000`开始加载的，所以需要一个`重定位加载器`（软件性的重定位）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131623288.png" alt="image-20220713162341210" style="zoom:67%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131608432.png" alt="image-20220713160857343" style="zoom: 80%;" />

### Simple address translation with Base and Bound

- 基于上一个的基础上，使用硬件来做地址转换（那个加号就是）。
- 传入的地址类似偏移量，由硬件加上基址做地址转换。地址合法性检查同前。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131639954.png" alt="image-20220713163902857" style="zoom:80%;" />

### Another idea: Address Space Translation

- 程序运行在和物理内存完全分离的地址空间上。虚拟地址经过硬件翻译得到物理地址。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131710679.png" alt="image-20220713171017584" style="zoom:67%;" />

- 分页虚拟地址空间

  - 将整个虚拟地址空间划分为等尺寸的块（页），每一页有一个`Base`
  - 每页的大小一样，所以很容易把每页放入内存。
  - 硬件利用页表实现地址翻译。
  - 每页有一个独立的`Base`，每页的`Bound`是页面的尺寸。
  - 特殊的硬件寄存器保存指向页表的指针。
  - **将内存也分页为与虚拟页等尺寸的帧，这样就可以把任意页放入任意帧**
  - 分页后，指令运行在虚拟地址上。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131711366.png" alt="image-20220713171121273" style="zoom:67%;" />

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207131715030.png" alt="image-20220713171528931" style="zoom:67%;" />

## Third OS Concept: Process

- 一个进程是具有受限制的权利的执行环境。
- 一个进程包含的资源有：
  - 受保护的地址空间，带有一个或多个线程。
  - 内存（地址空间）
  - 文件描述符、文件系统上下文，etc
  - 进程将一个或多个**共享进程资源**的线程封装起来。
- 应用程序作为进程启动，应用程序还可以启动子进程（使用`fork()`/`exec()`。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207140943847.png" alt="image-20220714094253633" style="zoom:80%;" />
- 为什么需要进程？
  - 它提供了受保护的地址空间，能够使得进程与进程之间相互隔离开（不互相伤害，比如覆写对方内存），能保护操作系统不受其他进程危害。
  - 进程之内的线程之间是有可能覆写内存的。
- 在保护性与效率之间存在一个很重要的`tradeoff`，在进程内的通信更加容易（但是更危险），在进程之间的通信更难（但是更安全）

- 单线程和多线程的进程：
  - 不管是单线程还是多线程。**每个线程都有属于自己的堆、栈（因为每个线程至少都需要保存自己的函数调用栈）**
  - 线程封装了并发（还有并行）。
  - 地址空间封装了保护，使得有bug的软件不会导致系统崩溃。
  - 我们为什么需要多线程？
    - 并行性。如果有多个核，那么使用多线程，每个核上运行一个线程，这样可以利用硬件优势提高针对同一个任务的效率。
    - 并发性。比如一个线程负责监听鼠标事件，一个线程负责监听窗口事件，一个线程负责网络连接。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207140947196.png" alt="image-20220714094759028" style="zoom:67%;" />

- Why do we need Process?Protection and Isolation.
  - ![image-20220714095549569](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207140955719.png)

## Fourth OS Concept:  Dual Mode Operation

- 注：`w/:with`,`w/o: without`。

- 硬件至少提供两种运行模式（至少一比特的模式位）

  - 内核模式，内核态。（监管者模式，超级用户模式？）
  - 用户模式，用户态。

- 当处于用户态时，某些特定的操作是被禁止的。

  - 比如改变页表指针，关闭中断，直接与硬件交互，写入内核内存。

- 用户态与内核态的转换是严格受控的。

  - 中断、系统调用、异常。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141014411.png" alt="image-20220714101408224" style="zoom:80%;" />

- 以Unix的宏内核为例:

  - 应用、标准库等等处于用户态。
  - 系统调用、中断、陷阱、异常等属于内核态。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141018300.png" alt="image-20220714101841138" style="zoom:80%;" />

- 用户态下有受限的硬件(HW)访问，内核态下则是完全的访问权限。

  - `exec()`:内核态===>用户态
  - 系统调用:用户态===>内核态
  - `rtn`:指的是从内核态的`return`。
  - 中断:用户态==>内核态
  - 其他的看图吧。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141020955.png" alt="image-20220714102006825" style="zoom: 67%;" />

- 能够通过容器技术和虚拟机等提供额外的保护：

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141025853.png" alt="image-20220714102514701" style="zoom:80%;" />

- 三类 用户态$\Rightarrow$内核态的转换：

  - 系统调用：类似函数调用，但是是在进程外部的。当进程需要操作系统服务时。
  - 中断：外部非同步的事件触发。
  - 陷阱或者异常：进程内部的同步事件触发，如除0、`segmentation fault`。
  - **三种都是unprogrammed control transfer**（未编程的控制转移？）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141026623.png" alt="image-20220714102615481" style="zoom:80%;" />

- Process Control Block：PCB，进程控制块。
  - PCB保存了进程的状态信息，内核以PCB的形式代表每个进程。
    - 进程的状态：正在运行、就绪、阻塞,etc。
    - 进程的PID、用户、可执行文件、优先级
    - 执行时间
    - 内存空间...
  - 内核调度器维持一个包含许多PCB的数据结构。
  - 调度策略选择下一个要运行的进程。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141029563.png" alt="image-20220714102956440" style="zoom:80%;" />

## Conclusion: Four Fundamental OS Concepts

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141045234.png" alt="image-20220714104514072" style="zoom:80%;" />

# CS162 Lecture 3: Abstractions 1: Threads and Processes

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141046144.png" alt="image-20220714104604015" style="zoom: 80%;" />

- Goals for today:
  - **What** threads are
    - –And what they are not
  - **Why** threads are useful (motivation)
  - **How** to write a program using threads
  - **Alternatives** to using threads



## What Threads Are

- 线程：单个的执行上下文。
- 线程：代表一个能被**独立调度**的任务的执行序列。
- 线程可以用于并发，也可以用于并行。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141544546.png" alt="image-20220714154448374" style="zoom: 67%;" />



## Motivation for Threads

- 概括起来就是我们需求一个程序能一次处理多件事。

- Threads are a unit of *concurrency* provided by the OS

  Each thread can represent one thing or one task

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141550036.png" alt="image-20220714155013916" style="zoom:67%;" />

## Multiprocessing vs. Multiprogramming

- Multiprocessing：有多个CPU或者核心，同时致力于同一个任务。
- Multiprogramming：多个任务或进程，不一定要同时进行。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141553782.png" alt="image-20220714155331674" style="zoom: 80%;" />

- 并发与并行的区别：
  - 并发是一次能够处理多件事情，而并行是指同一个时刻有多个任务同时执行。
  - 例如，两个线程运行在一个单核CPU上，这两个线程是并发的，但是并不是并行的（因为是两个线程轮流切换）。
  - 每个线程能处理一个独立的任务，但是这些任务并不一定是同时执行的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141603707.png" alt="image-20220714160331599" style="zoom:67%;" />

## Threads Mask I/O Latency

- 一个线程的三个状态：正在运行、就绪、阻塞
- 如果一个线程在等待I/O完成，那么OS会将其标记为阻塞，并且将其移除到就绪表。当I/O完成，OS将其标记为就绪。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141622404.png" alt="image-20220714162201315" style="zoom: 60%;" />
- **一个被阻塞的线程并不能直接从阻塞态跳转到运行态，因为需要给调度器一个调度它的机会**，不能越过调度器直接运行。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141618840.png" alt="image-20220714161832740" style="zoom: 67%;" />

## OS Library API for Threads: *pthreads*

- P：指的是[POSIX](https://baike.baidu.com/item/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/12718298?fromtitle=POSIX&fromid=3792413&fr=aladdin)。
- **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为**POSIX**）是[IEEE](https://baike.baidu.com/item/IEEE)为要在各种[UNIX](https://baike.baidu.com/item/UNIX)[操作系统](https://baike.baidu.com/item/操作系统)上运行软件，而定义API的一系列互相关联的标准的总称
- 但是其实目前并没有完全标准化的接口。
- 关于C的函数指针[Function Pointer in C](https://www.geeksforgeeks.org/function-pointer-in-c/)

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine)(void*), void *arg);
//void *(*start_routine)(void*)
//函数指针，指向一个函数void* func(void* )

int pthread_join(pthread_t thread, void **value_ptr);
//暂停调用线程的执行，直到目标线程终止。
```

![image-20220714172035800](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141720923.png)

- What happens when pthread_create(…) is called in a process?
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141737228.png" alt="image-20220714173728124" style="zoom:67%;" />
- Fork-Join Pattern：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141737162.png" alt="image-20220714173752054" style="zoom:67%;" />

## Thread State

- 线程间共享的：
  - 共享内存（全局变量、**堆(Heap)**、静态变量）
  - I/O状态（文件描述符、**网络连接**,ect）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141740675.png" alt="image-20220714174026576" style="zoom: 80%;" />
- 线程私有的：
  - 都保存在TCB中
  - 寄存器的值，包括PC
  - 调用栈
- 调用栈：
  - 参数、临时变量
  - 函数调用的返回位置

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141753865.png" alt="image-20220714175317749" style="zoom:67%;" />

## Thread Abstraction

- 程序员视角：有无限多个处理器，可以满足多线程的要求。
- 现实：有一部分线程在运行，有一部分线程没有运行，线程轮换。
- 程序员期待的代码运行于实际调度的不确定性：
  - 程序员看来每行代码是连续执行的，但是在实际的调度中，可能确实是连续执行的，也可能是执行一行就被挂起。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141804787.png" alt="image-20220714180455671" style="zoom: 67%;" />

## Correctness with Concurrent Threads

- 非确定性：
  - 调度器可以以任何顺序运行线程。
  - 调度器可以在任何时候切换线程。
  - 这使得测试非常困难。
  - 但是我们要保证我们的程序在这种非确定性之下永远是正确的。
- 独立线程：
  - 线程之间没有共享的状态
  - 确定性的、可以复现的情况
- 协作线程：
  - 多个线程之间共享状态。

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141806125.png" alt="image-20220714180617033" style="zoom:67%;" />

## Race Conditions

- 不存在Race Condition：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141917029.png" alt="image-20220714191747923" style="zoom:67%;" />
- 存在Race Condition：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141918269.png" alt="image-20220714191809174" style="zoom: 67%;" />

## Relevant Definitions(关于锁和同步的)

- 同步：线程之间的协作，通常与共享的数据有关。
- 互斥：保证一次只有一个线程能做某个特定的操作
- 临界区：一次只能有一个线程运行的代码
- 锁：一次只能有一个线程持有的对象。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141919671.png" alt="image-20220714191906567" style="zoom:67%;" />



## Locks

- 锁提供两个原子操作：
  - 获取锁：等待直到锁是空闲的，然后将其标记为占用。称作这个线程持有这个锁。
  - 释放锁：只能被目前持有这个锁的线程调用。调用返回后，这个线程不再持有这个锁。
- 目前暂不关心锁的具体实现。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141948898.png" alt="image-20220714194832793" style="zoom:67%;" />

## OS Library Locks: *pthreads*

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207141950618.png" alt="image-20220714195040516" style="zoom:67%;" />

## Processes

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207142011692.png" alt="image-20220714201130594" style="zoom:80%;" />

- 所有的进程都是被其他进程创建的，那么第一个进程是如何来的？
  - `Bootstrapping`：自举。
  - 第一个进程是被内核启动的，常称作`init`。在此之后所有的进程都被其他进程所创建。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150914103.png" alt="image-20220715091436908" style="zoom: 80%;" />

## Process Management API

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150918074.png" alt="image-20220715091858929" style="zoom:67%;" />

### exit()

- 当没有显式调用`exit()`时，OS库会隐式调用。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150920201.png" alt="image-20220715092014032" style="zoom:80%;" />

### fork()

- `fork()`会将当前进程的内存复制一个副本，放入一个新的地址空间。
  - 新的进程有不同的PID，但是内存和父进程是完全一样的。
  - 新的进程最开始只有一个线程。
  - `fork()`在子进程中返回0，在父进程中返回子进程的PID。
  - 如果`fork()`失败，则返回一个负数。
  - 子进程和父进程之间构成一棵进程树，如果子进程再`fork()`则它也变为父进程
  - 当父进程被`kill()`，子进程不会被`kill()`，会被父进程的父进程接管，一直`Kill()`最终由`init`进程接管。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150923297.png" alt="image-20220715092331114" style="zoom: 67%;" />

- C:Child，P:Parent
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150927729.png" alt="image-20220715092731554" style="zoom: 60%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150928490.png" alt="image-20220715092809318" style="zoom:60%;" />

- 在这种情况下两个`i`并不会发生竞争冒险，因为是不同的`i`，处于不同的地址空间。但是输出的顺序会因为调度的原因变化多样。
  - 完全独立的地址空间，因为是两个进程而不是线程。所以只存在对标准输出流的竞争。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150933928.png" alt="image-20220715093329735" style="zoom:67%;" />

### exec()

- `exec()`会将当前进程的内存内容全部清空，使用新进程覆盖。
- 下图的情况下，正常情况下`execv()`是不会`return`的（都全部覆盖了还return干嘛）。只有出错的时候才会`return`。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151005384.png" alt="image-20220715100537180" style="zoom:67%;" />
- `Shell`是如何利用`fork()`和`exec()`实现的：
  - 每当敲入一个命令，终端`fork`出一个新的终端，然后新的终端`exec`出命令对应的进程，旧中断则等待其返回。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151007207.png" alt="image-20220715100744017" style="zoom:67%;" />

### wait()

- `wait()`会一直等待子进程直到其结束，并将子进程`exit()`的参数值填充到`status`中去（图中是42），同时返回子进程的`PID`。
- 如果有多个子进程，可以指定等待哪一个子进程。`wait()`能起作用是因为内核维护了父子进程关系。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151009986.png" alt="image-20220715100944814" style="zoom:67%;" />

### kill() & sigaction()

- `sigation()`：设定收到相应的信号时的处理器。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151020424.png" alt="image-20220715102033267" style="zoom:67%;" />

- POSIX SIGNAL：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151023717.png" alt="image-20220715102305568" style="zoom:67%;" />
- 下面这个当收到`Ctrl + C`时会调用`signal_callback_handler()`

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151022931.png" alt="image-20220715102226740" style="zoom:67%;" />



## Conclusion

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207150937087.png" alt="image-20220715093743899" style="zoom:80%;" />

# CS162 Lecture 4: Abstractions 2: Files and I/O

![image-20220715102856207](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151028413.png)

- Goals for Today: The File Abstraction
  - High-Level File I/O: Streams
  - Low-Level File I/O: File Descriptors
  - *How* and *Why* of High-Level File I/O
  - Process State for File Descriptors
  - Common Pitfalls with OS Abstractions

## Unix/POSIX Idea: Everything is a “File”

- 一切都是文件，因此有很多东西有相似的接口
  - 硬盘上的文件
  - 设备
  - 普通文件
  - 网络（Socket）
  - 本地进程间通信的手段
- 这些接口是基于系统调用的：`open()、read()、write()、close()`
- `ioctl()`用于配置那些不太符合的。
- 一切皆文件的思想在提出来的时候是相当激进的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151057805.png" alt="image-20220715105725593" style="zoom:67%;" />

## The File System Abstraction

- 文件：
  - 一个字节流序列，可以是文本文件、二进制文件、序列化对象。
  - 元数据：描述文件本身的数据，包括其大小、最后一次编辑的时间、所有者、安全信息、访问权限等。
- 目录：
  - 包含文件和目录的文件夹。
  - 在内核中，文件夹也只是一个将文件名与实际的文件内容映射起来的一个文件。
  - 目前暂时不深入讲解。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151104711.png" alt="image-20220715110445508" style="zoom:67%;" />

## Connecting Processes, File Systems, and Users

- 每个进程都有一个工作目录($CWD$)，工作目录可以使用系统调用更改。
- 绝对路径会忽略掉$CWD$。
- 相对路径是相对$CWD$来说的。
- `~`是`home`目录。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151504704.png" alt="image-20220715150403517" style="zoom: 67%;" />

## C High-Level File API – Streams

- 字节流：未格式化的字节序列（不存在关于它是文本文件还是二进制数据的信息），带有一个指针指向当前阅读的位置。
- 打开的字节流使用一个`FILE`结构体指针来代表。
- `fopen()`返回的是一个`FILE`结构体指针，打开文件后的后续操作都是使用这个指向文件的指针。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151514270.png" alt="image-20220715151416132" style="zoom:67%;" />

## C API Standard Streams – stdio.h

- 三种预定义的标准流：
  - 标准输出流：一般是屏幕
  - 标准输入流：一般是键盘
  - 标准错误流：一般也是屏幕
- 三种标准流都是可以被重定向的。比如使用管道进行输入重定向和输出重定向。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151545084.png" alt="image-20220715154518953" style="zoom:67%;" />

## C High-Level File API

```c
// character oriented  
//返回值是int而不是char,是因为EOF是-1，-1并不是任何一个char
int fputc( int c, FILE *fp );			// rtn c or EOF on err,put a char
int fputs( const char *s, FILE *fp );	// rtn > 0 or EOF,put a String

int fgetc( FILE * fp );
char *fgets( char *buf, int n, FILE *fp );

// block oriented
//一块一块的读取或写入字节流，在这种情况下需要一个缓冲区。
size_t fread(void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
size_t fwrite(const void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);

// formatted
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int fscanf(FILE *restrict stream, const char *restrict format, ... );

```

```c
int main(void) {
  FILE* input = fopen(“input.txt”, “r”);
  FILE* output = fopen(“output.txt”, “w”);
  int c;
//这里使用int来接收读取到的字符是因为fgetc()会返回EOF,而EOF不是一个char,EOF是-1
  c = fgetc(input);
  while (c != EOF) {
    fputc(output, c);
    c = fgetc(input);
  }
  fclose(input);
  fclose(output);
}

#define BUFFER_SIZE 1024
int main(void) {
  FILE* input = fopen("input.txt", "r");
  FILE* output = fopen("output.txt", "w");
  char buffer[BUFFER_SIZE];
  size_t length;
    //返回值是读取到的字符的个数，不一定和缓冲区的大小一模一样。
    //第二个参数是一次读取多少个字符，应该看做是一次读取字符数的上限。
  length = fread(buffer, BUFFER_SIZE, sizeof(char), input);
  while (length > 0) {
    fwrite(buffer, length, sizeof(char), output);
    length = fread(buffer, BUFFER_SIZE, sizeof(char), input);
  }
  fclose(input);
  fclose(output);
}
```

## C High-Level File API: Positioning The Pointer

- 用于调整指针位置的`fseek()`
  - 针对偏移量是相对谁的偏移量有三种选项，三种选项都是定义在`stdio.h`中的常量。
  - `SEEK_SET`:相对起点的偏移量
  - `SEEK_END`:相对终点的偏移量
  - `SEEK_CUR`:相对当前位置的偏移量
- 用于查看当前指针位置的`ftell()`
- 用于重置指针到流的起点的`rewind()`

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151614056.png" alt="image-20220715161426880" style="zoom:67%;" />

## Key Unix I/O Design Concepts

- 一切皆文件
- 使用之前先打开
- 面向字节：一切都是字节流，内核对任何数据或文件的结构和格式一无所知，除了一个特例：目录。
- 内核缓存读和写：
  - 一部分原因是为了缓存和性能
  - 还有一部分原因是硬盘之类的是面向块的，所以一次只能向硬盘写入一块字节。
- 显式关闭

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151631757.png" alt="image-20220715163154598" style="zoom:80%;" />

## Low-Level File I/O: The RAW system-call interface

- `open()`返回的是一个文件描述符，当返回值小于零时出错。
  - Open system call created an *open file description* entry in system-wide table of open files
  - –*Open* *file description* object in the kernel represents an instance of an open file
  - 为什么返回给用户的是一个文件描述符，而不是一个指向文件描述对象的指针？安全，防止用户访问不该访问的东西。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151651393.png" alt="image-20220715165122226" style="zoom:80%;" />

## C Low-Level (pre-opened) Standard Descriptors

- 在`unistd.h`中预定义了三个标准流所对应的文件描述符。
  - 标准输入流：0
  - 标准输出流：1
  - 标准错误流：2
- `FILE`结构体中是记录了文件的文件描述符的，能够通过`fileno()`得到。
- 第三个函数看图

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151656906.png" alt="image-20220715165633769" style="zoom:80%;" />

## Low-Level File API

- 三个都和高等级下的FILE API相似，只不过是有些地方将`FILE*`替换成文件描述符。
- 注：`filedes`:file descriptor.
- `read()`返回读到的字符的个数，不超过`maxsize`指定的个数。返回0代表EOF，-0代表出错。
- `write()`返回写入的字符的个数。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151659892.png" alt="image-20220715165926744" style="zoom:80%;" />

## POSIX I/O: Kernel Buffering

- 读和写都是缓存在内核中的，原因之前已经说过。
- 其他的以后深入。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151702326.png" alt="image-20220715170245179" style="zoom:67%;" />

## Low-Level I/O: Other Operations

- 最后两个以后深入讲
- Pipe那个用来建立一条管道。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151722243.png" alt="image-20220715172211093" style="zoom: 80%;" />

## High-Level vs. Low-Level File API

- `fread()`并不是传入需要读取的字符个数，就向内核请求多少字符个数，而是会一次请求比如4KB，然后缓存起来，然后从缓存里读。
  - 假如你要读13个字节，`fread()`并不是从内核里请求出13个字节，而是直接带出一大块数据（比如4KB）缓存起来，然后从缓存读取前13个字节。
- 流是被缓存在用户内存中的，而针对文件描述符的操作是立即可见的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151740017.png" alt="image-20220715173959863" style="zoom:67%;" />

## What’s in a FILE?

- FILE结构中有什么：
  - 文件描述符
  - 缓冲区（用户缓冲区，之前提到的）
  - 锁（同步用的，防止多个线程同时访问这个结构）
  - 其他东西不重要。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151742047.png" alt="image-20220715174215905" style="zoom:67%;" />

## FILE Buffering

- 当你借助`FILE`结构使用`fwrite()`向文件中写入数据时，你的数据实际上发生了什么？
  - 数据先被缓存到`FILE`结构体的缓冲区中去。
  - 如果缓冲区满，就刷新缓冲区（把缓冲区现有的内容写入文件）
    - 也就是说你给的数据其实不一定会立即写入文件。
    - 所以不要指望FILE帮你及时写入，而是在有需要的时候人为刷新`fflush()`。
  - C标准库可能会更频繁的刷新缓冲区。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151742950.png" alt="image-20220715174250811" style="zoom:67%;" />



- 例子1：
  - 写入的字符`b`可能已经被写入文件了，也可能只是被缓存在`f1`的缓冲区中，所以`fread()`可能读到`b`也可能没读到。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151745624.png" alt="image-20220715174546474" style="zoom: 80%;" />

- 例子2：人为立即刷新了缓冲区
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151747058.png" alt="image-20220715174709911" style="zoom:80%;" />
- Writing Correct Code with FILE：
  - 根据需要加入人为的`fflush()`去刷新缓冲区
  - 调用`fclose()`时会先刷新缓冲区，然后再回收资源。
  - **当使用低等级的file API，就不存在上述问题**（但是也同样没有那么好的性能）
  - `fgetc()`等的性能这么好是因为：你要读的第一个字节会进入内核顺便带回来一大块数据缓存起来，然后后续的读取都直接从缓冲区读取，直到缓冲区耗尽，才会有第二次系统调用（再一次带回一大块数据）。
  - ![image-20220715174817608](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151748755.png)

## Why Buffer in Userspace?

- 在用户空间使用缓存的原因有两个
  - 一是开销，系统调用的开销比函数调用大很多。使用`read()`读取一个字节的开销比使用`fget()`大得多，因为后者会缓存（前面讲过的那种缓存）
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151759515.png" alt="image-20220715175918346" style="zoom:67%;" />
  - 二是为了功能性。比如内核是完全不知道字节流的类型的，它只知道字节流，所以诸如读取一行这样的操作是没办法由内核完成的，因为内核不知道什么是换行符，这种操作就只能在更高层级完成。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207151800581.png" alt="image-20220715180037425" style="zoom:80%;" />

## State Maintained by the Kernel

- 当成功打开一个文件时，`open()`返回一个文件描述符，同时在内核创建其对应的文件描述对象。
- 对于每个进程，内核维持一个文件描述符到其所对应的打开的文件描述对象的映射。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152038562.png" alt="image-20220715203822384" style="zoom: 80%;" />



- What’s in an Open File Description？
  - 最重要的两个，一个是用来记录在硬盘上的哪个地方找到对应的文件，另外一个是位置指针在文件中的当前位置。

## Abstract Representation of a Process

- 举例：
- 最开始的时候，进程打开一个文件：
  - 文件描述符是3，是因为0、1、2分别是预定义的标准流。
  - Open File Description记录了文件描述符对应的文件，以及当前位置。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152044610.png" alt="image-20220715204407435" style="zoom:67%;" />
- 然后进程往后读了100字节，此时Position变为100。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152046685.png" alt="image-20220715204601512" style="zoom: 67%;" />
- 假如下一步执行`close(3)`，那么变为：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152049517.png" alt="image-20220715204914329" style="zoom:50%;" />
- 假如下一步`fork()`出一个子进程2，**那么子进程2会复制父进程的文件描述符**
  - **并且父子进程共享同一个Open FILE Description**。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152050152.png" alt="image-20220715205042989" style="zoom:67%;" />
- 然后子进程往后读取一百字节，那么Position变为200。
  - **假如父进程要读取一百字节，那么父进程读取的是200-300的那一百字节。**（也就是说Position是共享的）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152052280.png" alt="image-20220715205231116" style="zoom:67%;" />
- 假如父进程关闭了它的文件描述符，此时对于的文件描述并不会直接被清理：
  - **只会清理掉父进程的指向对应文件描述的指针。**
  - 抓住一点就是父子进程共享`打开文件表(Open file Description)`
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152053322.png" alt="image-20220715205339169" style="zoom:67%;" />

- 对于从同一个终端打开的两个进程来说，他们的三个标准流都会指向同一个终端。
  - 因为这两个进程是终端`fork()`而来的，它们会有同样的文件描述符。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152057325.png" alt="image-20220715205747156" style="zoom: 80%;" />

## Other Syscalls: dup and dup2

- `dup(fd)`：得到一个新的描述符，指向`fd`所对应的打开文件描述，得到的文件描述符不一定就是`fd + 1`。
- `dup2(fd1,fd2)`：指定得到的新的文件描述符为`fd2`

![image-20220715210116397](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152101572.png)

## fork() in Multithreaded Processes

- 概括来说，当在多线程中使用`fork()`时，子进程中永远只有一个线程，那就是调用`fork()`的那个线程。
- 其他线程会直接消失。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152110927.png" alt="image-20220715211054759" style="zoom:80%;" />

## Possible Problems with Multithreaded fork()

- 当在多线程中调用`fork()`时，除了那个调用`fork()`的线程，其他线程都直接消失。这就会带来一些问题。
  - 万一消失的线程有一个正持有锁？
  - 万一消失的线程有一个正处于修改某个数据结构的中途？
  - 总之会有很多乱七八糟的问题。
- **当然如果多线程`fork()`之后子进程直接`exec()`是安全的**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152112438.png" alt="image-20220715211249283" style="zoom:80%;" />

## Conclusion

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202207152116472.png" alt="image-20220715211636301" style="zoom: 67%;" />
