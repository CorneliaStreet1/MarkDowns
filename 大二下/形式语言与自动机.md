

# 第1章 绪论

## 为什么要学习形式语言与自动机

- 《编译原理》的前置课程
- 相关课程：《模式识别》、《算法分析》

## 概述及应用

### 核心内容

- 有限状态自动机，正规语言，正规表达式。或许叫正则语言和正则表达式比较好。
- 上下文无关文法、上下文无关语言、下推自动机
- 图灵机、计算问题分类



## 形式语言

- 什么是形式语言：形式化描述的字母表上的字符串的集合。
  - 字母表：字符的有限集合。
    - 与常规意义上的字母表含义不同。（不一定要是26个字母）
    - 任意字符组成的有限集都可以称作是一个字母表。
  - 字符串：字母表中的字符构成的有限序列。
    - 字符串和语言是不同的。
    - 对于中文来说，字符串可以是不符合语法的没有意义的一串汉字，而中文语言是可以被人理解其意思的一串字符串。
- 自然语言：人说话时所使用的语言。
- 形式语言最初是一套用于描述语言的方法，后来被用于编译原理，再后来各个领域。



## 自动机

### 定义

- 什么是自动机：具有**离散输入和输出**的**数学模型**。
- 自动机接受一定的输入，执行一定的动作，产生一定的结果。使用状态迁移来描述整个工作过程。
- 状态：一个标识，能够区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的内部状态。
- 自动机的本质：根据状态、输入和规则，决定下一个状态。
  - 规则就是状态转移函数。
  - 输入为输入集中的某个元素。
  - （当前）状态 + 输入（激励） + 规则（状态转移函数）——> 状态迁移。
- **自动机可能的状态、运行的规则都是事先确定的，一旦开始运行就会按照规则自动运行下去，所以叫自动机。**



### 自动机的分类

- 有限自动机
- 下推自动机
- 图灵机



## 形式语言与自动机的关系

- 使用形式语言来描述字符串。
- 使用自动机来识别字符串。
- 形式语言可以看做是定义语言的数学模型，而自动机可以看做是识别语言的系统。



# 第2章 语言与文法

- 主要内容：
  - 定义形式语言的术语
  - 给出文法的定义和文法的分类

- 要求掌握：
  - 语言和文法的形式定义
  - CHOMSKY文法体系的分类

## 第1节 语言的定义与运算

### 语言的一些术语

- 字母表：字符的有限集合，记为T。
- 字符串：由字母表T中的字符构成的序列称字母表T上的字符串（也叫句子，和平常意义上的句子意义不同）。

#### 字母表

- 概念：形式符号的集合，常用T，Σ来表示。
- 比如英文字母表，汉字表，英文标点符号表，ASCII码表。



#### 字符串

- 概念：由字母表T上的字符构成的有限序列，也称作字(word)，也简称串。
- 空串用`ε`来表示，空串不包含任何字符。
- 字符串的长度：某个`字符串W`中字符的个数，记作`|W|`。
  - |ε| = 0，空串的长度为0。

### 字符串的运算

- 连接运算：记两个字符串为X和Y，则X与Y的连接记作XY，就是把Y的字符直接拼接到X的字符的右侧末尾。
  - 比如X = 114514，Y = 1919180，则XY = 11145141919180，YX = 1919180114514。
- 连接运算的性质：
  - 结合律：$(XY)Z = X(YZ)$。
  - 零元：$$εΧ = Χε = X$$。
  - 拼接后的字符串长度等于拼接前的字符串的长度之和：$$|XY| = |X| + |Y|$$。
- 子串：记由三个字符串拼接而成的字符串W1W2W3
  - 前缀：W1
  - 后缀：W3
  - 子串：W2
  - 空串是任何字符串的前缀、后缀及子串。
  - 字符串本身是本身的子串，前缀和后缀。
- 字符串的逆：假如原字符串是从左往右写的，把原字符串从右往左写一遍就得到了它的逆，记作$\overline W$。
  - 空串的逆还是空串。
  - W = "abcde"，则W的逆$\overline W$ = "edcba"。



### 字母表的幂运算

- 设$T$为字母表，$n$为任意自然数，则字母表的幂运算定义如下：
  - $(1)T ^0 = {ε}$。字母表的零次幂为空串。
  - $(2)$设$x∈ T^{n-1},a ∈ T$,则$ax ∈ T^n$。
  - $(3)T^n$中的元素只能由$(1)$和$(2)$生成。
  - $T^n$中的元素是长度为$n$的字符串，换句话说字母表$T$的$n$次幂运算，得到的是长度为$n$的所有字符串的集合。

- *闭包，读作星号闭包，是所有字符串的集合。

  - 可以看做是由$T^0\cup T^1\cup T^2 \cup .....\cup T^n$。
  - 星号闭包可以看做是加号闭包加上{ε}。

- +闭包，读作加号闭包，是所有非空字符串的（长度大于集合。

  - 可以看做是由$T^1\cup T^2 \cup .....\cup T^n$。

  - 加号闭包是星号闭包去掉$\{{ε}\}$。





### 语言

- 概念：设$T$为字母表，则任何集合$L \subseteq T$是字母表$T$上的一个语言。
  - 比如成语集，比如英文单词集。
  - 空集$\empty$为空语言。
  - 语言是一个集合，可以进行集合的运算，对于集合的运算可以对应于对语言的运算。
- 语言的积：两个语言L~1~和L~2~的积L~1~L~2~是由L~1~和L~2~中的字符串连接所构成的字符串的集合。
  - 对应于集合的笛卡尔积。
  - $L_1L_2 = \{l_3|l_3 = l_1l_2,l_1 \in L_1, l_2 \in L2  \}$，L~1~中的所有字符串分别与L~2~中的所有字符串连接得到的集合。
  - $L_1L_2 \neq L_2L_1$。语言的积不满足交换律。
- 语言的幂：
  - $L^0 = \{ ε\}$。
  - $L^n = L^{n - 1} \cdot L = L \cdot L^{n - 1}$。语言的幂运算满足交换律

## 第2节 文法

- 文法：用来定义语言的一个数学模型。
- 表示语言的方法：
  - 语言集为有限集则直接列举。
  - 语言集为无限集：
    - 文法产生系统，由定义的文法规则产生出语言的每个句子。
    - 机器识别系统：输入一个字符串，如果这个字符串能被一个语言的机器识别系统接受，则这个字符串是该语言的一个句子，否则不是。

### 元语言

- 描述语言的语言，在讨论某种语言时，需要一种语言来描述它，元语言用来讨论对象语言。

#### Chomsky文法体系

- 任何文法必须包含：
  - 非终结符集合`N`
  - 终结符集合`T`。
  - 形式规则的有限集合`P`，也就是生成式集合。
  - 一个起始符`S`
  - **集合都是有限集合**。

- 生成式是用于产生语言的句子的规则。
- **句子是仅由终结符构成的字符串**。（因此终结符的集合也就是字母表的集合）
- **字符串必须由起始符S开始，不断使用生成式来生成**。
- 生成式是文法的核心，它决定了语言中句子的产生。

#### 文法的形式定义

- 文法$G $由四元组$G = (N,T,P,S)$构成，依次是非终结符，终结符，生成式，起始符。
- 生成式集合中的生成式必须是$\alpha \rightarrow \beta$的形式。
- $\alpha$必须是$(N \cup T)^*N^+(N\cup T)^*$。也就是（任意个终结符和任意个非终结符的任意拼接）拼接（非空终结符串）再拼接（任意个终结符和任意个非终结符的任意拼接），**也就是说$\alpha$中至少要有一个非终结符**。
- $\beta\in (N \cup T)^*$，也就是$\beta$是非终结符和终结符的并集的星号闭包，也就是说$\beta$可以是空串，也可以是任意个终结符和任意个非终结符的任意拼接。
- S为起始符，起始符一定属于非终结符的集合。



#### 推导与句型

##### 直接推导

- 设$G = (N,T,P,S)$是文法，若$A \rightarrow \beta$是$P$中的一个生成式，$\alpha$和$\gamma$是$(N \cup T)^*$的子串，则有$\alpha A \gamma \Rightarrow \alpha \beta \gamma$，称$\alpha A \gamma $直接推导 $\alpha \beta \gamma$
- 也就是直接把$A$出现的地方替换成$\beta$

##### 推导序列

- 设$G = (N,T,P,S)$是文法，$\alpha、\alpha_0 、\alpha_1、 \alpha_3 ..... \alpha_n、\alpha^{’}$都是$(N \cup T)^*$中的字符串，且$\alpha = \alpha_0，\alpha_n = \alpha^{'}$，其中$\alpha_i$直接推导出$\alpha_{i+1}$，则称序列$\alpha \Rightarrow \alpha_0\Rightarrow\alpha_1 \Rightarrow \alpha_2\Rightarrow......\alpha_n$是长度为$n$的推导序列，$\alpha \Rightarrow \alpha_0$称长度为0的推导序列。
- 推导序列的每一步都产生一个字符串，这些字符串一般称为句型。
- 对$\alpha$推导出$\alpha^{'}$记作$\alpha \Rightarrow^*_G \alpha^{'}$。上面是星号，下面是文法符号G，如果推导序列大于零，就把星号换成加号。

##### 句型和句子

- 字符串$\alpha$是文法G的句型，当前仅当从起始符能够经过推导序列得到$\alpha$，且$\alpha$是终结符和非终结符的拼接。
- 字符串$w$是文法G的句子，当且仅当从起始符能够经过推导序列得到$w$，且$w$是**仅由终结符组成的字符串**
- **句型包含句子，也就是说句子是特殊的句型（句子是句型的特例）。**

##### 文法产生的语言

- 由文法产生的语言记为$L(G) = \{w|w \in T^*，S\Rightarrow^*_G w\}$。
- 即：由文法G产生的语言，必定是从起始符经过推导序列得到的由终结符组成的字符串。

## 第3节 Chomsky文法体系的分类



- 设文法$G = (N,T,P,S)$，生成式P：$\alpha \rightarrow \beta$，$\alpha \in (N \cup T)^*N^+(N\cup T)^*$，$\beta\in (N \cup T)^*$
- 对文法体系的分类是基于生成式P的形式的，总共分为4类。
  - 0型、1型、2型、3型文法

#### 0型文法：无限制文法

- 与图灵机等价



#### 1型文法（CSG,Context-sensitive Grammar)

- 也称上下文有关文法`CSG`。

- 生成式的形式$\alpha \rightarrow \beta$，其中$|\alpha| \le |\beta| $，$\alpha \in (N \cup T)^*N^+(N\cup T)^*$，$\beta\in (N \cup T)^+$。

- $\beta$是终结符和非终结符的并集的加号闭包的元素。
- 生成式左部长度小于右部，不含$A \rightarrow ε$。

- 不考虑空串的情况下与线性有界自动机等价
- 特征：左侧不一定是单个的非终结符，**但是至少有一个非终结符的**，左侧长度小于等于右侧。

#### 2型文法(CFG,Context-free Grammar)

- 也称上下文无关文法。
- 对应语言：上下文无关语言。
- 生成式：$A \rightarrow \alpha$，$\alpha\in (N \cup T)^*，A \in N$。
- 限制：左侧是单个的非终结符，右侧是终结符和非终结符的并集的星号闭包。
- 特征：左侧是单个的非终结符，右侧是终结符和非终结符的拼接。



#### 3型文法

- 也称正则文法，分为`左线性文法`和`右线性文法`
- 对应语言：正则语言
- 对应自动机：有限自动机。
- 右线性文法：$B$在$w$的右侧
  - $A \rightarrow wB $或$A \rightarrow w$。A,B为非终结符，$w$为终结符组成的字符串。
- 左线性文法：$B$在$w$的左侧
  - $A \rightarrow Bw $或$A \rightarrow w$。A,B为非终结符，$w$为终结符组成的字符串。

- 特征：左侧是单个的非终结符，右侧是终结符和非终结符的拼接，但是非终结符的个数只有一个或零个。



#### 4类文法之间的关系

- 3型是特殊的2型，2型对右侧的非终结符的个数没有做出限制，正则文法则限制右侧的非终结符的个数不超过一个。
- 1型不允许用空串替换非终结符。
- 1、2、3型都属于0型。
- 对不含$A \rightarrow ε$的2、3型属于1型（3型是特殊的2型，自然也属于1型）。









# 第3章 有限自动机与右线性文法

- 主要内容：
  - 确定有限自动机DFA
  - 非确定有限自动机NFA
  - NFA和DFA的等价性
  - 右线性文法和有限自动机的等价性
  - 有限性文法的性质，蚌埠定理



## 第1节 有限自动机

### 有限状态系统的概念

- 状态：状态是可以将事物区分开的一种表示
- 系统可以具有离散的状态，也可以具有连续的系统。
- 有限状态系统必然是离散状态系统，否则它的状态不是有限个。

### 有限自动机的概念

- 具有离散输入和输出系统的一种数学模型。
  - 可以没有输入，更特殊一点也没有输出。
- 有限的状态
- 状态+输入$\rightarrow$状态转移。
  - 每次转换的后继状态都唯一：DFA
  - 每次转换的后继状态不唯一：NFA

- 有限自动机的五要素：
  - 有限状态集
  - 有限输入符号集
  - 转移函数
  - 一个开始状态
  - 一个终态集合



### DFA的形式定义

- 定义：DFA是一个五元组$M = (Q,T,\delta,q_0,F)$
  - $Q$：有限状态集
  - $T$：有限输入集（输入字母表）
  - $\delta$：转换函数（状态转移集合）
  - $q_0$：初始状态，$q_0 \in Q$。
  - $F$：终止状态集，$F \subseteq Q$。终态集要是状态集的子集。

#### 转移图表示的DFA

- 圈内为各个状态，双圈内的为终态。
- 弧线表示的是输入，箭头指向的是接受弧线上的输入之后，转移到的后继状态。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204151526175.png" alt="image-20220415152554736" style="zoom: 33%;" />

#### 转移表表示的DFA

- 最左边一列是起始态，最上面一行是输入的字符，其余是状态转移的后继状态。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204151622123.png" alt="image-20220415162209773" style="zoom:33%;" />







### 扩展转移函数适合于输入字符串

- $\delta^{'}$函数：接收一个字符串的状态转移函数，对任何状态集中的状态q（$q \in Q)$,定义：

  - $\delta^{'}(q,ε) = q$。
  - 若$w$是一个字符串，$a$是一个字符，定义：$\delta^{'}(q,wa) = \delta^{'}(\delta^{'}(q,w),a)$。也就是说从$q$起始，接收一个字符串输入($wa)$，可以看做从$q$起始，先接收一个**去掉了字符串的最后一个字符的**`短一点的`字符串($w)$的输入，转移到某个中间态($\delta^{'}(q,w)$)，然后从这个中间态接收$q$作为输入转移到最后的状态$\delta^{'}(q,wa)$。
  - 利用这个递推关系可以将输入的字符串一步步的缩短长度，逐步分解为从状态$q$起始，接收多个连续的单个字符作为输入，进行状态的多步转移。

  - 栗子：
    - 状态$q$接收字符串$abcdef$作为输入，可以看做状态$q$先接收字符串$abcde$作为输入转移一次，然后再接收字符$f$作为输入转移一次。
    - 状态$q$接收字符串$abcde$作为输入，可以看做状态$q$先接收字符串$abcd$作为输入转移一次，然后再接收字符$e$作为输入转移一次。
    - 状态$q$接收字符串$abcd$作为输入，可以看做状态$q$先接收字符串$abc$作为输入转移一次，然后再接收字符$d$作为输入转移一次。
    - 状态$q$接收字符串$abc$​作为输入,可以看做状态$q$先接收字符串$ab$作为输入转移一次，然后再接收字符$c$作为输入转移一次。
    - 状态$q$接收字符串$ab$​作为输入,可以看做状态$q$先接收字符串$a$作为输入转移一次，然后再接收字符$b$作为输入转移一次。
    - 从下往上，则变成了状态$q$依次接收单个的字符$a、b、c、d、e、f$作为输入，进行多次状态转移。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204151645932.png" alt="image-20220415164518579" style="zoom: 33%;" />

#### DFA接收的语言

- DFA接收的字符串：如果一个字符串作为输入，能够使得自动机到达终态，这个字符串就是能被DFA接收的字符串。否则就不是能被DFA接收的字符串。
- DFA接收的语言：能被DFA接收的字符串的集合，记作$L(M) = \{w| \delta^{'}(q_0,w)\in F\}$。
  - $q_0$是起始态，$F$是终态集。

### 格局

- 一自动机在某一时刻的工作状态，可以用两个信息表明：
  - 当前状态$q$，待输入字符串$w$。
  - 两者构成一个瞬时描述，称为格局，记作$(q,w)$。
  - 初始格局:$(q_0,w)$，$w$为任意字符串。
  - 终止格局：$(q,\epsilon),q \in F$。
  - **格局是无限的因为待输入字符串的种类可以是无限的**
  - 那个奇奇怪怪的符号表示格局由左边转移到右边。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204151753826.png" alt="image-20220415175313325" style="zoom:67%;" />

### 设计有限自动机

- 没什么好方法。以机器的角度思考。



## 第2节 不确定的有限自动机(NFA)

- 对DFA的模型进行修改，使得在某一个当前状态下，给定一个输入，能够有多个转移的可能，即为NFA。

### NFA的形式定义

- 还是那五元组$M = (Q, T, \delta,q_0, F)$，状态集，输入集，转移函数，起始状态，终态。
  - 除了转移函数变为针对同一个当前状态以及同一个输入时，会有多个转移，其余和DFA相同。
- 对自动机接受的字符串也有了新的定义：
  - 如果接收一个字符串后NFA进入一个状态集，此状态集中包含一个及以上的终态，则称NFA接收该字符串。
  - 这是因为对于上述输入的那个字符串，它可能会转移向那个含有终态的集合的其他非终态，但是它又确实是可以转移到终态的。
- 状态转移图和状态转移表表示的NFA：**值得注意的是转移表中每一项都是一个集合**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204151916425.png" alt="image-20220415191610018" style="zoom:33%;" />

- 格局示例：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204151948584.png" alt="image-20220415194849202" style="zoom:33%;" />

### NFA的状态转移函数

- 首先引入一个观点：
  - 我们知道，对于一个含有$n$个元素的集合来说，它的子集有$2^n$个。
  - 其次我们知道，NFA接收一个输入跳转进入的任意一个状态集，都会是NFA的状态集的一个子集。
  - 因此我们知道，NFA可能的状态子集总共就有$2^{|Q|}$个。
- 同样不允许无输入的时候发生状态变化（输入空串就是无输入），$\delta(p,\varepsilon) = p$。
- 对于接收字符串$wa$作为输入的时候，$\delta^{'}(q,wa) = \{p|r \in \delta^{'}(q,w),p \in \delta(r,a)\}$。也就是说，$q$接收字符串$wa$作为输入时，看做$q$先接收字符串$w$跳转到某个中间状态集，然后从这个**中间状态集的每个状态**下再接收$a$，所跳转到的所有可能的状态集的并集，是$q$接收字符串$wa$作为输入时的后继状态集。
- 对下图的$\delta^{'}(p,010)$的说明：
  - 首先是$p$接受0，跳转到$q$，然后$q$接受1有两种可能的状态$\{q,r\}$作为一个状态集
  - 然后从这个状态集中的每个状态分别再接收第三个0，$q$接收0跳转到状态集$\{q\}$，$r$接收0跳转到状态集$\emptyset$
  - 最后$\delta^{'}(p,010)$的结果就是第二步的两个状态集的并集$\{q\}$。
  - 其他的以此类推。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204152120483.png" alt="image-20220415212042115" style="zoom:33%;" />

### NFA接受的语言

- 只要某个字符串能够使NFA从初态，以这个字符串作为输入，最后能跳转进入某个含有终态的集合，这个字符串就是NFA能识别的语言。
- 记NFA为$A = (Q,T,\delta,q_0,F)$

- 形式化的描述为$L(A) = \{w|\delta^{'}(q_0,w) \cap F \neq \emptyset \}$，翻译成人话就是$q_0$接收字符串$w$，到达的状态集与终态集有共同元素。

## 第3节 NFA与DFA的等价性

- DFA是NFA的特例，DFA和NFA是等价的，具体的证明过程就不看了。
- 由于DFA和NFA的等价性，我们可以知道：
  - NFA可以接收DFA能接收的语言，也即，设一个NFA可以接受语言L，则必然存在一个DFA能够接收语言L。



### 从NFA构造等价的DFA：子集构造法

- 设$L$是某个NFA$M_N = (Q,T,\delta,q_0,F)$的语言，则存在DFA，能够接收语言$L$。
  - 定义：$M_D = (Q_D,T,\delta_d, [q0], F_D)$，其中$Q_D = 2^Q$。人话：构造DFA，输入集和NFA一样，状态集是由NFA的状态集的子集作为元素的集合。
    - 再说清楚一点，$Q_D$中的元素的形式为$[q_1,q_2,...q_n]$，其中任意一个小写的$q$都是NFA的状态之一。
    - 对$[q_1,q_2,...q_n] \in Q_D,a \in T,\delta_d([q_1,q_2,...q_n],a) = \delta(\{q_1,q_2,..q_n\},a)$
  - $F_D \subseteq Q_D$，$F_D$的每个状态包含$F$中的一个状态。

- 把上面的步骤翻译成人话就是：
  1. 把初始的NFA列表，这样方便看。
  2. 把DFA的表列好，填上NFA的状态集的所有子集作为DFA的初态，填上DFA的输入。
  3. 根据NFA的表，计算DFA的表的所有初态的可达性，有些状态集可能是不可达的。
  4. 把不可达的状态剔除掉。
  5. 翻译成一句话就是，对DFA的某个状态作为初态，把这个初态集合里面的每个状态$q_i$，找出它接收某个输入$a$时，在NFA到达的状态集$Q_i$，然后把得到的这些状态集$Q_i$求并集。
- 对下面这个子集构造：
  - 第一步最左列，填上NFA状态集的子集，作为初态，$[p]$是起始态，用箭头标注一下。
  - 第二步按行填接收不同输入的后继状态转移。
  - 拿$[p,q]$举例，$p$接收1到达$\emptyset$，$q$接收1到达$[q,r]$，合并一下就可以。
  - 最后一步，对不可达的状态集进行筛选。比如$[p,q,r]$就是不可达的，没有哪个初态集接收某一个输入能到达这个状态，$[r]$同理。
  - **对起始态不用去筛选，因为是人为指定从它起始的，即使它看上去是不可达的。**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204161327573.png" alt="image-20220416132750125" style="zoom:33%;" />

- 当然，如果完全采用子集构造法，由于如果NFA有$Q$个状态，则DFA需要筛选的状态集就有$2^Q$个，对比较大的$Q$，筛起来就很麻烦。
- 所以对子集构造法进行一些改进。

- 下面那个的填表过程大概是：

  1. 从$p$开始，$p$接收0跳转到$[p]$,$p$接收1跳转到$[p,q]$，说明$[p,q]$可达。
  2. $[p,q]$作为初态填第二行，$p$接收0到$p$,$q$接收0到达$r$，则$[p,q]$接收0到达$[p,r]$，同理得到接收1的时候到达$[p,q,r]$。
  3. 说明$[p,q,r]、[p,r]$可达，分别作为初态，求出他们的后继状态，发现没有再出现新的可达状态集，求解完毕。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204161355360.png" alt="image-20220416135509898" style="zoom:33%;" />

- 中心思想就是，把NFA的状态集看做是构造的DFA的一个状态，然后对每个状态分别求后继态，直到不再出现新的DFA状态为止。



### 子集构造法得到的状态数

- 实践中，通过子集构造法得到的DFA的状态数目和原NFA的状态数目大体相当。
- 较坏的情况下，DFA的状态数目可能接近NFA状态集的所有子集数。



### 练习

- 解题步骤：
  1. 从起始状态$[q_0]$出发。
  2. $q_0$接受1跳转到$[q_0,q_2]$，$q_0$接受0跳转到$[q_0,q_1]$。
  3. $[q_0,q_1]$接受1跳转到$[q_0,q_2]$。（$q_0$接受1跳转到$q_0$或$q_2$，$q_1$则无法接收1作为输入，求并集即可）
  4. 以此类推。
  5. 最好的方法还是画表。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204161411616.png" alt="image-20220416141109229" style="zoom:33%;" />

## 第4节 有ε转换的NFA

### 定义

- 概念：当输入空串$ε$时（也就是无输入时），也能引起状态转移。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204161417760.png" alt="image-20220416141746387" style="zoom: 33%;" />





### ε-闭包(closure)概念

- 状态$q$的$ε-$闭包，记作$ε-CLOSURE$或$ECLOSURE$，定义为从状态$q$经过所有的$ε$路径可以到达的状态，包括$q$本身。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204161425875.png" alt="image-20220416142518486" style="zoom:33%;" />

- 状态子集$I$的闭包：等于集合中所有状态的ε-闭包的并集。
  - $ε-CLOSURE(\{q_1,q_2\}) = ε-CLOSURE(q_1) \cup ε-CLOSURE(q_2)$。
- $Ia$概念：
  - 对于状态子集$I \subseteq Q$，任意$a \in T$，定义$Ia$如下：
  - $Ia = ε-CLOSURE(P),P = \delta(I,a)$。
  - 人话就是：$a$是输入，先求状态集$I$中的状态接收$a$能够到达的状态的集合，然后求这个集合的状态子集闭包。

- 解析：
  - 先求状态子集接收1为输入后转移到的状态的集合
  - $q_0$接收1转移到$\emptyset$，$q_1$接收1转移到$q_1$。转移后状态集合$\{q_1\}$
  - $q_q$的空闭包$\{q_1,q_2\}$即为$I_1$。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204161439572.png" alt="image-20220416143946131" style="zoom:33%;" />





### 扩展转移函数适合于输入字符串

- 仍旧是老样子，接收单个字符的状态转移函数记作$\delta$，而接收字符串作为输入的状态转移函数记作$\delta^{'}$
- $ε1$应该看做是一个字符串(空串拼接1)，不能看做是单个字符，使用状态转移函数的时候使用的应该是$\delta^{'}$
- 定义$\delta:Q \cross T \cup \{ε\} \rightarrow 2^Q$
- 扩充定义$\delta^{'}:Q \cross T^* \rightarrow 2^Q$
- 对任何$q \in Q$定义：
  - $\delta^{'}(q,ε) =ε-CLOSURE(q)$。很简单，因为$q$接收$ε$，一个空串可以看做左边还有任意多个空串，所以接收一个空串可以到达闭包中的每一个状态。
  - $\delta^{'}(q,wa) = ε-CLOUSURE(P),P = \{p| r \in \delta^{'}(q,w) \and p \in \delta(r,a) \}$。
    - 也就是$q$先接收$w$，到达中间状态集$R$，再从$R$的每一个状态出发接收单个字符$a$到达实际的后继状态集，再对这个状态集求闭包。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211945512.png" alt="image-20220621194521998" style="zoom:67%;" />

- 一个栗子：

  - 说明：
    1. $q_0$接收前面没有空串的$a$，到达后继状态$q_1$停下。
    2. $q_0$接收$εα$，先到达$q_2$，$q_2$接收$a$到达$q_3$停下。
    3. $q_0$接收字符$aε$，先到达$q_1$，$q_1$再接收$ε$，到达$q_2$停下。
    4. 所以第一行先求$q_0$的空闭包，因为字符$a$**作为字符串输入**($\delta^{'})$的时候，前面可能会有任意多个空串，需要先让$q_0$接收掉这任意多个空串，到达闭包中的状态（$\delta^{'}(q_0,ε)$的意义在此)，然后再从闭包中的状态，接收$a$作为字符输入($\delta$)到达某些状态（$\delta(\delta^{'}(q_0,ε),a)$的意义在此）。
    5. 这里之后之所以还要再对结果求闭包，是因为作为字符串输入的时候，$a$的后面可能也会有任意多个字符串，这个时候还要处理掉这后面的任意多个字符串。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191305657.png" alt="image-20220419130520052" style="zoom:33%;" />



### ε-ΝFA的语言

- 还是一样的，只要能够使这个`ε-NFA`到达含有终态的集合就可以。
- 形式化的定义如下：
  - 设ε-NFA $M = (Q, T, \delta, q_0, F)$。
  - 定义M的语言$L_M = \{ w|\delta^{'}(q_0, w) \cap F \neq \emptyset \}$







### 有ε转换的NFA和无ε转换的NFA的等价

- 无空转换的NFA是有空转换的NFA的特殊情况。
- 定理：如果L可以被一个有空转移的NFA接收，那么L可以被一个不具有空转移的NFA接收。
- 证明思路就是直接构造出那个无空转换的NFA。

- 设带空转换的NFA$M = (Q,T,\delta, q_0,F)$，可构造一个不带空转换的NFA$M_1 = (Q,T,\delta_1,q_0,F_1)$，对任何$a\in T,\delta_q(q_0,a) = \delta^{'}(q_0,a)$。

- $$
  F_1 = 
  \begin{cases}
  F \cup {q_0} \text{  如果}ε-CLOSURE(q_0) \cap F \neq \emptyset\\
  F \text{ 否则}
  \end{cases}
  $$

- 上面的公式块翻译成人话就是，如果带空转换的NFA的$q_0$空闭包中含有一个终态，则不带空转换的NFA的终态集中要包含$q_0$，否则二者终态集相等。**注意这里只是对初态，不包括其他状态。**

  - 因为如果$q_0$的空闭包中含有终态的话，意味着我们可以通过给ε-ΝFA只提供任意多个空串，就可以到达终态，也就是什么都不提供就可以到达终态，而什么都不提供，在NFA中是不会进行状态转移的，也就是说$q_0$本身在不带空的NFA中不做状态转移就到达了终态。

- 证明省去，至此我们可以将带空转换的NFA转换成不带空转换的NFA，再转化成DFA。

- $ε-NFA \Leftarrow\Rightarrow NFA\Leftarrow \Rightarrow DFA$。

- 栗子：

  - 计算空闭包的目的是快速找出哪些状态之间可能会有新的连线。
  - 这里在NFA中，$q_0$之所以可以接受1和2为输入直接到达$q_2$，是因为
    - $\delta (q_0,1) = \delta^{'}(q_0,0εε) = q_2$
    - $\delta(q_0,2) = \delta^{'}(q_0,εε2) = q_2$

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191458953.png" alt="image-20220419145804399" style="zoom:33%;" />

## 第5节 正则集和正则式

- 正则集：字母表上一些特殊形式的字符串的集合，是正则式所表示的字符串的集合。
- 正则式：用类似代数表达式的方法表示正则语言。
- 运算：作用于语言上的三种代数运算：
  - 联合（Union）
  - 拼接（concatenation）
  - （星）闭包（Closure）

### 正则表达式（regular expression）

- 正则表达式的归纳定义如下：
  - 基础：空串（ε)、空集$\emptyset$、单个的输入字符$a \in T$都是正则式（原子正则式），相应的正则集为$\{ε\}，\emptyset ，\{a\}$
  - 归纳：如果$A$和$B$是正则式，且分别代表正则集$L(A) 、L(B)$，则$A + B,AB,A^*$也是正则式。
    - 分别代表以下正则集：$L(A) \cup L(B)$，A和B的串的并集，$L(A)L(B)$，A和B的串的拼接，$L(A)^*$，A的串的星号闭包。
  - 从基础开始，利用归纳的规则，有限次的运算下，能够得到字母表$T$上的正则式，这些正则式所表示的字符串的集合是$T$上的正则集。

### 正则表达式算符优先级

- 算符优先级：$*(Closure) > \cdot(concatenation) > + (Union) $
- 闭包大于拼接大于联合

### 语言的联合运算

- 两个语言$L$和$M$的联合：$L \cup M = \{w|w \in L \or w \in M\}$，也就是$L \cup M$。
- 两个语言的联合就是两个语言的并集

### 语言的连接运算

- 两个语言的$L$和$M$的连接：$L \cdot M = \{ w_1w_2| w_1 \in L \and w_2 \in M\}$
- 有时简记为$LM$。
- 就是两个语言的集合的笛卡尔积，$LM$就是$L$中的每一个句子和$M$中的每一个句子进行拼接得到的字符串的集合。

### 语言的闭包运算

- **和字母表的幂运算的定义是类似的**

- $L^* = \{w^n|w \in L \and n \geq 0\}$
- $L ^* = L^0\cup L^1\cup L^2 \cup .....\cup L^n,L^{i} = L^{i - 1} * L$

- $L = \{0,11\},L^2 = \{00,011,110,1111\}, L^2 \neq \{00,1111\}$
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191626805.png" alt="image-20220419162644205" style="zoom:33%;" />

- 一些注释：
  - $T^*$表示的是字母表的星号闭包，代表的是所有可能的字符串，因此正则集肯定是它的子集。
  - $L^+$表示的是$L^1 \cup L^2 ...\cup L^n$，**如果$L$本身不含空串的话**，$L$的加号闭包也不可能包含空串的。
  - 第三点很显然了。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191630640.png" alt="image-20220419163022121" style="zoom:33%;" />





### 正则式的性质

- 交换律和结合律：
  - $(\alpha + \beta) + \gamma = \alpha + (\beta+ \gamma)$
  - $(\alpha\beta)\gamma = \alpha (\beta \gamma)$
  - $\alpha + \beta = \beta + \alpha$
- 等幂律
  - $\alpha + \alpha = \alpha$
- 分配律
  - 注意分配的时候算子不是可交换的。
  - $\alpha (\beta + \gamma) = \alpha \beta + \alpha \gamma$
  - $(\beta + \gamma) \alpha = \beta \alpha + \gamma \alpha$
- 幺元和零元：
  - $\alpha + \varphi = \varphi + \alpha$
  - $\alpha  \varphi = \varphi  \alpha$
  - $αε = εα$

- 与闭包相关的定律：
  - $(\alpha ^*)^* = \alpha ^*$
  - $\alpha^* = \alpha + \alpha^*$
  - $\emptyset^* = \{ε\}$
  - $L^+ = L^*  L = L L^*$
  - $L^* = L^+ \cup \{ε\}$

### 右线性文法与正则式

- 右线性文法与正则式可以用来代表同一正则语言。
- **从右线性文法导出正则式：**这里的加号表示的是语言的联合的意思。
  - 设$x = \alpha x + \beta$，则$x = \alpha^*\beta$
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191746175.png" alt="image-20220419174624624" style="zoom: 33%;" />

- 一个栗子：
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191747615.png" alt="image-20220419174727937" style="zoom:33%;" />





## 第6节 正则集和右线性文法

- 正则集是由右线性文法产生的语言，由右线性文法产生的语言都是正则集。
  - 也就是说正则集和右线性文法产生的语言是等价的。
- 正则集又是由正则表达式所表示的字符串的集合，因此正则式和右线性文法是等价的。
- 证明略去
- 关于由正则表达式导出其等效的右线性文法：没有什么特别好的方法，可能需要一些逆向思维。
  - 此前知道由右线性文法导出正则表达式的方法，也就是$x = x\alpha + \beta,x = \alpha^* \beta$
  - 所以需要一些逆向思维，把给定的正则表达式写成$\alpha^* + \beta$的形式，然后再去构造右线性文法。

- 把给定的正则表达式写成$\alpha^* + \beta$的形式，则就可以知道有一个生成式可以写成$A = \alpha A + \beta$，即$A\rightarrow\alpha A,A\rightarrow \beta$。递归地将正则表达式分解成一个个的右线性文法生成式即可

## 第7节 正则表达式与有限自动机的关系

- 结论：有限自动机、右（左）线性文法、正则表达式都定义了同一种语言，把它称作正则语言。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191839677.png" alt="image-20220419183934266" style="zoom:33%;" />

### 从DFA构造等价的正则表达式（状态消去法）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191847577.png" alt="image-20220419184734969" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191849989.png" alt="image-20220419184920504" style="zoom:33%;" />

- 一个实例：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191852413.png" alt="image-20220419185213896" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191914134.png" alt="image-20220419191440520" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191920009.png" alt="image-20220419192051554" style="zoom:33%;" />

### 从正则表达式构造等价的ε-ΝFA

- 定理：$L$是正则表达式$R$表示的语言，则存在一个$ε-ΝFA$E，满足$L(E) = L(R) = L$
- 其实就是上一个小节的逆过程，上一个小节的最后一个例子可以很好地作为反推的栗子。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191932384.png" alt="image-20220419193217843" style="zoom:33%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191932865.png" alt="image-20220419193257420" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204191940665.png" alt="image-20220419194032165" style="zoom:33%;" />







## 第8节 右线性文法与有限自动机

- 总之，右线性文法$\Leftarrow \Rightarrow$正则表达式$\Leftarrow \Rightarrow$有限自动机



### 右线性文法 $\Rightarrow$有限自动机

- 定理：由任意一个右线性文法G定义的语言必然能被一个NFA M所接受。即$L(G) = L(M)$

- 构造的方法：

  - 设右线性文法$G = (N,T,P,S)$与文法$G$等价的自动机NFA $M = (Q,T, \delta, q_0, F)$。

  - NFA的状态集$Q = N \cup \{H\},H$为一个新增加的状态，且$H \notin N $。

  - NFA的初态$q_0 = S$。即NFA的初态是右线性文法的起始符$S$。

  - $$
    F = 
    \begin{cases}
    \{H,S\}\text{ 当}S \rightarrow ε\text{属于P。}\\
    \{H\} \text{否则}
    \end{cases}
    $$

  -  NFA的状态转移函数$\delta$定义为:对$A,B \in N,a \in T$

    - 当 $A \rightarrow aB \in P$，则$B \in \delta(A,a)$，也就是将非终结符$B$看做非终结符$A$接收终结符$a$得到的后继状态。
    - 当$A \rightarrow a \in P$，则$H \in \delta(A,a)$。也就是到达终态$H$。
    - 对于任意输入，$\delta(H,a) = \emptyset$。

- 例题1：

  - 可以知道新增的状态$H$，就写作$H$即可，是作为一个终态存在的，表示的是右线性文法推导得到了一个终结符串。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204192117205.png" alt="image-20220419211747551" style="zoom:33%;" />

- 例题2
  - 可以知道，当右线性文法右侧的非终结符的左侧出现不止一个终结符时，引入新的非终结符，将右侧改写成**一个终结符拼接一个非终结符**的形式。
  - 这里引入的C就是上述作用。
  - 新引入的非终结符也会变成NFA中一个我们引入的状态。比如这里引入的C。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204192121162.png" alt="image-20220419212154625" style="zoom:33%;" />



### 有限自动机$\Rightarrow$右线性文法

- 定理：设有限自动机$M$接收的语言为$L(M)$，则存在右线性文法$G$，它产生的语言$L(G) = L(M)$

- 证明的思路也是直接构造出这个右线性文法来。
- 和上一小节的右线性文法$\Rightarrow$NFA的思路是逆向的。
- 例题：
  - 值得注意的是当涉及终态的状态转移时，得到的生成式有一个或。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204192131469.png" alt="image-20220419213115800" style="zoom:33%;" />





## 第9节 右线性语言的性质

### 主要内容

- DFA的极小化
- 蚌埠引理
- 右线性语言的封闭性

### DFA的极小化

- DFA的极小化的定义：对DFA $M$的极小化，指的是找出一个DFA $M_1$，使得$M_1$的状态数小于$M$而$L(M) = L(M_1)$。
  - 也就是对DFA的多余状态进行精简，而不改变其接收的语言。
- 等价和可区分的概念：
  - 设DFA $M = (Q,T,\delta, q_0, F)$ ，对不同的状态$q_1,q_2 \in Q$和每个$w \in T^*$。
  - 如果有$(q_1,w) ├^*(q,ε)$和$(q_2,w) ├ ^* (q,ε)$且$q \in F$，则称$q_1$与$q_2$状态等价。记为$q_1 = q_2$。
  - 否则称$q_1$和$q_2$可区分。
  - **也就是说，如果两个状态作为前驱状态，接收同样的输入字符串，最后到达了同一个终态，就称它们相等**。
- 不可达状态：如果不存在任何$w \in T$，使得$(q_0,w) ├ ^* (q,ε)$则称状态$q \in Q$为不可达状态。
  - 也就是说如果从初态不管输入任何字符串都没有办法到达某个状态，这个状态就是不可达的。
- 最小化：若DFA $M$不存在互为等价状态及不可达状态，则称DFA $M$是最小化的。
  - 也就是说DFA的极小化过程就是去掉重复的状态，去掉不可达的状态。

#### 最小化算法

##### 状态集划分法

- 一个DFA $M$的最小化，就是把$M$的状态集$Q$变成一个划分，使得处于一个子集内的状态是等价的，而任意两个子集之间是可区分的。然后每一个子集用其中的一个元素来代表，并取一个状态名。
- 构成划分的步骤：
  1. 构成基本的划分，$\{F、Q - F\}$，也即终态集和非终态集两部分。因为终态和非终态肯定是可以区分的。
  2. 在终态集中进行细分，在非终态集内也对内部进行细分。
  3. 对同一个状态子集进行划分时，若这个状态集中的状态接收同样的输入可到达的状态分属不同的子集，则将这个子集再细分。
  4. 重复直到不可再细分。
  5. 删除不可达状态。
  6. <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204201157693.png" alt="image-20220420115718103" style="zoom:33%;" />

- 栗子：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204201157347.png" alt="image-20220420115702753" style="zoom:33%;" />

##### 填表法

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204201200432.png" alt="image-20220420120033737" style="zoom:33%;" />



### 通过合并等价的状态进行DFA的优化

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204201344256.png" style="zoom:33%;" />
- 栗子
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204201346302.png" alt="image-20220420134634549" style="zoom:33%;" />

### 针对正则语言的Pumping引理

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204241902236.png" alt="image-20220424190216620" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204241903770.png" alt="image-20220424190312004" style="zoom:50%;" />





## 第10节 双向和有输出的有限自动机

#### 双向有限自动机(2DFA)

- 定义：读入一个字符后，读头既可以左移一格，也可以右移一格，或者不移动的有限自动机，为双向有限自动机。
- **确定的**双向有限自动机：每读入一个字符，必须向左或者向右移动，不考虑不移动的情况。

##### 2DFA的形式定义

- 2DFA $M = (Q,T,\delta,q_0,F)$，$\delta$是从$Q\cross T\rightarrow Q\cross\{L,R\} $的映射。
  - 即$\delta(q,a) = (p,R)$或$\delta(q,a) = (p,L)$。以状态$q$读入字符$a$，进入状态$p$，读头向左或向右移动一格。
  - 用格局描述：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205012305286.png" alt="image-20220501230551623" style="zoom:33%;" />

##### 2DFA接收的字符串

- 2DFA接受的字符串集合是：$L(M) = \{w|q_0w ├^*wq,q \in F\}$。
- 翻译成人话就是，从初始状态接受字符串$w$，然后最终能转移到终态$q$，就是自动机能接收的字符串。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205012325268.png" alt="image-20220501232314672" style="zoom:33%;" />





### 有输出的有限自动机

- 定义：在有字符输入时，不仅存在状态转换，同时引起字符输出。
- 两类：
  - 米兰机：输出字符与输入字符以及状态有关。
  - 摩尔记：输出字符仅与状态有关。

#### 米兰机

- 米兰机的形式定义：$M = (Q,T,R,\delta,g,q_0)$
  - 注意米兰机是没有终态集的。
  - $Q$和$T$的意义不变。
  - $R$是有限输出字母表
  - $g:Q\cross T \rightarrow R$       输出函数

- 米兰机的图形表示，例题：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205020012164.png" alt="image-20220502001246499" style="zoom: 33%;" />

#### 摩尔机

- 形式定义：$M = (Q,T,R,\delta,g,q_0)$
  - $g:Q\rightarrow R$
  - $\delta:Q\cross T \rightarrow Q$
- 图形表示,例题：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205020024895.png" alt="image-20220502002425425" style="zoom:33%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205020027710.png" alt="image-20220502002700091" style="zoom:33%;" />

#### 米兰机和摩尔机的变换

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205020100701.png" alt="image-20220502010001048" style="zoom:33%;" />

# 第4章 上下文无关语法与下推自动机

- 推导树和文法的二义性
- 上下文无关文法的变换
  - Chomsky范式
  - Greibach范式
- 下推自动机
- 上下文无关语言的性质
- 上下文无关文法：$A \rightarrow \alpha,A \in N，\alpha \in (N \cup T)^*$。左侧是非终结符，右侧是终结符和非终结符的拼接。
  - 2型文法，上下文无关文法，$CFG,Context \ Free \ Gramma$。
  - 用途：定义程序设计语言、进行语法分析、简化语言翻译
- 2型文法对应的识别器——下推自动机。
  - $PDA(Push Down Automata)$：由输入带、有限控制器和下推栈构成。

## 4.1 推导树和二义性

### 归约与推导的概念

- 归约和推导都是推理一个给定字符串是否属于文法所定义的语言的方法。
- `推导过程`：将文法的产生式的左部($head$)替换为产生式的右部($body$)

#### 归约

- 自下而上的方法，称作递归推理，递归推理的过程习惯称为归约。
- 归约的过程：将产生式的右部替换为产生式的左部。
- 就是从给定字符串开始，利用文法的产生式去倒推，一步一步地将给定字符串中的终结符和非终结符串替换成生成式的左侧，直到从这个给定的字符串推导到了起始符$S$。
- 形象一点的说法就是“逆向工程”，数学上与之类似的就是分析法（欲证$\rightarrow$即证），从结论去倒推，直到倒退到给定的条件，则原命题得证。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061517409.png" alt="image-20220506151721736" style="zoom: 33%;" />

#### 推导

- 自上而下的方法，称作推导。
- 推导的过程：将产生式的左部替换为产生式的右部。
- 就是从起始符开始，利用文法的产生式一步步正推，直到找到一条能够推导出给定字符串的推导路径。
- 正向工程，类似数学上的一般从条件到结论的证明。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061521995.png" alt="image-20220506152133314" style="zoom: 33%;" />

#### 最左推导与最右推导

- 直接看图吧
- 最左推导：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061601711.png" alt="image-20220506160111981" style="zoom:33%;" />

- 最右推导：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061602020.png" alt="image-20220506160208341" style="zoom:33%;" />

### 推导树

- 用图的方法表示一个句型的推导，这种图称为推导图，也称语法树或语法分析树。
- 推导树的定义方法：
  - 以文法的起始符为根，树的枝节点标记是非终结符，树的叶子结点标记为终结符或$ε$。
  - 若枝节点$A$有直接子孙$x_1,x_2,x_3,...x_k$，则文法中有生成式$A \rightarrow x_1x_2x_3...x_k$。
- 推导树举例：
  - 树的每个节点都只含有一个字符，可能是终结符也可能是非终结符，但是只能是一个。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061608373.png" alt="image-20220506160824804" style="zoom:33%;" />

#### 边缘

- **叶子结点**从左向右组成的字符串称为推导树的边缘。
  - **每个叶子结点距离根节点的深度不一定要是一样的哈**
- 边缘举例：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061611079.png" alt="image-20220506161115388" style="zoom:33%;" />

#### 归约过程与推导树的关系

- 归约过程可以看做是从边缘（底部）开始逐渐向上（根，顶部）建造起了一棵推导树。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061615828.png" alt="image-20220506161507138" style="zoom:33%;" />

#### 推导过程与推导树的关系

- 推导过程就是自顶向下建立了，从根起步建立边缘。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061616124.png" alt="image-20220506161613437" style="zoom:33%;" />

### 归约、推导与分析树之间的关系

- 三者之间是等效的关系，因为都是描述的同一个东西。
- 对于同一个给定字符串，三者描述的都是它的生成过程，只不过分析树属于更直观的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061625790.png" alt="image-20220506162556178" style="zoom:33%;" />

- 定理：证明不看
  - 以及子树的概念。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061747090.png" alt="image-20220506174724351" style="zoom: 33%;" />

### 二义性

- 定义：
  - 文法$G$上的一个句子能够有多种得到它的最左（或最右）推导路径，就说明这个文法是二义的。
  - **同时存在一个最左推导和最右推导是不行的，按照这两个推导画出的推导树是一样的**
  - 对于消除文法的二义性，无一般的算法。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061755519.png" alt="image-20220506175519789" style="zoom: 33%;" />

## 4.2 上下文无关文法的变换

### 消除无用符号

- 有用符号一定**既是生成符号，又是可达符号**
- 只满足是生成符号，或只满足是可达符号，或两个都不满足，都不属于有用符号

#### 先找出生成符号（找出有用的非终结符，因为终结符肯定是生成符号）

- 递归的基础情况：所有的终结符都是生成符号
- 如果一个生成式的右侧全都是生成符号（右侧是生成符号的字符串），则这个生成式的左侧也是生成符号
- 找到哪些是生成符号之后，对于剩余那些不是生成符号的非终结符，要删除它们的生成式。



#### 后找出可达符号（终结符中可能存在不可达的符号）

- 递归的基础情况：文法的起始符S一定是可达符号。
- 如果一个生成式的左侧的单个非终结符是可达符号，那么这个生成式的右侧的每一个符号都是可达符号
- 必须按照这个步骤来，否则可能不会完全删除无用符号。

### 消除空产生式

- 可致空符号：如果一个非终结符A能够经过一系列推导得到空串，则A是可致空符号。
- 无空文法的定义：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206201719652.png" alt="image-20220620171908036" style="zoom:50%;" />

- 计算可致空符号的集合：
  - 递归的基础情况：如果$A \rightarrow ε$，则非终结符$A$是可致空符号，也就是说能够直接替换成空符号的非终结符是可致空符号。
  - 如果一个生成式的右侧全是可致空符号，则这个生成式左侧的那个单个非终结符也是可致空符号，将其加入可致空符号的集合。
- 找出可致空符号的非终结符的集合后，遍历每一个生成式，对于生成式右侧含有可致空符号的生成式，生成新的无空文法：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206201730433.png" alt="image-20220620173004870" style="zoom:50%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206201745265.png" alt="image-20220620174517652" style="zoom:50%;" />

- 例子

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206201748584.png" alt="image-20220620174839019" style="zoom:67%;" />

### 消除单生成式

- A和B都是非终结符，形如$A\rightarrow B$的生成式就是单生成式
- 单元偶对：非终结符Ａ能够借助一系列单产生式推到非终结符B，A和B就是单元偶对
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206201751520.png" alt="image-20220620175104968" style="zoom:50%;" />
- 消单产生式：
  - 对每个非终结符A，找到所有的单元偶对的集合。
  - ![image-20220620183148616](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206201831112.png)


### 简化CFG的顺序

1. 消除空产生式
2. 消除单产生式
3. 找出生成符号
4. 找出可达符号

### 消除递归

- 递归的定义：左递归、右递归、循环文法、递归文法
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261027384.png" alt="image-20220526102718791" style="zoom:50%;" />

#### 生成式的代换

- 2型文法中所有形如$A \rightarrow \alpha$的生成式称作$A$生成式

- 可对这种生成式进行变换：
  - **注意图里说了B生成式，意味着B的右侧$r_i$全是终结符**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261044901.png" alt="image-20220526104446370" style="zoom:50%;" />

- 这种直接代换的例子：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261049621.png" alt="image-20220526104911055" style="zoom:50%;" />

#### 消除直接左递归

- 把左递归生成式同样写右侧的前边，其他非左递归的生成式写后边
- 引入新的非终结符$A^{'}$，重写$A$的生成式：
  - 原来非递归的生成式照抄到重写的右侧前边，后边写的看图。
  - $A^{'}$怎么写看图

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261052415.png" alt="image-20220526105215833" style="zoom:50%;" />

- 例题：
  - 注意这里+号也是终结符的一部分。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261055344.png" alt="image-20220526105510738" style="zoom:50%;" />

## 4.3 Chomsky范式和Greibach范式

- 考试只要求CNF啦

### Chomsky范式

- $CNF(Chomsky \ Normal \ Form)$定义：
  - 需要注意的是，生成式右侧如果是两个符号，**全是非终结符，不能一个终结符一个非终结符拼接**
  -  如果是一个终结符和非终结符的拼接（$A \rightarrow aB$），引入新的非终结符C，将其变为$A\rightarrow CB,C \rightarrow a$
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261108758.png" alt="image-20220526110821172" style="zoom:50%;" />
  
- CNF的构成步骤：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261109137.png" alt="image-20220526110914574" style="zoom:50%;" />
- 例题：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261110068.png" alt="image-20220526111050431" style="zoom:50%;" />

### Greibach范式

- $GNF$的定义：
  - 就是要把所有的生成式的右侧都变成以**恰好一个终结符开头的，其余全是非终结符的串**。
  - 并且不包含空生成式
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261113777.png" alt="image-20220526111332099" style="zoom:50%;" />

- GNF的构成步骤：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205261120814.png" alt="image-20220526112034052" style="zoom:50%;" />

## 4.4 下推自动机(PDA,$Push \ Down \ Automaton$)

### PDA的结构

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202057506.png" alt="image-20220620205746941" style="zoom: 67%;" />

### PDA的形式定义

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202053744.png" alt="image-20220620205309271" style="zoom: 67%;" />

- 除了状态集、输入集、终态集、PDA的初始状态，多了可以入栈的字母的集合、下推栈的起始符号

- 转换函数由当前状态、当前输入、当前栈顶的符号来共同确定。

### PDA的转换函数

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202059453.png" alt="image-20220620205939013" style="zoom: 67%;" />

- 比较重要的是一些约定：
  - 注意空转换（输入为空串）的时候，读头是不移动的
  - 转换到下一个状态，栈顶符号是ε，表示之前栈顶的符号被弹出（并不是表示栈空了）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202100453.png" alt="image-20220620210022000" style="zoom:67%;" />

### PDA的格局

- 格局的要素：当前状态、待输入的串、当前栈顶符号，待输入串为空表明输入字符已读完，栈顶符号位空表明栈空。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202106491.png" alt="image-20220620210649008" style="zoom:67%;" />

### 下推自动机接受的语言

- 两种下推自动机接受的语言
- 终态接受，终止格局的当前状态为终态集中某个状态，待输入字符串为空串，栈顶符号无要求。
- 空栈接受，终止格局的当前状态为状态集中某个状态，待输入字符串为空串，栈顶符号为 ε。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202109393.png" alt="image-20220620210942915" style="zoom: 67%;" />

### PDA例

- 转移函数一个个解读：
  - 初始状态，接受a为输入，栈顶为初始符号，转移到q1状态，a入栈，栈顶符号变为$az_0(表示a入栈了)$
  - q1状态，接受a为输入，栈顶符号为a（栈的里面还有很多个a），转移到q1状态，栈顶符号变为$aa(表示多入栈一个a进去)$。
  - q1状态，接受b为输入，栈顶符号为a，转移到q2状态，栈顶符号变为ε（表示弹出一个a）。
  - q2状态，接受ε为输入，栈顶符号为初始符号，转移到终态q0,栈顶弹空。表示语言被接受。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202119943.png" alt="image-20220620211954454" style="zoom:67%;" />

### PDA的图形表示

- 以同一道例题为例
- 两个状态之间的有向弧上依次为：输入，当前栈顶符号情况/下一个状态的栈顶符号情况
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202128863.png" alt="image-20220620212814383" style="zoom:67%;" />

### 确定的下推自动机DPDA

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202232175.png" alt="image-20220620223205670" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202250678.png" alt="image-20220620225034213" style="zoom:67%;" />

### 非确定的下推自动机NPDA

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202250415.png" alt="image-20220620225056943" style="zoom:67%;" />

- 下题思路：
  - 不管是a和b个数相等还是a和c个数相等，都先将a全部入栈。
  - 在a入栈完毕后通过一个空转换（其实任何时刻都可以进行这个空转换，只不过只有a入栈完毕后进行空转换的情况能够到达终态），往两个分支中的某一个去猜想，空转换的过程中栈不变动。
  - 如果到达a和b相等的分支，则每读取一个b弹出一个a，直到读取到c之后，进入q2状态，将c全部读取完毕，栈空且输入为空，到达终态。
  - ac分支类似
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206202254864.png" alt="image-20220620225441368" style="zoom:67%;" />

### 空栈接受与终态接受的等价

- 一个能被PDA终态接受的语言，必然能够构造出一个PDA，这个PDA以空栈的方式接受同一个语言，反之亦然。
- 说人话就是，对于一个语言L，你既可以构造出一个终态接受的PDA，也可以构造出一个空栈接受的PDA识别它。

## 4.5 上下文无关文法与下推自动机

- 下推自动机转换为上下文无关文法考试不要求，狗都不复习。
- 复习一下上下文无关无法转换为下推自动机

- 上下文无关文法和下推自动机二者是等价的

### 上下文无关文法转换为自动机

自动机的形式化描述：(状态集，输入集，栈的字母表，转换函数，初状态，栈顶起始符号，终态集)

- 自动机的状态集只有一个状态q，也是起始状态。
- 构造的是空栈接受的PDA，所以终态集可以直接为空。
- 自动机的输入字符集就是文法的终结符集合
- 自动机的栈可以放入的字符集是文法的终结符和非终结符的集合。
- 栈的初始栈顶符号就是文法的起始符S。
- 转移函数定义为：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206210006560.png" alt="image-20220621000627089" style="zoom:67%;" />

- 因此构造一个CFG的PDA的流程归纳如下：
  1. PDA的状态集只有一个状态q，这个状态也是起始状态
  2. PDA的终态集为空，因为是构造栈空接收的PDA
  3. PDA的输入集为CFG文法的终结符
  4. PDA的栈的字母表是CFG文法的终结符和非终结符的并集
  5. 转换函数按照上面的定义抄即可。
     - q状态下，栈顶为非终结符，则接受空输入（读头不移动，因为读头读取的是终结符），转移到q状态，栈顶使用此前的非终结符的生成式右侧替换（可能有多个）
     - q状态下，栈顶为终结符，则接受此终结符本身作为输入，转移到q状态，并将栈顶的终结符本身弹出。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206210033462.png" alt="image-20220621003327004" style="zoom:67%;" />

- 用PDA模拟文法的某个句子的推导过程的思路：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211053337.png" alt="image-20220621105313684" style="zoom:67%;" />
- 一个例子：
  - 在栈顶是非终结符的时候，读头不右移，进行的是空转换来将栈顶替换为非终结符的生成式的右侧。
  - 栈顶是终结符的时候，读头右移，同时终结符出栈，出栈的终结符恰好和读头读取到的那个输入是一样的，于是就模拟了推导过程。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211055858.png" alt="image-20220621105501389" style="zoom:80%;" />

### 自动机转化为CGF考试不做要求，笑死

## 4.6 上下文无关文法的性质及蚌埠引理

### 蚌埠引理

- 引理本体：设上下文无关文法G，存在常数P，如果$w \in L$，且$|w| \geq  P$，则$w$可以写成$w_1w_2w_0w_3w_4$的形式，使得$|w_2w_3| > 0,|w_2w_0w_3| \leq P$，对于$i \geq 0$有$w_1w_2^iw_0w_3^iw_4 \in G$（不含G = {ε}的情况）。
- 人话就是，一个CFG文法中的某个句子，把它分成五段，第2和4段在原处重复相同的任意次数得到的串还属于这个CFG文法。
- 用途：证明某个文法不是上下文无关文法，使用反证法，看是否满足在$w \geq P $的情况下，$|w_2w_0w_3| \leq P $且$w_1w_2^iw_0w_3^iw_4 \in G$。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211307365.png" alt="image-20220621130700782" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211307430.png" alt="image-20220621130721904" style="zoom:67%;" />

### 二型语言的封闭性

- 注意二型语言对交运算不封闭即可，对并、拼接和闭包封闭

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211309868.png" alt="image-20220621130904385" style="zoom:67%;" />

### 二义性问题

- 文法可以是二义性的，而语言可以是固有二义性的。
- 如果所有描述语言L的文法G都是二义性文法，则语言L是固有二义性的，也叫先天二义性的。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211314475.png" alt="image-20220621131407923" style="zoom:67%;" />

## 4.7 受限型上下文无关文法

### 线性文法

- 生成式的右边只有一个非终结符，右边的其余字符都是终结符（$A \rightarrow w_1Cw_2,C \in N$），或者生成式右边全是终结符。

### 顺序文法

- 将非终结符排好序，每个生成式的右侧所含的非终结符的序号都大于左侧的那个非终结符的序号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211428485.png" alt="image-20220621142856924" style="zoom:67%;" />

# 第5章 图灵机

## 5.1 基本图灵机

### 图灵机的基本模型

- 一条输入带，输入带向右无限延伸，带有一个最左单元
- 有一个读写头，读写头在每一时刻扫描带上的一个单元
- 带最初时最左边的n个单元上有n个输入符，余下的所有单元都存放空白符，空白符不是输入符号。

- 图灵机根据读写头所扫描到的符号和有限控制器的状态做出动作。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211500009.png" alt="image-20220621150042429" style="zoom:67%;" />

### 图灵机的形式化描述

![image-20220621150442815](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211504454.png)

### 图灵机的函数与格局

- （当前状态，当前扫描到的带符）===》（转移到的状态，读头将扫描到的带符改写为什么符号，读头左移还是右移）
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211514552.png" alt="image-20220621151406473" style="zoom:67%;" />
- 图灵机的格局的几个约定：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211515021.png" alt="image-20220621151525370" style="zoom:67%;" />

- 图灵机的格局：
  - 第一个推导关系，意思是当前状态为q，当前读头读取到的字符是$X_i$，图灵机转移到状态p，并且先将$X_i$改为Y，然后读头向左移一格。
  - 第二个推导关系，意思是当前状态为q，当前读头读取到的字符是$X_i$，图灵机转移到状态p，并且先将$X_i$改为Y，然后读头向右移一格。
    - 两个例外：第一个是当读头读到n个输入字符的最后一个时，并且将它改为Y，此时读头右侧的空白符B。
    - 第二个例外：当读头读到第1个输入字符时，并且将它改为空白符B，此时读头右侧是空白符B（先将字符改为B然后右移一格）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211515254.png" alt="image-20220621151550379" style="zoom:67%;" />

### 图灵机接收的语言

- 如果一个语言作为输入放在图灵机的输入带上，能够使得图灵机进入终态，这个语言就是能被图灵机接受的语言。

  <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211530422.png" alt="image-20220621153056903" style="zoom:67%;" />

### 图灵机举例

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211551852.png" alt="image-20220621154831226" style="zoom:67%;" />

<img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220621154930919.png" alt="image-20220621154930919" style="zoom:50%;" />

- 等价的另外一种状态转移图
  - ![image-20220621155311300](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211553903.png)

### 图灵机作为整数计算机

- 使用零的个数来表示一个数，如果有多个数，每个数之间使用一个1隔开。
- 图灵机停机后，纸带上剩下的零的个数就是计算的结果

![image-20220621155418885](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211554517.png)

- 使用图灵机计算真减法：
  - ![image-20220621155840225](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211558720.png)
  - ![image-20220621155913328](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206211559829.png)
