# 第一章 计算机系统概述

## 1.1 计算机的发展

- 关注下硬件的发展

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282024090.png" alt="image-20220428202438903" style="zoom: 50%;" />



## 1.2.1 计算机硬件的基本组成

- 存储程序的概念：
  - 主存储器：指的是内存，不是硬盘。是那个16G的，不是那个512G的
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282026638.png" alt="image-20220428202642549" style="zoom:50%;" />

- **在计算机系统中，软件和硬件是等效的。**

  - 同一个功能，既可以用软件实现，也可以用硬件实现。
  - 软件实现成本低，人效高，效率低。
  - 硬件实现则效率高，人效低。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282035393.png" alt="image-20220428203529303" style="zoom: 80%;" />

- 传统的冯诺依曼式计算机的特点：
  - 指令和数据都是以二进制的形式表示的。
  - 指令和数据以同等的地位存于存储器，可按地址寻访。
  - 计算机由五大部件构成。
  - 指令由操作码和地址码构成。
    - 操作码指定进行什么操作。
    - 地址码指定数据存放的地方。
  - 存储程序。
  - 以运算器为中心。I/O设备与存储器之间的数据传输通过运算器完成。
- **现代计算机**：
  - 以存储器为中心。
  - CPU = 运算器 + 控制器
  - 控制器负责解析指令，并指挥运算器完成相关的运算。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282044818.png" alt="image-20220428204404692" style="zoom:50%;" />

## 1.2.2 认识各个硬件部件

### 主存储器的基本成（内存）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282109435.png" alt="image-20220428210916330" style="zoom:50%;" />

- 内存：
  - 用于存放数据的东西叫存储体。
    - 存储体由编好码的（也即是地址）存储单元组成，每个存储单元可以存放一串二进制数据（比如一字节）。
    - 储存字：存储单元中的二进制代码。
    - 存储字长：一个存储单元存放的二进制串的位数（一般是8比特）。
      - 注意区分字和字节，不是同一个概念。
    - 存储元：用来存储一个比特的电子元件。
  - 地址寄存器（MAR）：存储内存地址，这个地址可以是从这里数据的，也可以是从这里读数据的
    - **可能会被集成到CPU中**
    - 要从内存的哪个地方取数据
    - 或者将数据写入内存的哪个地方
    - **地址寄存器的位数也反映了内存的大小，也就是存储体中存储单元的个数。**
      - 比如地址寄存器是16位的，那么就有$2^{16}$个存储单元。
  - 数据寄存器（MDR）：存储数据，这个数据可以是从内存里取出来的，也可以是要写入内存的。
    - **可能会被集成到CPU中**
    - **存的东西，可能是计算要用的数据，也可能是要执行的一条指令。**
    - 从内存里取出数据，然后放置在数据寄存器中。
    - 把数据先放置在数据寄存器中，然后把存在这里的数据写入内存。
    - **数据寄存器的位数应该和存储单元的存储字长是一致的，比如一个存储单元存八位，那么数据寄存器也是八位**。

### 运算器的基本组成

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282111092.png" alt="image-20220428211134944" style="zoom: 50%;" />

### 控制器的基本组成

- 当初计导大作业的那些寄存器终于知道都在哪里了。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282113541.png" alt="image-20220428211321407" style="zoom: 50%;" />

## 1.2.3 计算机系统的层次结构

### 微指令

- 机器只能识别二进制的机器指令，比如乘法指令，加法指令。
- 但是由硬件(CPU)直接执行的是粒度更细的微指令，一条机器指令还要更进一步地细分为多条微指令。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011332759.png" alt="image-20220501133251607" style="zoom: 50%;" />

### 汇编语言

- 直接使用机器语言编写程序过于不方便，所以又出现了汇编语言。
  - 汇编语言也不是机器能够直接识别的指令，要经过汇编器将汇编程序翻译成机器指令才可以。

### 高级语言

- 出于同样的理由出现了更高级的编程语言。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011336292.png" alt="image-20220501133641097" style="zoom: 45%;" />



## 1.3 计算机的性能指标

- CPU主频：CPU内数字脉冲信号振荡的频率。
  - 主频和CPU的时钟周期是倒数关系。
- CPI(Clock cycle per Instruction)：执行一条指令所需的时钟周期数。
  - 微观下来考虑意义不大，能够影响一条指令的CPI的因素太多。
  - 不同的指令CPI不同，同一条指令的CPI也可能发生变化。
  - 一条指令的执行时间等于其CPI与CPU时钟周期的乘积。
- 指令条数 * 平均CPI / CPU主频 = 执行完所有指令所需的总时间，也叫CPU时间。
- IPS(Instruction Per Second)：每秒执行多少条指令。
  - IPS = 主频 / CPI = 一秒相当于的时钟周期数 / 一条指令需要的时钟周期数
  - KIPS、MIPS
- FLOPS(Floating-point Operations Per Second)：每秒执行多少次浮点运算
  - KFLOPS、MFLOPS

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011411126.png" alt="image-20220501141123050" style="zoom:50%;" />

- 数据通路带宽、吞吐量、响应时间：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011420871.png" alt="image-20220501142028725" style="zoom: 60%;" />
- ![image-20220501142615080](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011426154.png)



# 第二章 数据的表示和运算

## 2.1.1 各种进制及其之间的转换

- 其他进制转十进制：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021148801.png" alt="image-20220502114818705" style="zoom: 50%;" />
- 十进制转其他进制：
  - 分为整数部分和小数部分分别求取。
  - 整数部分使用短除法。其本质如下图：
    - 余数$K_0$就是用$r$进制表示的情况下的最低位
    - 然后接着用商去除以进制基数$r$，得到次低位，以此类推，直到商为0。
    - ![image-20220502115320326](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021153433.png)
  - 小数部分使用乘以进制基数，取积的整数部分的方法。本质和上面的类似，见下图：
    - 小数部分乘以进制基数，得到的积留下整数部分，再拿积剩余的小数部分去继续乘以进制基数。
    - 得到的积的整数部分是小数部分的更高位。
    - 有时候这个过程可以一直循环下去，因为可能是无限小数。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021202804.png" alt="image-20220502120234704" style="zoom: 50%;" />
    - ![image-20220502115728353](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021157447.png)
- 二进制和八进制、二进制和十六进制之间的相互转换：
  - 八进制和十六进制之间的转换则通过二进制做媒介。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021149083.png" alt="image-20220502114944951" style="zoom:50%;" />

### 真值和机器数

![image-20220502120412640](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021204707.png)

## 2.1.2 BCD码



- BCD：	Binary-Coded Decimal，使用二进制编码的十进制
- 计算机处理8421BCD码的方法：8421码是有权码，每一位编码的权值是固定的。
  - 先将两个数对应的编码直接按照二进制加法相加，得到的结果分两种情况：
    - 如果这两个数相加的值在0到9的区间内，那么BCD码相加得到的结果就是正确的结果。
    - 如果这两个数相加的值不在0到9的区间内，那么给编码相加得到的结果加上一个6的BCD码（0110），得到的就是和的正确编码。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021217333.png" alt="image-20220502121759209" style="zoom:50%;" />

- 关于余三码和2421码：
  - **余三码是无权码，而2121码则是对每一位的权值做了重新定义**。
  - **2421码对大于等于5的数的编码方式做了人为规定，最左边第一位一定是1**
    - 因为对于2121码来说，5有两种表示5 = 2 + 2 + 1 = 4 + 1
    - 采用5 = 4 + 1 编码，得到的是5的编码是0101，和BCD码是一样的。
    - 所以为了避免歧义，就规定了大于等于5的数的编码最左边第一位一定是1。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021220424.png" alt="image-20220502122046284" style="zoom:50%;" />

## 2.1.3 字符与字符串

- 英文的表示：ASCII码

### 汉字的表示与编码

- 区位码看做一个94*94的二维矩阵，两个区位码相当于坐标轴的两个坐标，可以定位到一个汉字。
- 给区位码（0到93）的每个字节加上32，使得编码从32开始，避开ASCII的通信和控制字符，得到国标码。
- 给国标码（32到125）的每个字节加上128，避开ASCII码的其他字符，得到汉字机内码。
  - **机内码**就是内存中存放汉字时使用的实际编码。
  - 由于ASCII码只用了一个字节中的低7位，所以，这个首位(最高位)上的“1”就可以作为识别汉字编码的标志，计算机在处理到首位是“1”的编码时就把它理解为汉字，在处理到首位是“0”的编码时就把它理解为ASCII字符。
- 输出码可以理解为对汉字的图像的像素编码。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021405204.png" alt="image-20220502140520993" style="zoom:50%;" />

### 字符串

- 按地址递增的顺序看，先遇到最高有效字节就是大端模式，先遇到最低有效字节就是小端模式。
- 注意汉字使用的是机内码来保存。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021420954.png" alt="image-20220502142014773" style="zoom:50%;" />



## 2.1.4 奇偶检验码

### 计算机硬件如何实现奇偶校验

- 计算校验位：
  - 偶校验：对给定的比特串进行连续异或，得到最终的结果就是校验位。
    - 对收到的编码进行检错：对收到的比特串进行连续异或，结果不为零就说明一定发生了错误。
    - 结果为0也不能百分之百确定没有发生错误。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021448275.png" alt="image-20220502144838132" style="zoom:50%;" />
  - 奇校验的硬件实现：
    - 校验位的计算：对偶校验校验位的计算结果取个非。
    - 对收到的编码进行检错：也是对偶校验情况下的计算结果取非，结果不为1就说明一定出错。
    - 同样只能百分百否定，但不能百分百肯定。

## 2.1.5 汉明码

## 2.1.6 循环冗余校验码

## 2.2.1 定点数的表示

- 定点数：小数点的位置固定不变，比如$114.514$
- 浮点数：小数点的位置不固定，比如使用科学计数法，随着阶码的变化小数点位置也变，$1.14514 \cross 10^2、11.4514 \cross 10^1$

### 无符号数的定点表示

- 没什么好说的，注意一下无符号都是整数就行了

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021501529.png" alt="image-20220502150138362" style="zoom:50%;" />

### 有符号数的定点表示

- **这里既有整数，也有小数，并且我们规定小数的小数点的位置是固定的。**
- 定点整数的小数点在最低位的后面隐含，定点小数的小数点在最高位的左边隐含。
  - 如果一个小数既有整数部分也有小数部分，就分开保存整数部分和小数部分
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021541594.png" alt="image-20220502154138483" style="zoom:50%;" />

#### 原码

- 用原码表示定点数的时候，真值为0会同时有正零和负零的两种编码。
  - 符号位为1，尾数全0，负0
  - 符号位为0，尾数为0，正0
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021548279.png" alt="image-20220502154835169" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021544477.png" alt="image-20220502154451287" style="zoom:50%;" />



#### 反码

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021551090.png" alt="image-20220502155151909" style="zoom:50%;" />

#### 补码

- 由原码求补码：
  - 正数的原码和补码是一样的
  - 负数：
    - 先求原码。
    - 对原码的尾数位（绝对值部分）全部取反，得到反码，**符号位保持不变**。
    - 将反码加一（考虑进位），得到补码。
- 由补码求原码：
  - 正数的补码和原码是一样的。
  - 负数：先对补码的尾数全部取反，然后再加1，得到原码。
- 由$[x]_补$快速求$[-x]_补$:
  - **符号位和尾数**都全部取反，然后再末位加一。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021601939.png" alt="image-20220502160146732" style="zoom:50%;" />

#### 移码

- 在补码的基础上将符号位取反，**只能用于表示整数**
- **补码的0也不存在正0负0的情况**
- 移码很方便硬件判断两个数的相对大小。
  - 将移码比特串看做一个无符号数的话，两个移码的相对大小和其对应真值的相对大小是一样的。
  - 随着真值的递增，移码所对应的无符号数值也是逐渐增大的
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021607119.png" alt="image-20220502160725972" style="zoom:50%;" />

## 2.1.2 原码补码反码的作用

- 补码：让减法操作天然的变成了加法操作。
  - 减去一个数就是加上它的补码。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022001881.png" alt="image-20220502200055657" style="zoom:50%;" />

## 2.2.3 移位运算

### 算术移位

##### 原码定点整数

- 不管是左移还是右移，移的次数太多都会丢失精度。

- 右移：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022103884.png" alt="image-20220502210306713" style="zoom:50%;" />
- 左移：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022104012.png" alt="image-20220502210458863" style="zoom:50%;" />

##### 原码定点小数

- 左移和右移都和原码定点整数是一样的

##### 反码的算术移位

- 正数的反码和原码是一样的，所以正数的反码移位和原码移位的相同
- 负数：可以从借助原码来理解，负数的反码对应的原码在移位之后要补的是0，补了零之后的结果的反码，补的零要取反变成一。
  - 所以负数的反码在移位时，需要补的是1，且该丢弃的丢弃，丢弃的部分和原码没什么区别。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022111871.png" alt="image-20220502211133749" style="zoom:50%;" />

##### 补码的算术移位

- 正数的补码和原码是一样的，所以正数的补码移位和原码相同
- 负数的看图：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022120180.png" alt="image-20220502212015033" style="zoom:50%;" />

### 逻辑移位

- 逻辑移位，**连带符号位一起，**不管左移右移都直接补0，要舍弃的位直接舍弃

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022122408.png" alt="image-20220502212256272" style="zoom:50%;" />

### 循环移位

- 就是原本移位的时候要舍弃的那一位，给它放到移位的时候空出来的位置上去
- 带进位位的循环移位就是把循环位也当做是数位的一位。
- 可以用于大端法和小端法的转换

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022136610.png" alt="image-20220502213644455" style="zoom:50%;" />



## 2.2.4 加减运算和溢出判断

### 原码的加减法

- 计算机内不会直接使用原码来做加减法。逻辑很复杂
  - 所以通常都是使用补码

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022216374.png" alt="image-20220502221615241" style="zoom:50%;" />

### 补码的加减法

- **加法就直接拿两个补码去加，符号位也参与运算**,加就是普通的二进制加法。
- 减法就转变成加上被减数的相反数就可以。
- 还要考虑溢出问题。最后两个例子都溢出了。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022226599.png" alt="image-20220502222627410" style="zoom:50%;" />

### 溢出判断（补码）

- **只有两个相同符号的数相加时，才可能会发生溢出。**
  - 上溢：正数 + 正数 = 负数，这种情况下是两个正数之和过大，往上比上限还大，所以叫上溢。
  - 下溢：负数 + 负数 = 正数，这种情况下是两个负数之和过小，往下比下限还小，所以叫下溢。
  - **正数 + 负数是不会溢出的**。
    - 因为和数肯定小于原来的正数而大于原来的负数，原来的两个加数都没有溢出，和数夹在二者之间自然也就不会是溢出的。
  - **发生上溢，则来自最高数值位的进位一定是1，因为只有这样，才能使两个加数的0符号位加上进位1，得到和数的符号位变为1**
  - **发生下溢，则来自最高数值位的进位一定是0，因为只有这样，才能使两个加数的1符号位加上进位0，得到和数的符号位变为0**
  - 方法二和方法三实际上就是基于上述两点。
- 因为最终减法也会转化成加法，所以我们只需要判断加法的溢出即可。
- 计算机硬件如何判断溢出：
- 方法一：采用一位符号位，$A_S$和$B_S$是两个加数的符号位，$S_S$是运算结果的符号位。
  - 判断溢出的布尔代数表达式为$V = A_SB_S\bar{S_S} + \bar{A_S} \bar{B_S} S_S$
    - $A$的符号位为$1$，$A_S$取值为$1$，其他几个也是相同规则。
    - 这个逻辑表达式用与或非门很方便使用硬件实现。

  - $V = 0$则无溢出，$V = 1$则有溢出。
  - $V = 1$解析一下就是两种情况：
    - $A_SB_S\bar{S_S}= 1$，也就是$A_S = 1\and B_S = 1 \and S_S = 0$，就是两个加数为正数，而得到的结果为负数，发生了上溢。
    - $\bar{A_S} \bar{B_S} S_S = 1$，也就是$A_S = 0 \and B_S = 0 \and S_S = 1$，就算两个加数为负数，而得到的结果为正数，发生了下溢。
    - 而溢出无非就是这两种情况之一。

- 方法二：采用一位符号位，根据数据位进位情况判断溢出
  - 上溢：符号位进位为0而最高数值位进位为1。
    - 最高数值位的进位指的是数值位向符号位进的那一位。
    - 符号位进位指的是那个进位位寄存器的值，也就是符号位向更高位产生的进位。

  - 下溢：符号位进位为1而最高数值位进位为0。
  - 也就是符号位的进位和最高数值位的进位不同，就发生了溢出，采用一个异或门实现即可。
  - 因为溢出就两种情况，正+正 = 负，或者负 + 负 = 正。
    - 第一种情况下，两个加数符号位都为0，在最高数值位进位为1的情况下，两个符号位加上来自最高数值位的进位，会使得最终结果的符号位为1，也就是最终结果变成了负数，发生上溢。而这种情况下，符号位的进位为0。
    - 第二种情况下，两个加数符号位都为1，在最高数值位进位为0的情况下，两个符号位加上来自最高数值位的进位，会使得最终结果的符号位为0，也就是最终结果变成了正数，发生下溢。而这种情况下，符号位的进位为1。
    - 最终结果指的是两个数相加得到的和。

- 方法三：采用双符号位：
  - $S_1$和$S_2$，$S_1$是和数预期的符号，$S_2$是和数实际得到的符号。
  - 还是因为溢出就两种情况，正+正 = 负，或者负 + 负 = 正。
    - 第一种情况下，两个加数符号位为00，如果发生溢出那么来自最高数值位的进位会为1，使得从左往右第二个符号位变为1。
      - 而从左往右第一个符号位在发生上溢的情况下，肯定是0的。这个0就记录了预期的正确符号。
      - 第二个符号位就记录了实际得到的符号。
      - 所以双符号位其实是可以拿来纠错的？

    - 第二种情况类似，就不细写了。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031503988.png" alt="image-20220503150357781" style="zoom:50%;" />


### 符号扩展

- **注意，定点整数的扩展是在原有的符号位和最高数值位的中间添加新位**。

- 正整数：符号位为零，直接在原有的八位的后面填零
- 对于**整数**，**补码的情况下，扩展都是直接用符号位在开头扩展即可**。
- 对于定点小数：
  - **由于要保证扩展后的各个位的位权不变，所以应该在右侧末尾补位**，而不是符号位和数值位之间补位。
  - 负定点小数的补码符号扩展可以记不住的话可以直接使用原码加反码进行推导。
  - **负定点小数的补码进行扩展时在右侧末尾添零**。
  - 正定点小数的补码进行扩展时在右侧末尾添零。

![image-20220503150630921](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031506130.png)

## 2.2.5 乘法运算

### 原码的乘法

- 这里是原码的乘法：**符号位是不参与运算的**

  - 对于原码的乘法我们符号位单独处理，然后使用两个因子的绝对值再去做乘法，得到的值再添加上符号。
  - 这样就可以将所有的乘法都转化成两个正数的乘法
  - 将两个因子的符号位进行异或，即可得到乘积的符号，因为异或是相同得零，相异得一，恰好对应了乘法的同号得正异号得负。

- 关于一位乘法：

  - 可能还是视频里讲的清楚。如果描述不清楚就还是看原视频吧。
  - 首先有一个寄存器叫ACC，累加器，这个寄存器在开始计算之前会被清零，用来存储乘积的高位或运算结果。
  - 然后有一个有一个普通的通用寄存器叫X，这个寄存器用于存放被乘数，就是手算的时候写在上面的那个。
  - 然后还有一个寄存器叫MQ，这个寄存器用于存放乘数，还有乘积的低位。
  - 一位乘法的过程如下：**请注意，X、MQ存的都是两个乘数的绝对值，ACC的结果也就是乘积的绝对值**
    1. 首先将ACC清零。然后对MQ中的乘数的最低位（记作ｑ）进行与Ｘ的一位乘法。
    2. 引入规则：如果q的值为1，那么就让ACC加上X，如果q的值为0，那么ACC就加上一个0。
    3. 在进行完一轮加法后，ＭＱ右移一位，将已经进行过乘法的老ｑ舍弃，同时原先新的ｑ挪到最右侧最低位。
    4. 同时ACC也右移一位，此前MQ右移在其左侧腾出的空位，用于存放从ACC右移出来的数，ACC的空位则补0。
    5. 然后进行下一轮的一位乘法和加法，直到MQ中乘数的符号位到达了MQ的最低位。
    6. 然后对两个乘数的符号位进行异或，得到乘积的符号位，并添加到符号位（ACC最左边）上去。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031556117.png" alt="image-20220503155656937" style="zoom:50%;" />

- 一个手算的例子：

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031556976.png" alt="image-20220503155609763" style="zoom:50%;" />

### 补码的乘法

- 也是一位乘法，**但是符号位是参与运算的**
- 整个的运算过程是和原码的一位运算差不多相同的，只不过引入的规则和原码引入的不一样。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031624291.png" alt="image-20220503162432093" style="zoom:50%;" />

- 关于辅助位：是给ＭＱ寄存器多加了一位，出于寄存器长度一致性的考虑，会给X寄存器和ACC寄存器也多加一位，多加的一位补符号位。
  - 因此X保存的数其实采用的是双符号位的补码。
  - 这里多出来的一次加法其实是ＭＱ中保存的补码的符号位参与了运算（原码中符号位是不参与运算的）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031625940.png" alt="image-20220503162557702" style="zoom:50%;" />



## 2.2.6 除法运算

### 原码的除法运算

- 首先有一些前提，就是二进制的除法，商的某一位要么是0，要么是1，（使用竖式手算的时候）商0的时候，余数减去的是0，商1的时候，余数减去的是除数本身。
- 如果是定点小数的除法，由于定点小数是无法表示大于1的数的，所以我们会隐式的要求被除数的绝对值要小于除数的绝对值（否则商的绝对值会大于一）

#### 原码除法：恢复余数法

- 与原码的乘法原理类似。

- 会有一个寄存器ACC，保存被除数和余数(余数其实不就是下一次求商的被除数么)

- 还有一个寄存器MQ，保存的是商，当然，也会通过类似的移位的方法来模拟手算的过程。

- 最后还有一个寄存器X，保存的是除数。

- 计算的过程：**要注意这里也是只保存了被除数和除数的绝对值，计算出来的也是商的绝对值**

  1. 首先将保存商MQ的寄存器清零，然后把MQ的最低位（最右侧）记作位置q。同时将ACC保存被除数，X保存除数。

  2. 在Q位上保存的是当前我们求商的那一位。

  3. 首先计算机默认商1，也就是将Q位填1，然后由ALU去更新ACC的值为得到的余数。

     - 如果ACC的新的值符号位为0，也就是正数，也就是新得到的余数大于零，那么商1是正确的。

     - 如果ACC的新的值符号位为1，也就是负数，也就是新得到的余数小于零，那么商1是错误的，ALU将会将余数恢复到原有的值，并且改商为0。这就是叫恢复余数法的原因。
     - 新得到的余数就是用ACC现存的值减去通用寄存器X的值，也就是ACC~新~= ACC~老~ - X = ACC~老~ + $[-x]_补$（因为X保存的是除数的绝对值哈）
     - 恢复余数就是新得到的错误的余数再加上除数的值即可。
     - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032029734.png" alt="image-20220503202949595" style="zoom:50%;" />

  4. 然后将ACC整个左移一位，低位补零，ＭＱ也左移一位，低位补０，然后回到３，直到求得的商的位数满足了精度要求，停止。

  5. 然后对被除数和除数的符号位进行异或，得到商的符号，把得到的符号位填充到ＭＱ的符号位（MQ的最左边）去。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031955230.png" alt="image-20220503195511996" style="zoom:50%;" />

#### 原码除法：不恢复余数法（加减交替法）

- **符号位仍然是采用单独异或处理的方法，下面计算的仍然是商的绝对值**。

- 在恢复余数法中，当我们发现商1新得到的余数是负值时，我们会做的事情有：
  - 此时ACC的值是新得到的负余数，记作$a$，X保存的是除数，记作$b$。
  - 我们需要做的是恢复余数，并且将商修正为0。
  - 也就是说，恢复余数后，ACC的值是$a + b$，对应的商位是0。
  - 然后进入下一位商的计算，先对ACC进行一次逻辑左移，此时ACC的值是$2a + 2b$
  - 然后计算机默认商1，得到新的余数$2a + b$。然后进入判断余数的符号的那一步。
- 因此不恢复余数法的改进就是，当得到负的余数时，直接将商位修正为1，并让ACC左移一位，然后加上除数的值，置为下一次的余数$2a + b$。
  - 如果$2a + b$是负的呢？直接商零，用ACC左移一位再加上X的值。
  - 如果是正的那就说明商1是对的，和恢复余数法的处理是一样的。
    - 也就是直接计算新的余数，用ACC左移一位再减去X的值。
  - 若最终的余数为负，还是要进行一次恢复余数。

![image-20220503205122385](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032051610.png)

### 补码的除法运算

- 补码的符号位也参与运算，其他的和原码的加减交替法完全一样。
- 还有就是补码的商的最后一位商恒置为1，不去判断商1是否正确，只是为了硬件设计省事。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032101334.png" alt="image-20220503210142115" style="zoom:50%;" />



## 2.2.7 强制类型转换

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032111990.png" alt="image-20220503211131764" style="zoom:50%;" />



## 2.2.8 数据的存储和排列

### 大小端模式

- 大端模式和人类的阅读习惯是保持一致的。
- 小端模式则方便机器处理数据，因为机器处理数据一般也是从低地址往高地址读取数据，所以采用小端法的时候，机器先读入的是低位字节。
  - 比如CPU要做加法时是从低位开始相加，这个时候如果最先读入的是低位的数据就会快些。



### 边界对齐（内存对齐）

- 不管是哪一种寻址方式，最终使用的都是按字节编码的地址。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032120694.png" alt="image-20220503212002503" style="zoom:50%;" />

## 2.3.1 浮点数的表示

- 定点数的问题在于，定点整数和定点小数表示的范围是有限的，但我们又不能无限制的增加数据的长度。
- 而浮点数则可以解决这个问题。浮点数采用的思想类似科学计数法。
- 例如下面的例子，在失去一定精度的情况下，我们可以将表示这个数所需的数据长度大大缩短
  - 由于底数肯定是$10$，所以我们可以直接省略不写这个作为底数的$10$，而是直接用两个数来代替整个科学计数法，一个数代表小数部分，一个数代表指数部分（也就是它的阶）。
  - 阶码部分就是底数的次数，尾数部分就是科学计数法的小数部分，都各自带有符号。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041438579.png" alt="image-20220504143804336" style="zoom:50%;" />

### 浮点数的表示

- 浮点数其实就可以看做是以二进制为基础的科学计数法。
- 阶码部分就是2的次数，也就是科学计数法的那个底数2的阶。阶码的位数反映了浮点数的表示范围和小数点的实际位置。
- 尾数部分就是科学计数法的那个小数部分，尾数的位数越多，精度就越高。
- **阶码和尾数本身都是采用定点的方式保存的**。
- **阶码是定点整数，尾数是定点小数**
- 之所以叫浮点数，是因为对于同一个数，阶码取不同的值，小数点的位置是会浮动的。
  - 可以举一个十进制的例子，$114514$可以写成$11.4514 * 10^4$（阶码取4），也可以写成$1.114514 * 10^5$（阶码取5）。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041443484.png" alt="image-20220504144341284" style="zoom:50%;" />

###  浮点数尾数的规格化

- 解决的是因为尾数的位数不够而导致的损失精度问题。
  - 举个例子：有一个二进制的数，科学计数法记为$2^{10} * 0.00001101$。
  - 假如要用八比特的空间来存储，肯定是存不下的，但是这个数的小数部分是有很多无效位数的。
  - 所以我们让尾数左移5位，同时阶码减少相应的次数，得到$2^5 * 1.101$。精度不变，而尾数的位数减少。
  - 这样八位恰好可以存的下。
  - 这个操作就是浮点数的左规。
  - 右规就类似十进制的科学计数法，$302.15 * 10^1$规格化变为$3.0215*10^3$。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041501636.png" alt="image-20220504150105397" style="zoom:50%;" />

### 规格化浮点数的特点

- 浮点数的尾数可以使用原码表示，也可以使用补码表示。
- 使用原码表示尾数时，要遵循的规则：
  - 正数的尾数必须为$0.1xxxxxxxx$的形式，0是符号位，数值位的最高位必须为1。
  - 负数的尾数必须为$1.1xxxxxxxx$的形式，1是符号位，数值位的最高位必须是1。
  - 也就是说，使用原码表示尾数时，最高数值位一定是1。
  - 很好理解吧，总不可能最高数值位是0（二进制要么1要么0嗷），那不就是一个无效位了。。。
- 使用补码表示尾数时，要遵循的规则：
  - 正数的尾数必须为$0.1xxxxxxx$的形式，0还是符号位，最高数值位与符号位相反。
  - 负数的尾数必须为$1.0xxxxxxx$的形式，1还是符号位，最高数值位与符号位相反。
  - 这样的设计是出于简化硬件设计的考虑。
  - 对于给定的例子的尾数1.1110100，要将其规格化为$1.0xxxxx$的形式，只能把**小数点右移**(也就是数左移)到夹在两个1之间的那个零前面了。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041504632.png" alt="image-20220504150453386" style="zoom:50%;" />

### 关于浮点数的溢出问题

- 浮点数的表示范围也是有限的，只不过比定点数的表示范围要大了很多。
- 浮点数表示的小数也是有一个最低下限的。正数的尾数最小值只有$0.100000...$，负数的尾数的最大值是$1.100000...$
- 浮点数表示正数有一个范围，表示的负数也有一个范围，这两个范围可以看做是没有交集的。
- 所以会有四种溢出：
  - 超过正数的最大值：正上溢，系统给出一个异常。
  - 低于正数的最小值但还是一个正数：正下溢，当做机器零。
  - 高于负数的最大值但还是一个负数：负下溢，当做机器零。
  - 低于负数的最小值：负上溢，抛出异常。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041523363.png" alt="image-20220504152353220" style="zoom:50%;" />





## 2.3.2 IEEE754标准

- 标准化浮点数，本质上是为了解决跨平台的问题，将不同设备制造商对浮点数的解析和存储方式统一，使得不同机器之间可以交换数据。

### 阶码（使用移码表示）

- IEEE754标准中，阶码是用移码的形式来表示的，所以有关移码：
  - 移码：在补码的基础上将符号位取反即可。移码只能表示整数
  - 移码的定义：移码（二进制） = 真值（二进制值） + 偏置值（二进制值）。
  - 偏置值取$2^{n - 1}$，$n$为位数。此时移码恰好就是补码的符号位取反
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041552308.png" alt="image-20220504155243123" style="zoom:50%;" />

- IEEE754标准的偏置值取的是$2^{n-1} - 1$。

### IEEE754

#### 一般情况下的：（阶码不为全0也不为全1）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041604780.png" alt="image-20220504160443513" style="zoom:50%;" />

- 32位浮点数：1 8 23。64位浮点数：1 11 52。
- 在计算阶码的真实值时，将阶码的二进制的移码看做无符号数，然后减去偏移值就可以得到真正的幂的次数。
  - 反过来，计算阶码的移码时，可以用幂的值加上偏移值，得到的数转换成二进制无符号数，就是对应的阶码的移码。
- **尾数部分使用的是原码，隐藏了整数部分的1**。尾数部分的原码缺少符号位是因为把符号位转移到了数符位，而尾数部分去掉了符号位。
- **阶码部分没有去掉符号位。**
- 十进制转浮点数的例子：<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041608737.png" alt="image-20220504160830548" style="zoom:50%;" />
- 浮点数转十进制的例子：<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041613538.png" alt="image-20220504161328360" style="zoom:50%;" />

#### 浮点数的最大值和最小值（除去特殊情况）

- 由于阶码的全1和全0都拿来表示特殊的情况（NaN或者无穷），并且计算幂次的实际值的时候是把阶码看做无符号数的。
- 所以阶码看做无符号数且不能为全1或者全0的情况下，阶码的最大值就是111111110，最小值就是0000000001。
- 最大值：最低位为0其他全为1。最小值：最低位为1其他全为零。



- 以32位的浮点数为例，阶码是8位，则阶码的最大值为11111110（十进制的254），最小值为00000001（十进制的1）
  - 再减去偏移量127，得到幂次的实际最大值127，实际最小值-126。
  - 然后再考虑尾数部分，由于尾数部分是隐含1的，所以最小尾数就是$1.00000000...$，最大是$1.1111111....$
  - 然后再考虑符号，负数肯定小于正数。
  - 因此浮点数的最小值是最大尾数乘以最大幂次再添个负号，最大值就是把符号去掉。
  - 而浮点数的**最小绝对值**则是最小尾数乘以最小幂次
- **浮点数是没办法表示绝对的0的，因为阶码部分肯定是正的，而尾数部分又是1.M，也肯定是正的，只能表示极小极其接近零的数**。
  - 所以要表示比最小绝对值还小的数，就需要用那些特殊用途。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041625357.png" alt="image-20220504162521163" style="zoom:50%;" />

#### 特殊情况

- 要表示那些比规格化的情况下的最小绝对值还小的数，就需要使用特殊的情况。
- 当阶码全为0时，**尾数部分也不视作是1.M的形式，而是视作0.M的形式，其幂次也固定视为-126，不是-127**
  - $1\leq E \leq 254$指的是将阶码看做是无符号数的情况，$E$为阶码。 
  - **当阶码全为0且尾数全为0时，根据符号位可以表示正负0。**
  - ![image-20220504181717148](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041817437.png)





## 2.3.3 浮点数的运算

### 加减运算

- 和十进制的科学计数法来类比一下：
  - 小阶向大阶对齐是出于硬件原因。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041824108.png" alt="image-20220504182416837" style="zoom:50%;" />
- 关于舍入：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041835449.png" alt="image-20220504183517155" style="zoom:50%;" />

### 强制类型转换

- **long转化为double是建立在long只有32位而double是64位的情况下的，如果long和double都是64位，转换会损失精度**。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041838585.png" alt="image-20220504183811423" style="zoom:50%;" />



## 2.4.1 ALU简介、加法器设计

- 介绍算术逻辑单元ALU，加法器的设计

### ALU

- 输入信号A和B是两个操作数，本质上是高低电平。
- 实例中：
  - $A_i、B_i$就是两个四位操作数输入的地方。
  - $M$表示进行哪一大类运算，是进行算术类运算还是逻辑类运算
  - $S_0$到$S_3$表明要进行大类中的哪一个小类运算（比如是算术运算类的加法）。
  - $F_0$到$F_3$是输出信号，输出ALU运算得到的结果。
  - 机器字长实质上就是指的ALU能一次处理多少位的单个数据。
  - 一般来说其他寄存器的位数会和ALU的位数保持一致，为了硬件适配，毕竟你输出一个4位的结果总要放到一个4位的寄存器去的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041849300.png" alt="image-20220504184903067" style="zoom:50%;" />

### 一位全加器

- 一位全加器考虑的是一位上的加法，全的意思是考虑了来自低位的进位的值。
- 三个输入$A_i、B_i、C_{i-1}$，分别为第$i$位的两个加数，以及来自更低一位的进位值。
- 两个输出：
  - $S_i$：第$i$位的和（满2进1的时候本位的和为0）
  - $C_i$：第$i$位向更高位的进位。
  - $S_i = A_i \bigoplus B_i \bigoplus C_i$。本位的和就是两个加数的本位加上来自低位的进位，得到的和再去模二。
  - $C_i = A_iB_i + (A \bigoplus B_i)C_i$。当两个加数的本位都为1时（不管来自低位的进位是什么值），或者两个加数其中一个为1且来自低位的进位为1时，本位向高位进位。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205042050658.png" alt="image-20220504205042391" style="zoom:50%;" />

### 串行加法器

- 如何使用一位全加器来实现n位二进制数的加法。
- 每次输入两个加数的一位，然后加上来自进位触发器的低位的进位($C_i$)，得到向更高位的进位以及本位的和，前者保存在进位触发器中，后者则输入到另外一个寄存器保存，然后再输入更高一位的两个加数的位，如此循环。
- 进位触发器用于保存来自低位的进位，也就是$C_{i - 1}$
- 以下面的为例：
  - 第一轮，输入$A_i = 1、B_i = 0$，由于这是最低位，无进位，计算得到$S_1 = 1$，输出，并将进位$0$保存在进位触发器中。
  - 第二轮，输入$A_i = 1、B_i = 1$，进位触发器输入来自低位的进位$0$，计算得到$S_2 = 0$，输出，并将进位1保存在进位触发器中。
  - 第三轮，输入两个加数的第三低位的两个数，以及来自第二低位的进位，后面不多说。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205042107444.png" alt="image-20220504210733229" style="zoom:50%;" />

### 并行加法器

- 要计算$n$位的两个二进制数的加法，就把$n$个全加器串联在一起，低位的全加器的进位输出作为其相邻高位的全加器的低位进位输入。
  - 最低位的全家器输出$S_1$的同时，其向第二位的进位$C_2$也作为了第二位全加器的“来自低位的进位”的输入
  - 以此类推。
- 这样可以同时将一个加数的$n$位数据同时输入，但是每一级的进位都依赖于其前一级的进位。
  - 也就是说，第2位只有得到了来自第一位的进位输入之后，才能开始计算它本位的进位以及本位和。以此类推。
  - 也就是说，只有$S_i$的结果出来之后（也就是这一位向相邻高位的进位出来后），$S_{i+1}$才能开始计算。
  - 所以这个叫做串行进位的并行加法器。
  - 因此这样的加法器的计算速度取决于进位的产生和传递速度。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205042114255.png" alt="image-20220504211436019" style="zoom:50%;" />



## 2.4.2 加法器优化（留坑）

# 第三章 存储系统

## 3.1-3.2 主存简单模型和寻址概念

### 主存储器的简单模型

- 一个主存储器由三部分构成：
  - 存储体
  - 数据寄存器
  - 地址寄存器
  - **实际设计上俩寄存器可能会和CPU集成在一起**
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071832891.png" alt="image-20220507183239704" style="zoom:50%;" />
- 有关存储体：
  - 存储体是由很多个存储单元一排排构成。
  - 一排的存储单元又是由单个从存储元构成。
  - 存储元能够保存一比特的信息，有一个控制开关来控制对存储元的写入和读取。
  - 存储体的存储容量就是用存储体的行数乘以列数那么多个比特。
- 如下图，红色的线是一条控制线，它控制一整行的存储单元，给一整行的8个存储元同时发出读信号或者写信号
- 绿色的线可以看做是一条直接连接到寄存器的某一位上的电路，负责传输来自一个存储元上的电平信号（也就是0和1）
  - 绿色的线其实是负责传输它左侧的那一列存储元的信号的，但是每次只有那一列上的某一个存储元的信号能够有效。
  - 也就是说，在读取数据的时候，每次只能读取一整行存储单元的数据。
  - 这个由输入进来的控制信息实现，

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205051421659.png" alt="image-20220505142119344" style="zoom:50%;" />

- 一个主存的简单模型：

  - 有关控制信息
    - 有一个译码器将控制信息传入，每次只会有一个输出端口的控制信息是有效。
    - 如下图。

  - 数据寄存器通过绿色的线和存储体相连，绿色的线负责将从存储单元读取到的数据放入数据寄存器，或者将外界写入数据寄存器中的数据写入存储单元。
    - 数据寄存器还有与外界相连的绿色的数据线，负责从外界将数据写入数据寄存器，或者将从存储单元读取并存放在数据寄存器中的数据传递给外界。
    - **数据线的根数和数据寄存器的位数是相等的。**

  - 地址寄存器与译码器通过红色的线相连。
    - 同时还有与外界相连的地址线，地址线将地址写入地址寄存器。
    - **地址线的根数和地址寄存器的位数是相同的**。

  - 片选线类似开关，有高电平有效和低电平有效两种模式。
    - 高电平有效就是高电平时，整个电路工作。

  - 读控制线负责控制读操作和什么时候读。写控制线类似。
    - 由于读和写通常是互斥的（同一时间只能读或者写），所以可以将两条控制线合并为一条，称作读写控制线，决定当前操作是读出去还是写进来，以及什么时候。

  - 将这些东西封装起来，就得到一个存储芯片。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205052100183.png" style="zoom:50%;" />

- 将上面的简单主存模型封装一下，大概是这样的：
  - 地址线和数据线都是暴露在外的存储芯片的接口。
  - 片选线和读写控制线也是暴露在外的接口。
  - 译码驱动起的是增强信号的作用，比如以前控制第一个存储元的那个1，现在要控制第一整行存储单元，就需要对电平进行增强.(大概意思一下)
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061112265.png" alt="image-20220506111202028" style="zoom:50%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205052116338.png" alt="image-20220505211639024" style="zoom:50%;" />

### 寻址

- 下图每一小格是一个字节。假设总容量为1KB(1024字节)
  - 则需要十根地址线。
  - 可以按字节寻址、按字寻址、按半字寻址、按双字寻址。
  - 一个字这里是4字节。
  - 大端方式和小端方式看图。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061102405.png" alt="image-20220506110213019" style="zoom:50%;" />

## 3.3.1 半导体存储器RAM

### 半导体随机存储器

- 关于SRAM:
  - 使用触发器来存储信息，触发器是可以保持两个稳定的状态的，一个作为0，另一个作为1即可。
  - 对SRAM进行读出的时候，只需要查看SRAM的状态就好，不会对状态造成破坏，因此也就不需要回写操作。
  - 由于触发器可以保证两种稳态，所以也不需要对SRAM中的信息进行定期刷新。
  - SRAM通常将行地址和列地址分割为长度不相等的两部分，所以只能同时送行地址和列地址，整个地址放到寄存器里面。
  - 假设行地址加列地址总长度是10位，那么就需要10根地址线。
  - 由于SRAM在读取的时候不需要对信息进行回写操作，也不需要定期对信息进行刷新，所以运行速度快于DRAM。
  - 需要的元件更多所以集成度更低发热量更大成本更高。
  - 成本更高所以常用作高速缓存。
- 关于DRAM：
  - 使用电容的带电量作为两个状态表示0和1，假设电容充满电为1，电容不带电为0。
  - 由于对DRAM的读出是连接电容并检测是否有电流流出，所以假设里面存储的是1，读取之后电容中的电荷就全部流失了（破坏性的读出），所以要进行回写，将电荷充回去，保持存储的信息为1。
  - 由于DRAM的电容中的电荷即使不去读取也会自己快速流失，所以要对整个存储矩阵进行定期刷新。
  - DRAM的行地址和列地址被划分为长度相等的两部分，所以可以分两次送，先送行地址，再送列地址（反过来也可以吧，看情况）。
  - 能分两次送使得地址线能被复用，线的根数减少一半。
  - 假设行地址加列地址总长度是10位，那么只需要5根地址线。
  - 由于需要回写和刷新等操作，运行速度慢于SRAM。
  - 集成度高发热低成本低，所以常用作大容量的主存。
  - 目前主流的主存应该是采用SDRAM。 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061121513.png" alt="image-20220506112117158" style="zoom:50%;" />

### DRAM的刷新

- 刷新周期：由于DRAM的电荷持续周期一般是两毫秒，所以刷新周期也是两毫秒。
- 以行为单位，每次刷新一行存储单元（一行有多个存储元哈，是一行这一整行作为一个存储单元）。
- 由于行地址选通后可以同时选通一行存储单元，所以可以直接对一行进行刷新。
  - 刷新的时候传一个行地址就够了
- 刷新由硬件支持，不需要CPU支持，读出一行的信息之后重新写入，**占用一个读/写周期**。
- 在有容量扩充的情况下，存储器中所有芯片的同一行同时刷新。

- 关于三种刷新方式：
  - **由于在2毫秒内电荷不会完全流失干净，所以在这两毫秒内任意一个存储单元的信息都是可读的，所以只要在两毫秒内刷新一次即可**
  - 假定DRAM是128 * 128的矩阵，读/写周期为0.5微秒。
  - 则在2毫秒内，总共有4000个读写周期。
  - 分散刷新：
    - 将存取周期由0.5微秒扩大一倍，变为1微秒。
    - 实际的读写占一半，另外一半用来刷新需要刷新的某一行，不一定是当前读取的那一行。
  - 集中刷新：在2毫秒的时间内集中安排时间，将128行一次性全部刷新。
    - 128行刷新需要占用128个读写周期。
    - 因此2毫秒内的4000个读写周期内，前3872个读写周期用于读写。
    - 最后的128个周期专门用于刷新。
    - 专门刷新的那段时间内存储器无法被访问，称为访存死区。
  - 异步刷新：结合了前两种刷新。
    - 由于128行在两毫秒内都需要刷新一次，所以我只要保证在这两毫秒内完成128次刷新就可以了。
    - 也就是每隔2ms / 128 = 15.6 微秒，要进行一次刷新。
    - 也就是说，将2毫秒分为128段，每段15.6微秒，每段时间内完成对某一行的刷新操作。
    - 则每个15.6微秒内，有0.5微秒用于刷新的死时间，其他的15.1微秒都可以用来读写。
    - 通过指令的灵活安排，可以将死时间的影响直接消去（在死时间内干别的）。

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061832751.png" alt="image-20220506183214380" style="zoom:50%;" />

#### 为什么要使用行地址和列地址

- 假设使用原先建立的模型，只使用一个译码器，那么在地址的位数$n$比较大时，选通线的条数就非常大了。
  - 比如$n = 10$，那就需要1024条选通线来控制1024行存储单元。
  - 但是如果将DRAM的地址划分为行地址和列地址，并且将存储单元排列成矩阵的形式，将存储阵列划分成$2^{n/2}$行乘以$2^{n/2}$列，那么就可以使用类似坐标轴定位的方式来选通某个存储单元。
  - DRAM的行地址长度和列地址长度是相等的，则行地址译码器和列地址译码器都各自有$n / 2$位地址输入，选通线都是$2^{n/2}$条。
  - 总共需要的选通线的条数就变为$2 * 2^{n / 2} = 2^{n + 2 / 2}$条。如果取$n = 10$，则选通线条数由$1024$变为$128$条，直接缩小十倍。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061814182.png" alt="image-20220506181428874" style="zoom:50%;" />

### SRAM的读周期

- 一个菱形代表地址线传入的一个地址。
- CS是片选线，D~OUT~为数据线，在读的过程中负责输出从主存读取到的数据。
- 读的过程：
  - 首先地址线传入地址，但是并不是立刻开始读，因为通过地址线传输过来的信号可能不是同时到达的。
  - 所以要等一段时间（也就是第1和2根竖线之间的间隔），等地址信号稳定。
  - 然后片选线才开始打开，方便从存储矩阵读取数据。
  - 由于读取数据也需要一段时间，所以打开也会持续一段时间，直到信号稳定下来，然后关闭（第2个间隔）。
  - 开关关闭之后可能数据线上的信号还在传输，所以数据线上的信号会维持一段时间，地址信号也维持一段时间关闭。
  - 将数据从存储矩阵读取之后的那一段时间主要是为了保持数据的正确性，所以需要一段恢复时间。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061901456.png" alt="image-20220506190125125" style="zoom:50%;" />



### SRAM的写周期

- 和读周期是类似的。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061912538.png" alt="image-20220506191253241" style="zoom:50%;" />

## 3.3.2 半导体存储器ROM

- 首先纠正我的一个多年的误解：**只读存储器和固态硬盘之类的不完全是一个东西**
  - ROM其实可以看做是写了BIOS的地方，ROM在开机的时候告诉CPU，操作系统放在磁盘（辅存）的哪个位置，然后电脑就可以开机了。
  - 或者这么说，ROM就是负责在电脑开机的时候，告诉CPU，把辅存里的哪里的哪些内容放进RAM。
  - ROM在最开始出来的时候甚至是不可以写入的，只在出厂的时候被写入一次，所以叫$Read\ Only\ Memory$
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061926125.png" alt="image-20220506192606807" style="zoom:50%;" />

## 3.3.3 存储器基本概念

### 存储器的分类

- 辅存不能直接与CPU交流，主存以及高速缓存与CPU直接交流
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061928067.png" alt="image-20220506192846801" style="zoom:50%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061932338.png" alt="image-20220506193206025" style="zoom: 50%;" />

### 存储器的性能指标

- 关注一下存储速度的计算

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205062118167.png" alt="image-20220506211820871" style="zoom:50%;" />

### 存储器的层次化结构

- 主存与辅存是解决主存容量不够大的问题（以及主存的易失性问题？）
- 高速缓存和主存解决的是CPU和主存之间读写速度差距过大的问题。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205062120723.png" alt="image-20220506212028468" style="zoom:50%;" />



## 3.4.1 主存与CPU的连接

### 主存容量扩展——位扩展

- 增加存储器芯片的位数
  - WE是读写控制线，CS是片选线，$A_0$到$A_{15}$是CPU的地址线。
  - 存储芯片是8K * 1位的，8K说明有13条地址线。
  - 需要对储存容量进行位扩展的时候，就新增一块芯片，地址线都连接在CPU的地址总线上（红色）
  - 绿色的是CPU的输入输出线，和存储芯片的输入输出线一对一相连，看图。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071746746.png" alt="image-20220507174627481" style="zoom:50%;" />

- 如果要扩展更多位，就需要更多芯片
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071751645.png" alt="image-20220507175125415" style="zoom:50%;" />

### 主存容量扩展——字扩展

- 增加存储芯片的字数

#### 线选法

- $A_{13}、A_{14}$分别和两片存储芯片的片选信号相连，需要哪一块的时候就把哪一块的片选信号置为1，另一块置为0
  - 也就是说$A_{13}、A_{14}$两条线不能同时为1或同时为0，四个状态只用了两个。
  - 这种情况下地址空间是不连续的
- 数据线看绿色的，地址线看红色的，这也是决定了为什么需要两条不同的线选线。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071801120.png" alt="image-20220507180105814" style="zoom:50%;" />

#### 译码片选法

- 对上面的稍作一些改进，增加一个非门，就可以减少一根线的消耗。
  - 这本质上就是采用译码器了，如果新增更多的存储芯片使用一个译码器即可。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071807138.png" style="zoom:50%;" />



- 比如一个使用了四个存储芯片的字扩展：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071814137.png" alt="image-20220507181435839" style="zoom:50%;" />

### 主存容量扩展——字位扩展

- 以下图为例，CPU的数据线是八位的，单个的存储芯片是16K * 4位的。
  - 先以两片为单位进行位扩展，得到的一个整体就是16K * 8位的。
  - 然后两片作为一个整体再进行字扩展，此时就需要使用译码器。
  - 译码器输出的信号是并行传输到一个整体的两片芯片上的，比如译码器的一号输出的电路在第二片分了叉的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071818783.png" alt="image-20220507181839508" style="zoom:50%;" />

## 3.4.2 主存与CPU的连接例题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071830997.png" alt="image-20220507183009664" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071830105.png" alt="image-20220507183035840" style="zoom:50%;" />

## 3.5 双口RAM和多模块存储器

#### 双端口RAM

- 有两套接口，也就是两套数据线，两套地址线，两套控制线。
  - 同时和两个CPU相连，两个CPU可以同时对主存进行访问。
  - 对于可能会出现读出错误和写入错误的情况，增加了两条忙线，用来保证两个CPU同时对同一存储单元操作时不会出错。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071840985.png" alt="image-20220507184014695" style="zoom:50%;" />

#### 多模块存储器

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071851500.png" alt="image-20220507185125174" style="zoom:50%;" />

#### 多体并行存储器

- 两种编值方式：
  - 高位交叉编值：地址的高位决定访问的是哪一个存储体。
  - 低位交叉编值：地址的低位来决定。
- 两种编址方式针对连续访问的表现：
  - 对于高位交叉编址，对下一个地址的访问，只能在前一个地址结束访问之后才能开始。
    - 也就是说，下面的例子中，对$M_o$的访问，必须是访完第0个单元后，才能开始访问下一个地址对应的存储单元。
  - 对于低位交叉编址，在对当前地址访问开始之后的很短的一段时间内，就可以立即开始对下一个地址对应的存储单元的访问。
    - 也就是说，在对$M_0$的0号单元访问开始之后的很短一段时间$\tau$后，由于第二条地址所对应的存储单元不在$M_0$上，对第二条地址对应的存储单元的访问也可以直接开始，而不必等待前一个访问完毕。
    - 整体的时间就比高位交叉编址要短很多。
    - 设计得好的话，让$\tau$特别小，可以相当于这多个存储体并行工作。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071934183.png" alt="image-20220507193435844" style="zoom:50%;" />



#### 流水线

- **低位交叉编址的连续存取n个字耗时的结论$T + (n - 1)\tau$只有在$m \geq T /r$的时候才适用，实际设计取等号**
  - 如果存储体的个数$m$过少，则在最后一个存储体的读写工作开始时，再经过$\tau$的时间，由于第1个存储体还没有恢复，不能立即开始工作。
  - 如果存储体的个数$m$恰好等于$T / r$，那么在最后一个存储体读写工作开始时，再经过$\tau$时间，第一个存储体恰好恢复，可以立即开始工作。
  - 如果存储体的个数$m$更大，那么在最后一个存储体读写工作开始时，再经过$\tau$时间，第一个存储体早已恢复完毕甚至已经空闲了一段时间。
    - 所以取等号，把空闲时间去掉。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071947471.png" alt="image-20220507194727267" style="zoom:50%;" />



- 
  - $n$较大时，$(W / r) / (W/T) = T / r = m $，相当于$m$个存储体并行工作
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071944539.png" alt="image-20220507194457202" style="zoom:50%;" />

## 3.6.1 局部性原理及性能分析

### 局部性原理

- 空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的。
- 时间局部性：在最近的未来要用到的信息，很可能是现在正在用到的信息。

#### 性能分析

- 命中率$H$：CPU欲访问的信息已在Cache中的比率。
  - 设在程序执行期间，CPU访问Cache的参数为$N_C$，访问主存的次数为$N_M$，则$H = N_C / (N_C + N_M)$

- 缺失率：$1 - H$，把分子的$N_C$换成$N_M$。
- 设$T_c$为命中时的Cache访问时间，$T_M$为未命中时的访问时间。
  - 未命中则有两种模式：
    - 主存先将数据传输给Cache，然后CPU再从Cache中取出
    - 主存同时向CPU和Cache传输数据。
  - Cache——主存系统的平均访问时间：
    - $T_C * H + T_M * (1 - H)$ 

- 例题注意一下两种不同的未命中下的访问模式：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081140649.png" alt="image-20220508114018164" style="zoom:50%;" />

## 3.6.2 Cache-地址映射

### Cache基本工作原理

- 主存中的块在Cache中如何放置：
  - 空位随意放：全相联映射。随意放哪个空位。
  - 对号入座：直接映射。给每一个块固定分配一个号，在Cache中只能放置在固定位置
  - 按号分组，组内随意放：组相联映射
- Cache满了如何处理？
  - 随机算法
  - 先进先出算法
  - 近期最少使用算法
  - 最不经常使用算法
- 由于CPU会对Cache进行读和写，如何保持Cache中的内容和主存中相应内容的一致性？
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081150317.png" alt="image-20220508115020057" style="zoom:50%;" />

### 地址映射

#### 全相联映射

- 有效位用于标记Cache中的某一块是否已经保存了来自主存其他块的数据，只有被标记为空的Cache块才能存放新的数据。
- 在将主存中块的数据放入Cache的时候，块内的地址是没有变化的。
- 为了标识Cache中保存的那一块数据是来自原来主存中的哪一块，会将主存块的地址的高位也存入。
- 在将主存中的某一块放入Cache的某一块的时候，会将有效位标记为已占用，同时写入主存地址的高位起到溯源的作用。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081157885.png" alt="image-20220508115714514" style="zoom:50%;" />

#### 直接映射

- 概括一下就是第$i$块主存放在Cache的第$i \ mod \ 8$块。
  - 将主存地址分成三部分：
    - 主存字块标记：用于标记放在某一块Cache的内容来自主存的哪一块
      - 由于同一块Cache可以存放来自不同主存块的内容，所以是必要的，比如第0块Cache可以放置第0、8、16块主存的内容。
    - Cache字块地址：能够放置在同一块Cache的主存块，它们的Cache字块地址是一样的，所以这一部分的三位不需要写入Cache作为标记。
    - 字块内地址：最低的6位，还是和上面是一样的。
- 这里和上面不一样的地方在于，用作溯源的主存地址高位，只选取了高位的19位，而没有一并加上中间的三位。
- 与第一种放置方法相比：
  - 优势在于，存放的额外信息少了（也就是起到溯源作用的高位地址的位数少了），硬件电路更简单
  - 劣势在于，第8块主存只能放在第0块Cache，空间利用率肯定是更低的，而第一种方法的就没有这个限制，

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081207619.png" alt="image-20220508120758243" style="zoom:50%;" />

#### 组相连映射

- 先将Cache分组，一个主存块在Cache组内时可以随意放。
  - 每几个Cache块为一组，就称作几路组相联。
  - 以二路组相联为例，将Cache分为4组，第$i$块主存放入第$i \ mod \ 4$组。
- 主存地址就可以分为三部分：
  - 主存字块标记：用于写入Cache后溯源
  - 组地址：标记当前主存块应该放入哪个组，组内可以随机选择一块Cache块放置
  - 字块内地址：不再赘述

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081405588.png" alt="image-20220508140537164" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081411034.png" alt="image-20220508141154720" style="zoom:50%;" />

- 直接映射相当于一路组相联。

## 3.6.3 Cache-替换算法及写策略

### 替换算法

- 对于近期最少使用算法的计数器，可以看做是用来记录某个块“经历了几轮CPU访问但是访问的不是它”的次数。
  - 比如某个Cache块的计数器的值是10，说明CPU访问了十次Cache，但是10次都没有访问到它。
  - 计数器为0就说明该行近几轮CPU访问被命中过。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081424392.png" alt="image-20220508142407084" style="zoom:50%;" />

### Cache原理图

- Cache主存地址映射变换机构负责将CPU给出的主存地址映射成Cache中的块地址和块内地址。
- 数据总线负责CPU和Cache以及主存之间的数据传输，在命中的情况下Cache直接将数据传输给CPU。
- 在未命中的情况下，主存通过Cache替换机构将CPU访问的主存块的内容替换进Cache。
  - CPU则有可能在主存将内容传输给Cache后访问Cache，也有可能主存同时将内容传输给Cache和CPU
- 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081436747.png" alt="image-20220508143617445" style="zoom:50%;" />

### 写策略

#### 命中情况下的写策略

- 写回法：增加一个脏位，用于标记当前块是否被修改过。
  - 在CPU对Cache写命中时，考虑到CPU后续可能还会对同一块做其他写入操作，所以不会马上把改变写回主存对应块。
  - 在等到这块被替换出去的时候，CPU对它不再有修改的可能性了（CPU对它的所有修改工作都完成了），再将这块内容写回主存。
  - 在替换的时候，如果脏位标记为内容未修改，就直接覆盖掉，如果脏位标记为已修改，就将内容写回主存再覆盖。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081441416.png" alt="image-20220508144117107" style="zoom:50%;" />

- 全写法：CPU对Cache写命中时，同时将修改写入Cache和主存。
  - 由于CPU写Cache和写主存的速度差异很大，采用写缓冲。
  - 如果CPU写的频率太高可能会导致缓冲区溢出

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081446294.png" alt="image-20220508144610992" style="zoom:50%;" />

#### 未命中情况下的写策略

- 写分配法，将主存中的块调入Cache，然后对Cache修改。搭配写回法使用。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081511303.png" alt="image-20220508151141994" style="zoom:50%;" />

- 非写分配法：将修改直接写入主存，搭配全写法使用。
  - ![image-20220508151302862](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081513161.png)

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081516640.png" alt="image-20220508151602397" style="zoom:50%;" />

### 多级Cache

- L1和L2之间使用全写法，L2和主存之间使用写回法。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081516617.png" alt="image-20220508151646381" style="zoom:50%;" />

## 3.6.7 虚拟存储器

- 用户给出的地址和实际在存储器上的物理地址是不同的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081611942.png" alt="image-20220508161101621" style="zoom:50%;" />

### 页式虚拟存储器

- 将虚拟空间与主存空间划分为同样大小的页
  - 主存的页称为实页，因为主存是真实存在的。
  - 虚拟内存的页称为虚页，因为虚拟内存是不存在的。
- 主存的地址分为两部分：类似Cache的地址映射
  - 页内地址
  - 实页号
- 虚页的地址也分为两部分：页内地址 + 虚页号
- **一个虚页地址和其对应的实页的页内地址是相同的**，因为虚页和实页是同样大小的页。
- 页表：
  - 页表的一项有两个域：
    - 实页号：记录某个虚页号对应的实页号。
    - 装入位，记录虚拟地址指向的那部分数据是已经被装入主存，还是只存在于外部磁盘中。
      - 如果装入位是1，则将实页号和页内地址拼接一下，得到数据在主存中放置的地址。
      - 如果装入位是0，则操作系统先将虚页对应的数据调到主存中，再访问主存中的数据。
  - **页表本身也是处于主存中的，所以页表的每一项都可以使用主存地址去访问。**
- 由虚页号得到对应实页号的流程：
  - 硬件提供一个寄存器，页表基址寄存器，存放页表的起始地址。
  - 寄存器中的页表起始地址和虚页号进行拼接，就可以得到页表中一个页表项的完整地址。
  - 根据得到的完整地址去访问页表项，然后得到其对应的实页号，以及装入位。
  - 将实页号取出，与虚页地址的页内地址部分进行拼接，就得到了数据在主存当中的地址。
  - 然后访问数据即可。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081632111.png" alt="image-20220508163245827" style="zoom:50%;" />

### 段式虚拟存储

- 将虚地址分为两部分，段号 + 段内地址
  - 由于段的大小是不固定的，所以不将主存地址也分为两部分。
- 段表：
  - 每行是一个段表项。
  - 段表同样是存储于主存当中的，每一项都可以使用主存地址访问。
  - 一个段表项的域有：
    - 某个段对应的段号
    - 装入位
    - 段起点和段的长度。
- 得到主存地址的流程：
  - 硬件有一个寄存器，段表基址寄存器，纪录了段表的起始地址。
  - 将段表起始地址与段号拼接，得到段表项的地址。
  - 根据段表项的地址，取出其中内容与段内地址相加，得到主存地址。
  - 然后访问数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081709301.png" alt="image-20220508170926949" style="zoom:50%;" />

### 段页式虚拟存储器



<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081719034.png" alt="image-20220508171859759" style="zoom:50%;" />

### 快表和慢表

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081726114.png" alt="image-20220508172630783" style="zoom:50%;" />

### 例题

- **不要把最后的大写H也当做地址的一部分，那个是16进制的标记**。
- **标记指的是虚页号，页框号指的是实页号。**
- 虚拟地址空间32位，包括12位页内地址，以及20位虚页号
- 主存地址空间28位，包括12位页内地址，以及16位实页号。
- 有效位表示在Cache中是否有给定虚拟地址指向的数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081733054.png" alt="image-20220508173352694" style="zoom:50%;" />

# 第4章 指令系统

## 4.1 指令格式

### 指令的定义

- 定义：指令是指计算机执行某种操作的命令，是计算机运行的最小功能单位
  - 一台计算机的所有指令的集合构成该计算机的指令集。
  - 只能执行属于自己指令集系统的指令，不能执行其他系统的指令。

### 指令格式

- 指令的长度称作指令字长

#### 地址码

- ​	四地址指令到三地址指令的改进是增加了程序计数器PC
  - 在四地址指令的情况下，指令是分散分布在主存各处的，所以需要给出下一条指令的位置。
  - 新增程序计数器之后，指令是集中存储在内存的某一块，只需要让程序计数器自动的指向下一条指令的位置即可。

- 三地址指令到二地址指令是因为略去了存放结果的内存位置，而使用原来存储某个操作数的空间存储得到的结果。
- 定长指令字结构：指令的长度是固定的，从四地址指令到一地址指令都是定长指令。
- 变长指令字结构：指令的长度不等，比如既有零地址指令又有二地址指令。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101449039.png" alt="image-20220510144901609" style="zoom:50%;" />

#### 操作码

- 定长操作码：操作码的长度是固定的，对于一个$n$位长的操作码来说，指令的种类有$2^n$种。
  - 只考虑操作码的可能性，条数就是这么多。

#### 扩展操作码

- 将4位定长操作码的三地址定长指令进行扩展：
  - 首先不进行扩展的情况下，4位操作码全用于三地址指令，则有16条。
  - **如果将16种状态中的某一种保留下来用于下一层扩展操作码，三地址指令为15条**。这里我们保留`1111`
    - 则当4位操作码为`1111`时，我们知道我们进入了扩展的操作码的范畴。
  - 将前四位为全一的指令，翻译成二地址指令，原先$A_1$的部分也扩展为操作码的一部分。
  - 同样的我们保留$A_1$位置为`1111`的情况用作扩展，这样就得到了15条二地址指令。
  - 以此类推，我们将$A_2$部分也扩展为操作码的一部分，同时也保留其为`1111` 情况用做扩展，得到15条一地址指令。
  - 再进一步扩展，由于无法再进行扩展，所以无需保留$A_3$为`1111`，得到16条零地址指令。
- 当机器在分析指令的过程：
  - 如果读到前四位不为全`1111`，那就说明这是一条三地址指令，可以开始执行。
  - 否则说明这是一条扩展操作码的指令，继续向后读取四位，如果读取到的四位不全为1，说明是二地址指令，可以执行。
  - 否则说明这不是一条二地址指令，继续向后读取四位，如果读取到的四位不全为1，说明是一地址指令，可以执行。
  - 以此类推下去。
  - 四个位置中，某一个位置上的`1111`相当于告诉机器把下一个位置上的四位也看做操作码来读。
  - **所以应该尽量把使用频率较高的指令分配较短的操作码，这样对指令的译码的时间就越短**。
- 设计扩展操作码时应该注意的：
  - 操作码必须是无前缀编码，即某一个短操作码不能是另外一个长操作码的前缀。
  - 各指令的操作码不能重复
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101533888.png" alt="image-20220510153313624" style="zoom:50%;" />
- **每一层其实可以留出多个状态来为下一层进行扩展，所以扩展的方式有很多种**

<img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220510151103017.png" alt="image-20220510151103017" style="zoom:50%;" />

- **一个前一层扩展给下一层留出不同数目状态用作扩展的例题：**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101536025.png" alt="image-20220510153628682" style="zoom:50%;" />

- 总结：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101554934.png" alt="image-20220510155408583" style="zoom:50%;" />

### 操作类型

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101556239.png" alt="image-20220510155647887" style="zoom:50%;" />



## 4.2.1 指令寻址

### 数据存放（编址）的一些概念复习

- 各种编址方式：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101601749.png" alt="image-20220510160142356" style="zoom:50%;" />

- 大端法和小端法：
  - 大端法是符合人类阅读习惯的方法。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101603345.png" alt="image-20220510160322055" style="zoom:50%;" />

- 三个字长：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101612548.png" alt="image-20220510161230284" style="zoom:50%;" />
- 内存对齐：
  - 对齐的好处：不写了。复习的时候想
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101613727.png" alt="image-20220510161329446" style="zoom:50%;" />



### 指令寻址

- 这里给出的只是一个最基本的模型，基本上结合大一的CPU模拟器大作业以及CSAPP有关汇编语言的部分内容就全面了。
- 顺序寻址：PC按顺序自动加一指向下一条指令
- 跳跃寻址：由跳转指令修改PC的值，跳转指令给出的应该是PC相对的寻址方式（CSAPP遥远的记忆）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101620819.png" alt="image-20220510162023487" style="zoom:50%;" />

## 4.2.2 数据寻址1

### 操作数类型

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101640130.png" alt="image-20220510164058873" style="zoom:50%;" />

### 数据寻址

- 以一地址指令为例进行后续讨论。
  - 可以推广到两个地址以上的指令。
  - **每个形式地址都有一个自己的寻址特征，因为每个形式地址可以使用不同的寻址方式**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101739616.png" alt="image-20220510173947350" style="zoom:50%;" />
- 指令的地址码分为两部分
  - 形式地址：并不是操作数真实的在主存中的地址，是用于根据寻址特征求出操作数在主存中的真实地址的。
  - 寻址特征：表征寻址方式的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101737935.png" alt="image-20220510173711540" style="zoom:50%;" />

#### 立即寻址

- 指令的形式地址就是操作数本身，这样获取操作数的时候就不需要去访存，可以减少指令的执行时间。
- 寻址特征采用井号表示
- 立即数一般使用补码形式来表示
- 立即寻址的缺点是形式地址的位数限制了操作数的数据范围。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101758953.png" alt="image-20220510175826638" style="zoom:50%;" />

#### 直接寻址

- 就是把操作数处于主存中的真实地址存入形式地址。
- 要获取操作数的时候，就直接按照指令给出的形式地址去主存的位置寻找即可。
- 缺点是形式地址的长度限制了操作数的寻址范围，并且由于指令中的地址是固定的，就不能轻易修改操作数在内存中的位置。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101802432.png" alt="image-20220510180216097" style="zoom:50%;" />

#### 间接寻址

- 形式地址段保存的是一个指向操作数的地址的指针，也就是保存的是操作数的地址的地址。
  - 也就是说A保存的是EA的地址，EA是操作数的地址。
- 由于操作数的地址的地址是可以灵活变化的，所以形式地址是可以灵活变化的。
  - 也就是可以把EA存到不同的主存位置。
- 在进行多次间接寻址的时候，主存中的每个地址的标志位（图中是最高位）用于表明当前取到的地址是否是指向操作数的有效地址，如果不是就还要继续往前取地址。如果是，则下一次取到的就是操作数。
- 缺点就是多层嵌套的指针访问会增多访存的次数，优点是扩大了寻址范围。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101809426.png" alt="image-20220510180951079" style="zoom:50%;" />



#### 寄存器（直接）寻址

- 将操作数保存在寄存器中，而指令中的形式地址保存的就是寄存器的编号。
- 类似于内存的直接寻址。
- 优点是取操作数的时候非常快
  - 取操作数的时候不需要访存的，因为寄存器在CPU里。
  - 可能比立即寻址还是慢点，毕竟立即寻址操作数就在指令里面，都不需要去取操作数

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101920434.png" alt="image-20220510192057007" style="zoom:50%;" />

#### 寄存器间接寻址

- 这种寻址方式在CSAPP遥远的记忆中就出现了。
- 形式地址仍然是寄存器的编号，**但是寄存器中保存的值不再是操作数，而是操作数在主存中的有效地址**。
- 取指令访存一次，然后从指令指明的寄存器取出操作数的有效地址，然后根据有效地址访存，取得操作数。
- 比一般的间接寻址要快。
  - 因为一般的间接寻址，有效地址是存在主存中的，而寄存器间接寻址，有效地址是存在寄存器中的，访问寄存器肯定更快。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101954560.png" alt="image-20220510195431200" style="zoom:50%;" />



- ### 以上都是以一地址指令为例说明的，对于多地址指令，每个地址都会有自己的寻址特征码，根据它的寻址特征码来计算有效地址即可。

#### 隐含寻址

- 其中一个操作数由形式地址给出，另外一个操作数约定放在ACC中，运算的结果也放入ACC中

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102003505.png" alt="image-20220510200338221" style="zoom:50%;" />



## 4.2.3 数据寻址2——偏移寻址

- 三种偏移寻址计算有效地址的形式都是一样的。
- 基址寻址：将CPU中基址寄存器的内容加上指令格式中的形式地址A，得到操作数的有效地址。
- 既可以使用专用的寄存器来基址寄存器，也可以使用通用寄存器作为基址寄存器。
  - 采用通用寄存器作为基址寄存器的时候，形式地址要给出通用寄存器的编号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102021262.png" alt="image-20220510202110927" style="zoom:50%;" />

### 基址寻址

- 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。
  - 在程序执行过程中，基址寄存器的内容保持不变，作为基地址。
  - 而作为偏移量的形式地址是可变的。
  - 采用通用寄存器作为基址寄存器时，用户可以决定采用第几个通用寄存器，但是还是不能决定寄存器中的内容。
- 扩大寻址范围是每个偏移寻址都有的优点。**有效地址的位数和位数长的那个一致。**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102032132.png" alt="image-20220510203227754" style="zoom:50%;" />

### 变址寻址

- 对于数组来说，形式地址A中的基址，就是数组的第0个单元的地址。
- 如果使用通用寄存器作为变址寄存器，同样需要指出通用寄存器的编号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102046288.png" alt="image-20220510204631985" style="zoom:50%;" />

### 相对寻址

- PC的值是会变化的。
- 形式地址A给出相对当前地址的位移量，使用补码表示。
- 来自CSAPP遥远的记忆，应该是`PC相对的寻址`。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102105092.png" alt="image-20220510210503702" style="zoom:50%;" />

- 例题，里面的第二问是使用补码计算的。。减去一个数，替换成加上它的补码。
  - 因为A是使用补码保存的，但是右边两个地址都是无符号数。转换成补码再求结果。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102125257.png" alt="image-20220510212526864" style="zoom:50%;" />

## 4.2.4 数据寻址3——堆栈寻址

- 没什么好说的，就是利用栈这种数据结构，CSAPP遥远的记忆。
  - 使用出栈来给出操作数。
  - 使用入栈将运算的结果存入。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102322635.png" alt="image-20220510232251151" style="zoom:50%;" />

- 堆栈一般是从主存中划出一块专用区域或一组专用寄存器组来实现。分为硬堆栈和软堆栈。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102325418.png" alt="image-20220510232521119" style="zoom:50%;" />

## 4.3 RISC和CISC

### CISC($Complex \ Instruction \ Set \ Computer$)

- 复杂指令集
- 设计思路：一条指令完成一个复杂的基本功能

### RISC($Reduced \ Instruction \ Set \ Computer$)

- 精简指令集，基于2-8规律。
  - 且用到的2通常是较简单的指令。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102332463.png" alt="image-20220510233232156" style="zoom:50%;" />
- 设计思路：一条指令完成一个最基本的动作，多条指令组合完成一个复杂的基本功能。

### 对比

- CISC通用寄存器少一个原因是指令复杂，产生的中间结果少，另一个原因是指令本身的实现就占用了大部分面积。
- RISC则恰恰相反

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102341981.png" alt="image-20220510234123613" style="zoom:50%;" />

# 第5章 中央处理器

## 5.1 CPU的功能和基本结构

### CPU的功能

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111040669.png" alt="image-20220511104031298" style="zoom:50%;" />

### 运算器和控制器的功能

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111042182.png" alt="image-20220511104237861" style="zoom:50%;" />

### 运算器的基本结构

- 两种结构：总线结构和专用数据通路结构。

#### 专用数据通路结构

- 算术逻辑单元的A和B是两个操作对象保存的地方。

- 每个寄存器都有与A和B直接相连的数据通路（电路）。
  - 所以性能较高， 也不存在数据冲突的问题，但结构复杂，硬件量大不易实现。
  - 数据冲突和总线结构对比的。
- 由于每个寄存器都有导线直接和ALU相连，所以需要一些控制措施来保证不会出现多个寄存器同时向ALU的同一个位置传输数据的情况。
  - 使用多路选择器，选择一路寄存器输入传入ALU中。
  - 使用三态门：每一条导线都有一个三态门，控制这条导线是否输出到ALU。**PPT上无法输出应该是Ａ端不是Ｂ端。**
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111143401.png" alt="image-20220511114351066" style="zoom:50%;" />

-  <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111138765.png" alt="image-20220511113834395" style="zoom:50%;" />

#### 总线结构

- CPU内部单总线结构：将所有寄存器的输入端和输出端都连接到一条公共的数据通路上，也就是总线上。
  - 总线结构必然带来数据冲突，所以每个寄存器的对总线的输出线都有一个三态门用于控制是否输出。
  - **任意两个部件之间的传输都需要通过总线**，两个寄存器之间的数据传输也是通过总线传输的。
  - 结构简单容易实现，但是数据冲突比较多，性能也低一些。
    - 寄存器只能轮流使用总线来传输而不能像专用数据通路那样同时传输。
  - 图中绿色的线是用来控制总线对寄存器的输入的，$RIin$用于控制，绿色箭头用于传输。
- 暂存寄存器的作用：由于AB是和总线同时相连的，所以如果没有暂存寄存器的话，AB中的数据永远是一样的，无法做到两个操作数。
  - 所以使用暂存寄存器，第一个操作数暂存在这里，第二个操作数在第二次总线传输的时候传输给B。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111215518.png" alt="image-20220511121502231" style="zoom:50%;" />
- 有关移位寄存器：
  - 也可以用作暂存ALU运算的结果。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111215944.png" alt="image-20220511121537708" style="zoom:50%;" />
- 程序状态字寄存器($PSW$)：
  - 这个寄存器的每一位都有自己的含义。
  - 这个寄存器是可以按位寻址的，可以直接给出某一位的内容。
  - 可能还有中断的控制信息。
- 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111202037.png" alt="image-20220511120257636" style="zoom:50%;" />

### 控制器的基本结构

- 程序计数器PC：
  - PC有自增功能。
  - PC会跟CPU内部总线有数据交流，用来设置PC的值
- 指令寄存器：
  - 由于保存当前正在执行的指令。
  - **地址码部分会将形式地址（？）传递给总线，然后再通过总线传递给地址寄存器。**也就是说指令寄存器只会将地址码部分传递给总线
    - 地址寄存器保存的到底是形式地址还是有效地址？？？？？
  - 操作码部分传递给指令译码器进行译码。
- 指令译码器：
  - 将指令寄存器传递来的操作码译码，将结果传递给微操作发生器。
- 微操作信号发生器：产生控制整个计算机系统所需的各种控制信号。
  - 图中所有的绿色的蓝色的信号，都是由微操作发生器产生的。
- 地址寄存器：
  - 在逻辑上是属于主存的，但是硬件实际是整合在CPU内部。
  - 与CPU内部总线相连，外连地址总线，地址总线与主存相连。
- 数据寄存器：
  - 在逻辑上是属于主存的，但是硬件实际是整合在CPU内部。
  - 与CPU内部总线相连接，也与数据总线相连，两边的总线都会有输入和输出。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111412472.png" alt="image-20220511141211018" style="zoom:50%;" />

### CPU的基本结构

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111427338.png" alt="image-20220511142733005" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111428337.png" alt="image-20220511142759975" style="zoom:50%;" />

## 5.2 指令周期的数据流

### 指令周期

- 指令周期：CPU从主存中每取出并执行一条指令所需的全部时间
  - 每条指令的指令周期并不一定是相同的（废话）
  - 也就是说每条指令所需要的机器周期的数目也不是相同的。
- 指令周期常常用若干个机器周期来表示，机器周期又叫CPU周期。
  - 每个机器周期的长度也不一定是相同的，可能是定长的机器周期($a$)，也可能是不定长的机器周期($b$)。
- 一个机器周期又包含若干个时钟周期，时钟周期是CPU操作的最基本单位。一个时钟周期完成一个最基本的动作。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202033259.png" alt="image-20220520203342934" style="zoom:50%;" />
- 不同指令的指令周期不同是因为不同指令要完成的任务的复杂度是不同的，NOP指令的任务是最简单的（没有操作），乘法指令又比加法指令复杂。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202038675.png" alt="image-20220520203817308" style="zoom:50%;" />

### 指令周期流程

1. 进入取指令周期
2. 取值周期结束后判断有无间接寻址，
   1. 有的话进入间址周期，然后从间址周期进入执行周期
   2. 无的话直接从取值周期进入执行周期
3. 执行周期结束后判断有无中断
   1. 有的话进入中断周期
   2. 无的话直接进入下一条指令的指令周期

- 系统如何判断当前处于指令周期的哪一个阶段？
  - 有4个触发器，每个触发器负责记录一个周期。
  - 处于哪个周期，就把哪个周期对应的触发器置为1，其他触发器置为0。进入相应周期的时候有微命令负责。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202044606.png" alt="image-20220520204400218" style="zoom:50%;" />



### 取指周期：取指令

- 一些关于程序计数器的说明：
  - 有的时候说程序计数器保存的是下一条指令的地址，有的时候说程序计数器保存的是当前指令的地址，这两种说法都是正确的，只不过视角不同。
  - 在取指周期开始时，程序计数器保存的就是马上要取的那条指令的地址，也就是“当前指令的地址”。
  - 在取址周期结束时，控制单元会令程序计数器“加一”，指向下一条指令，此时PC保存的就是“下一条指令的地址”。

- 取指周期要做的事：
  1. 将PC中保存的当前指令的地址放入地址寄存器中。
  2. 控制单元发出控制信号，经控制总线传入主存，取指令的时候发出的是读主存的信号。
  3. 地址寄存器中的地址经地址总线传入主存，主存将取到的内容（也就是指令）通过数据总线传入数据寄存器。
  4. 数据寄存器中的指令**经CPU内部的总线**送入指令寄存器IR。
  5. 控制单元发出控制信号，修改程序计数器的值，使它指向下一条指令。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202052276.png" alt="image-20220520205225914" style="zoom:50%;" />

### 间址周期：取有效地址

- **这里以一次间址为例说明**
- 间址周期做的事：
  1. 指令寄存器通过CPU内部总线将形式地址送入地址寄存器（这里是可以的，形式地址是操作数的地址的地址）
  2. 控制单元通过控制总线给主存一个读信号
  3. 主存将MAR所指向的内容（也就是操作数的地址）取出，通过数据总线传递给MDR。
  4. MDR直接将操作数的地址传入地址寄存器，或者先传递给IR指令的地址码部分，然后传递给地址寄存器。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202106257.png" alt="image-20220520210625886" style="zoom:50%;" />

### 执行周期

- 下一节细讲

### 中断周期

- 中断是什么：暂停当前的任务去完成其他任务。
  - 既然是暂停，那待会肯定是要回来的。
  - 所以要保存断点。
- 断点是什么：断点就是当前暂停的时候本来要执行的指令的地址（具体是不是下一条看情况，反正就是当前PC的内容）
- 保存断点就是保存当前PC的内容。
- 一般将PC的内容保存在堆栈中，而来自CSAPP遥远的记忆告诉我，栈顶指针保存在寄存器%rsp中。
- 由于对于栈顶指针的实现有不同的方案，可能是指向下一个空位，也可能指向栈顶元素，我们在这里假定是后一种。
- 那么中断周期要做的事有：
  1. CU（控制单元）将%rsp的内容减一（来自CSAPP的记忆就不用多说了吧），这一步就是在修改栈顶指针的值，让它指向下一个空位。
  2. 修改后的栈顶指针值传递给地址寄存器，地址寄存器通过地址总线将要写入的主存位置的地址（也就是栈顶的空位的地址）传入主存
  3. CU发出控制信号，通过控制总线给主存一个写入的信号。
  4. PC的内容通过CPU内部总线传递给数据寄存器，数据寄存器通过数据总线将内容传递给主存，并将内容写入栈顶。
  5. **截止目前完成了保存断点的工作，接下来去完成其他任务**
  6. CU修改程序计数器的值，这样就可以让CPU去执行其他任务的第一条指令。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202116641.png" alt="image-20220520211611227" style="zoom:50%;" />

### 指令执行方案

- 单指令周期：
  - 不细分那么多指令的阶段，就一整个指令周期作为一个阶段，对所有的指令都选用相同的时间来完成。
  - 指令之间是串行执行的，一条指令执行完，才能执行下一条指令。
  - 由于实际上每种指令执行需要的时间是不一样长的，所以单指令周期只能选取需要时间最长的指令为准。
  - 也是因为同样的原因，整个系统的效率会更低。

- 多指令周期：
  - 设计上和单指令周期恰好相反。但是指令之间仍然是串行执行的。硬件设计更复杂但是效率高一些。
- 流水线方案：
  - 根本的依据是在同一时间内，不同的指令可以占用不同的硬件资源。
- ![image-20220520213725650](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202137075.png)



## 5.3.1 数据通路1——CPU内部的单总线方式

- 数据通路：数据在功能部件之间的传送路径。
  - 由控制部件产生的控制信号建立数据通路
- 数据通路的基本结构：
  - CPU内部的单总线方式
  - CPU内部的多总线方式
  - 专用数据通路方式
- 内部总线和系统总线的概念：概括一下就是系统总线是负责各个部件沟通的，而内部总线是负责部件内部沟通的。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202239223.png" alt="image-20220520223909915" style="zoom:50%;" />



- 各种数据在CPU内部的传送的情况都举了个例子，看一下吧：
  - 一些说明：
    - 主存与CPU之间的数据传输，第三步的$MDRin$有效，原则上应该指的是数据总线与数据寄存器之间的$MDRin$，这里直接用图上的代替了
    - 第三个例子中，将指令的地址码部分传入地址寄存器的时候，原则上应该是$IRout$负责传输到地址寄存器，这里直接使用了数据寄存器的内容($MDRout$)，是因为在取指令之后，数据寄存器中的内容恰好就是IR中的那条指令。
    - 第三个例子中，另外一个操作数隐含在ACC中。寄存器Y是操作数的暂存寄存器，寄存器Z是ALU运算结果的暂存器。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202253468.png" alt="image-20220520225332046" style="zoom:50%;" />

- 还有一个例题，挺简单的。。感谢CSAPP
- 多总线和单总线是类似的，看到连线之后可以进行类比。

## 5.3.2 数据通路2——专用数据通路

- 其实和总线的方式差别也不大。。其实就可以看做是任意两个需要交流的部件之间都有一条它们二者专用的总线就行了。。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205202330937.png" alt="image-20220520233046577" style="zoom: 50%;" />

## 5.4.1 控制器1——硬布线

### 控制器的结构和功能

- 控制器的功能：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205222105170.png" alt="image-20220522210529770" style="zoom:50%;" />
- 一个更全面的所有设备之间的连接图：
  - **输入和输出设备也是通过数据总线来传输数据的**。注意箭头，数据总线与输入和输出设备的箭头是单向的。
  - 地址总线除了传输主存地址，也起到了定位输入输出设备的作用，输入输出设备的“地址”也是通过地址总线传输。
  - 控制总线负责传输控制信号。
  - 程序计数器的值可能是经过ALU计算的结果，也可能是自动“加一”
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205222106781.png" alt="image-20220522210623300" style="zoom:50%;" />

### 控制器的输入和输出

- 控制器的输入：
  - 标志是来自程序状态字寄存器的输入
  - CPU内部的控制信号也需要通过CPU内部总线？
  - 来自系统总线的控制信号其实是反馈信号

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231422690.png" alt="image-20220523142259214" style="zoom:50%;" />

### 硬布线控制器

- 使用操作码译码器把n位代表一个状态转换成1位代表一个状态。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231430583.png" alt="image-20220523143001219" style="zoom:50%;" />

### CPU的控制方式

- 同步的控制方式：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231434301.png" alt="image-20220523143446915" style="zoom:50%;" />
- 异步的控制方式和同步异步联合的控制方式：了解一下
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231436472.png" alt="image-20220523143632136" style="zoom:50%;" />

### 安排微操作时序

#### 取指周期

- **假设**：一个机器周期内安排三个节拍，采用同步控制的方式。
- 取指周期要做的六件事（这里无排序）：
  1. PC的值传递给地址寄存器，这个肯定是需要最先做的。
  2. 给主存发出读信号，这个与1没有明确的先后关系，当然在前面我们是知道是先1后2的，但是可能有的书直接合并到3去。
  3. 从主存中取出指令并放入数据寄存器，这个肯定要在1的后面。
  4. 从数据寄存器中将指令传递给IR，这个肯定要在3的后面。
  5. IR将操作码传递给CU（译码），这个肯定要在4的后面
  6. PC的值“加一”，指向下一条指令的位置。这个的话，其实只要在1之后，就都可以的。
- 所以按照三个原则：
  - 答案并不是唯一的，因为6可以放在不同的位置（比如，先排6后排3，**但是不管怎么排3和6都是并发的**），只要在1后面都可以。
  - 将3和6放一起可以说是按照原则二，二者的操作占用的是不同的资源，所以放在同一个节拍之内同时完成。
  - 安排在T~2~的两个操作是原则三。

![image-20220523144215336](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231442874.png)

#### 间址周期（一次间址为例）

- 间址周期要做的事：
  1. 形式地址（有效地址的地址）放入MAR
  2. 给主存传递读信号
  3. 取得有效地址放
  4. 有效地址传给

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231454817.png" alt="image-20220523145422476" style="zoom:50%;" />

#### 执行周期

- 看看就好，倒不用记太多

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231505796.png" alt="image-20220523150547367" style="zoom:50%;" />

#### 中断周期

- $a$是保存断点的值的内存位置，估计是栈顶指针
- 将入口地址传递给PC的操作只要在断点保存之后即可



<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231513268.png" alt="image-20220523151356877" style="zoom:50%;" />

### 硬布线电路设计

- 步骤：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231534705.png" alt="image-20220523153429384" style="zoom:50%;" />



1. 列出操作时间表：以根据地址取主存内容为例：
   - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231535405.png" alt="image-20220523153527002" style="zoom:50%;" />
   - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231536012.png" alt="image-20220523153621593" style="zoom:50%;" />
2. 列出逻辑表达式$\uparrow$
3. 画组合逻辑图：
   - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231537907.png" alt="image-20220523153743525" style="zoom:50%;" />

## 5.4.2 控制器2——微程序

### 微程序控制的基本思想

- 微操作：一个基本的操作
- 微命令：微操作的控制信号，一个微操作对应一个微命令
  - 相容性微命令：可以放在同一时间同时执行
  - 互斥性微命令：

- 完成一条机器指令的操作可以看做由很多个微操作构成，因此一条机器指令可以看做由很多条微操作命令构成。
- 将相容性的微命令统一编写成写成一条微指令，互斥性的微命令单独编写成一条微指令。一系列的微指令构成一个微程序，微程序就可以完成一条机器指令的工作。
- 提前将微程序写好，然后放入非易失性的存储介质中（如ROM），每一条机器指令对应一个微程序。
- 由于每条指令的取值周期的操作都是相同的，所以把取指周期完成的工作统一做成一个微程序。
- 一条微指令的格式：微操作码 + 微地址码

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231630076.png" alt="image-20220523163040571" style="zoom:50%;" />

### 微程序控制器的基本结构

- 机器指令的操作码部分传递给微程序控制器（微地址形成部件），形成的微地址再传递给顺序逻辑。
- 顺序逻辑进行一些判断，将地址传递给微地址寄存器，由译码器将地址译码。
- 微数据寄存器存放从控制存储器中取出的微指令，然后执行微指令。
- 微指令的“下地址”指的是下一条指令的地址。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231644314.png" alt="image-20220523164436781" style="zoom:50%;" />

### 控制存储器CM

- 这里主要讲的是组成微程序的微指令是如何定位到下一条微指令的。
- 以取指周期为例，第M条是取指微程序的入口微指令，它的下址字段设置为M+1，就是下一条微指令的地址。
  - **取指周期微程序的最后一条指令的下地址是指向间址周期微程序的第一条指令还是指向其他情况，就需要顺序逻辑部件来判断。**
- **除了取指周期微程序以外的，那些对应一条机器指令的微程序，他们的最后一条微指令都是指向取指周期微程序的入口微指令。**
  - 比如对应LDA的微程序，在机器指令LDA结束之后，就要进入取下一条指令的循环了，所以P+2处的微指令的下地址是M。
- 间址周期的微程序的最后一条微指令的下地址指向执行周期微程序的第一条微指令，中断周期类似，看图。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231700130.png" alt="image-20220523170017719" style="zoom:50%;" />

### 微指令的格式

- 垂直型的微指令类似机器指令，一个操作码只能定义一个操作。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231708904.png" alt="image-20220523170851424" style="zoom:50%;" />

### 微指令的编码方式

- 什么叫做微指令的编码：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231711307.png" alt="image-20220523171127992" style="zoom: 67%;" />
- 直接编码方式
  - 操作码字段的每一比特对应一个微操作，这一比特为1代表这个微操作有效。比如图上的(PC)$\rightarrow$MAR有效
  - 缺点和优点看图。
  - ![image-20220523171358640](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231713006.png)

- 字段直接编码方式：
  - 将微指令的控制字段分成若干段，每段对应一个微操作，经译码后发出控制信号。
  - 互斥性的微命令分在同一段内，利用的是译码器一次只能有一个输出，这样同一段内的互斥性命令就不会同时发出控制信号。
  - 相容性的微命令分在不同段，利用的是不同段的译码器是可以同时各自输出一个输出的，这样就可以使相容性微命令同时执行。
  - 第三点注意一下，需要保留一个状态表示不发出任何微命令。
  - 编码过肯定指令更短，但是要译码所以也会更慢
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231724535.png" alt="image-20220523172421098" style="zoom:50%;" />
  - 一个例题：
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231725415.png" alt="image-20220523172542066" style="zoom:50%;" />
- 字段间接编码：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231818108.png" alt="image-20220523181805730" style="zoom:50%;" />

### 微指令的地址形成方式

- 后四种了解一下就好

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231820980.png" alt="image-20220523182027570" style="zoom:50%;" />

- 第一种方式的例题：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231823562.png" alt="image-20220523182335085" style="zoom:50%;" />

### 微程序控制的基本概念梳理

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231827977.png" alt="image-20220523182732498" style="zoom:50%;" />

### 微程序控制单元的设计

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231833627.png" alt="image-20220523183349264" style="zoom:50%;" />

- 
  - 从上往下三个蓝色的框依次标注为1 2 3条微指令。每条微指令都由两个微操作（微命令）组成。
  - 在第1和2之间的那个微操作（也是一条微指令）是用于，执行完第1条微指令之后，告诉第2条微指令在哪里。2和3之间的类似。
    - 一个微操作对应一个微命令，一个微指令可以对应一个微操作（也就是微命令），也可以对应多个微操作。
  - T5那个就是用于转入下一个周期了。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231832443.png" alt="image-20220523183201053" style="zoom:50%;" />

### 微程序设计分类

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231837035.png" alt="image-20220523183739676" style="zoom:50%;" />

### 硬布线与微程序比较

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231837148.png" alt="image-20220523183700650" style="zoom:50%;" />

## 5.5.1 指令流水线的概念及基本指标

### 指令流水的定义

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231910373.png" alt="image-20220523191030982" style="zoom:50%;" />

- 指令的顺序执行方式：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231911627.png" alt="image-20220523191115239" style="zoom:50%;" />

- 一次重叠执行方式：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231912099.png" alt="image-20220523191256743" style="zoom:50%;" />

- 二次重叠执行方式：
  - 按照这样，如果把指令的阶段细分越多，可以重叠的比例也就越大。
  - 流水线的基本思想就是这样，同一时刻多条指令占用不同的资源，从而可以同时执行。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231914657.png" alt="image-20220523191446275" style="zoom:50%;" />

### 流水线的表示方法

- 其实我感觉。。差不多。。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205231924381.png" alt="image-20220523192404949" style="zoom:50%;" />

### 流水线的性能指标

- 性能指标：
  - 吞吐率
  - 加速比
  - 效率
- 吞吐率($TP$)：
  - 完成任务的个数（指令数）除以完成任务所花费的时间。
  - 极限情况下，平均一个时钟周期内可以完成一条指令的全部工作。
  - 装入时间：第一条指令开始到结束的那段时间
  - 排空时间：最后一条指令开始到结束的那段时间
  - 夹在装入时间和排空时间之间的那部分，每个时刻所有的资源都被占满，是最理想的情况。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232017940.png" alt="image-20220523201738515" style="zoom:50%;" />

- 加速比：
  - 极限是K倍，顺序执行的时候一条指令花费K个时钟周期，流水线理想情况下只需要一个时钟周期，所以是K倍。
  - ![image-20220523203244430](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232032863.png)

- 效率：
  - 有效面积可以割补成一个矩形来算。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232035929.png" alt="image-20220523203547482" style="zoom:50%;" />

## 5.5.2 影响流水线的因素及分类

### 机器周期的设置

- 实际上指令的各个阶段都不算等长时间的。
- 下面这张图的信息：
  - 取值阶段是有一个指令高速缓存的，同样的还有一个数据高速缓存。
  - 为了方便流水线的设计将每个阶段的耗时取最各个阶段的耗时最大值，但是由于各个阶段的实际耗时实际上是不一样的
  - 就会出现耗时短的阶段提早结束，所以需要在每个阶段的功能部件都配置应该缓冲器寄存器，把提前结束的结果缓存好。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232041487.png" alt="image-20220523204106090" style="zoom:50%;" />

### 影响流水线的因素

#### 结构相关（资源冲突）

- 前一小节所提到的流水线工作站既有指令高速缓存也有数据高速缓存就是为了解决这样的问题。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232046670.png" alt="image-20220523204635258" style="zoom:50%;" />

#### 数据相关（数据冲突）

- 比如后面几条指令需要用到前面几条指令的运算结果，那这几条指令就没办法在流水线上并行
- 解决办法看图
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232111245.png" alt="image-20220523211147858" style="zoom:50%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232111627.png" alt="image-20220523211111210" style="zoom:50%;" />
  - 
- 配图是数据旁路
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232110133.png" alt="image-20220523211041635" style="zoom:50%;" />

- 数据冲突的种类：
  - 写后读，读后写，写后写。后两种都是因为流水线优化的导致的。
  - **A是After的意思**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232252758.png" alt="image-20220523225246423" style="zoom:50%;" />

#### 控制相关

- 最主要的就是，假如条件转移时，你的条件的真值还没有确定怎么办？
  - 如果默认按条件为真走，那条件为假时就白费功夫。反之亦然。
  - 第四种就是分枝预测

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232257448.png" alt="image-20220523225733133" style="zoom:50%;" />

### 流水线的分类

- 了解一下就好
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232306496.png" alt="image-20220523230611190" style="zoom:50%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232306521.png" alt="image-20220523230628241" style="zoom:50%;" />

### 流水线的多发技术

- 超标量技术
  - 比如图上这样3条3条地执行指令，要求有多套功能部件
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232308149.png" alt="image-20220523230847899" style="zoom:50%;" />
- 超流水技术
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232318877.png" alt="image-20220523231841619" style="zoom:50%;" />
- 超长指令字
  - 由于是将多条指令合并了，就会有多个操作码，所以在进行执行指令的时候需要有多个负责执行的部件。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205232321570.png" alt="image-20220523232104322" style="zoom:50%;" />

# 第6章 总线

## 6.1.1 总线的概念与分类

### 总线的定义

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301400337.png" alt="image-20220530140050915" style="zoom:50%;" />

### 总线的特性

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301405261.png" alt="image-20220530140529968" style="zoom:50%;" />

### 总线的分类

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301407978.png" alt="image-20220530140702685" style="zoom:50%;" />

#### 串行总线与并行总线

- 假设设备A要给设备B传送数据1011。
- 如果是串行总线：A将1011一位一位地传输给总线，总线一位一位地传输到B，然后设备B再一位一位地接收数据。
- 如果是并行总线：A将1011四位并行传输给总线，总线并行传输四位到B，然后设备B并行接收四位数据
- 数据的拆卸和装配指的就是将多位数据拆分成一位一位地传输，装配就是相反的过程。
- 并行总线需要多根导线并行，每根导线传输其中一位数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301408518.png" alt="image-20220530140845164" style="zoom:50%;" />

### 片内总线、系统总线、通信总线

- 注意区分一下片内总线和内部总线，片内总线的片特指CPU芯片，而内部总线的内部泛指计算机部件的内部。
- 数据总线的位数与机器字长以及存储字长没有固定的关系。
- 控制总线一般不讨论根数问题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301422982.png" alt="image-20220530142258619" style="zoom:50%;" />

##### 系统总线

- **地址总线的导线根数和主存地址空间以及外设数量都有关系。**根数关系到主存的容量最大值以及设备的数量。
- 控制总线的每一根的方向是不一样的，可能有一根负责从CPU传出控制信号，有一根从外部传入反馈信号给CPU。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301420379.png" alt="image-20220530142000951" style="zoom:50%;" />

### 系统总线的结构

#### 单总线结构

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301626275.png" alt="image-20220530162613962" style="zoom:50%;" />

#### 双总线结构

- 主存总线支持突发传送，给出首地址即可传输地址连续的几个字节。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301628933.png" alt="image-20220530162847606" style="zoom:50%;" />

#### 三总线结构

- 高速外设通过DMA总线直接和主存交流，**高速外设和低速外设通过I/O总线与CPU进行交流**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301633039.png" alt="image-20220530163321698" style="zoom:50%;" />

### 四总线结构简介

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301637961.png" alt="image-20220530163707562" style="zoom:50%;" />

## 6.1.2 总线的性能指标

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301638478.png" alt="image-20220530163823242" style="zoom:50%;" />



### 前四个

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301643799.png" alt="image-20220530164339408" style="zoom:50%;" />

### 后两个

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301646078.png" alt="image-20220530164635737" style="zoom:50%;" />

- 例题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301651766.png" alt="image-20220530165103348" style="zoom:50%;" />



### 串行总线与并行总线的速度问题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301658348.png" alt="image-20220530165809054" style="zoom:50%;" />

### 总线复用和信号线数

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301659971.png" alt="image-20220530165957571" style="zoom:50%;" />

## 6.2 总线仲裁

### 基本概念



<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301710955.png" alt="image-20220530171053614" style="zoom:50%;" />

### 集中仲裁方式

#### 链式仲裁

- BG线：信号由总线控制部件发往设备，截取到这个信号的设备相当于截取到了总线的使用权。
- BR线：信号由与总线相连的设备发往总线控制部件，需要使用总线的设备通过这根线给总线控制部件发出请求。
- BS线：信号由与总线相连的设备发往总线控制部件，已经获取到总线使用权的设备会在使用总线之前发出信号告知控制部件总线忙。
- 假定设备1和设备n同时要使用总线：
  1. 两个设备通过BR线向总线控制部件发出控制请求
  2. 总线控制部件查看BS线，确定当前总线是否被占用
  3. 如果总线当前空闲，则沿BG线发出总线允许信号
  4. 总线允许信号被里控制器近的设备1获取，设备1获得总线使用权，并发出总线忙信号。
  5. 设备1使用完毕后撤销总线忙信号，总线允许信号继续向前传播（是控制部件重新发出信号还是从被截取的地方继续向前不要深究）被设备n截取。
- 缺点和特点看图

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301718600.png" alt="image-20220530171856183" style="zoom:50%;" />

#### 计数器查询方式

- 有请求的时候，计数器数数，这个数实际上就是设备的地址。
- 设备地址线需要$\lceil log_2n \rceil$条。这个没啥好说的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301730138.png" alt="image-20220530173041626" style="zoom:50%;" />

#### 独立查询方式

- 图上的信息足够说明工作过程了

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301737362.png" alt="image-20220530173709930" style="zoom:50%;" />



### 分布式仲裁方式

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301739577.png" alt="image-20220530173920312" style="zoom:50%;" />

## 6.3 总线操作和定时

### 总线传输的四个阶段

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301759219.png" alt="image-20220530175929872" style="zoom:50%;" />

### 同步定时方式

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301809290.png" alt="image-20220530180943933" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301809299.png" alt="image-20220530180923970" style="zoom:50%;" />

### 异步定时方式

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301819024.png" alt="image-20220530181922611" style="zoom:50%;" />

- 不互锁就是两个设备发出信号之后也不管对方收没收到，维持一段时间就直接撤销信号
- 半互锁就是主设备在收到从设备的回答之前会一直维持请求的信号
- 全互锁就是主从设备在对方收到自己发出的信号之前，都会一直维持自己发出的信号
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301818135.png" alt="image-20220530181802772" style="zoom:50%;" />

### 半同步通信

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301834263.png" alt="image-20220530183408972" style="zoom:50%;" />

### 分离式通信

- 把总线空闲的那段时间内的使用权让出来，而不是被主设备占用着干等
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205301837942.png" alt="image-20220530183718624" style="zoom:50%;" />

## 6.4 总线标准

### 总线标准的基本概念

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302009669.png" alt="image-20220530200926281" style="zoom:50%;" />

### 总线标准

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302010269.png" alt="image-20220530201029685" style="zoom:50%;" />

#### ISA/EISA

- ISA和EISA的最大速度是可以用工作频率和数据线的根数算出来的。
- EISA的扩展就是扩展在了数据线的宽度上（根数多了一倍）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302013640.png" alt="image-20220530201307136" style="zoom:50%;" />

#### PCI

- 局部总线

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302017853.png" alt="image-20220530201724334" style="zoom:50%;" />

#### AGP

- 显卡专用局部总线
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302020545.png" alt="image-20220530202002073" style="zoom:50%;" />



#### PCI-E

- 串行架构

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302022360.png" alt="image-20220530202214911" style="zoom:50%;" />





#### VESA

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302027180.png" alt="image-20220530202701691" style="zoom:50%;" />

#### USB

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302031793.png" alt="image-20220530203136342" style="zoom:50%;" />

#### RS-232C

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302032469.png" alt="image-20220530203244021" style="zoom:50%;" />

#### IDE

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302034940.png" alt="image-20220530203421478" style="zoom:50%;" />

#### SATA

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302035509.png" alt="image-20220530203550928" style="zoom:50%;" />

### 视频线标准

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205302042481.png" alt="image-20220530204159943" style="zoom:50%;" />

# 第7章 输入/输出系统

## 7.1 基本概念

### I/O系统的演变过程

- 早期IO和CPU串行工作，分散连接，IO系统和主存之间的信息传递也需要CPU来作为中介完成。在IO系统工作时CPU本身是不工作的，它不断查询IO设备是否已经做好准备，而不是去做其他的工作。
- 中断方式一定程度上解放了CPU，IO系统在有数据并且准备就绪时才通过中断请求的方式告知CPU，CPU就可以在IO系统准备数据的时候做其他事情。
  - **由于低速外设需要准备的时间相对长，所以它给CPU的中断不会非常频繁，不会频繁打断CPU。**
  - 但是对于高速外设来说恰恰相反，这就是为什么会出现了DMA方式，直接让高速外设不采用中断的方式，由DMA控制器完成任务。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206101745931.png" alt="image-20220610174522428" style="zoom:50%;" />

### I/O系统基本组成

- I/O指令的操作码部分的作用是告诉CPU这条指令是一条 I/O指令。
- 命令码部分指明这条I/O指令是做什么操作。设备码指明对哪个设备进行操作。
- I/O指令由CPU执行，通道指令由通道执行。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206101922302.png" alt="image-20220610192252922" style="zoom:50%;" />

### I/O方式简介

- 程序查询方式：：在I/O准备数据的过程中CPU要持续等待并查询。
- 中断方式：启动I/O之后CPU可以继续执行指令，直到I/O发出中断请求，CPU处理中断服务程序。
- DMA方式：DMA发出请求后，CPU是不能访问主存的，如果CPU需要访问主存，此时需要停下等待，如果CPU此时不需要访问主存，就可以直接执行现行程序，DMA发出请求的时候也无需停下。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206101934504.png" alt="image-20220610193419134" style="zoom:50%;" />

## 7.2.1 输入输出

### 外部设备

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206101947794.png" alt="image-20220610194732289" style="zoom:50%;" />

### 输入设备

- 了解下就好

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206101949406.png" alt="image-20220610194907967" style="zoom:50%;" />



### 输出设备

- 重点是显存的计算。
  - 显存容量等于分辨率$\times$灰度级位数，也就是一幅图像总共有多少个像素点乘以记录每个像素点的颜色所需要的位数。
  - 带宽就是一秒内传输的比特数呗，每次刷新传输的比特数就是显存容量那么多，一秒内刷新的次数就是帧频呗。 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206101953525.png" alt="image-20220610195306089" style="zoom:50%;" />

### 显示器

- 分类，后续细讲阴极射线管显示器

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102002606.png" alt="image-20220610200221157" style="zoom:50%;" />

#### 阴极射线管显示器

- 字符显示器：
  - 字模要结合编码（如ASCII）和显示器的控制器来选择其对应的ROM，ROM中保存了这个字符的字模。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102006557.png" alt="image-20220610200655175" style="zoom:50%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102006497.png" alt="image-20220610200612131" style="zoom:50%;" />

- 图像显示器和**图形**显示器
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102009866.png" alt="image-20220610200904544" style="zoom:50%;" />

- 按扫描方式还可分为两类：
  - 光栅扫描显示器：扫描的时候是逐行扫描完整个屏幕，来决定屏幕上的每个像素点是否点亮。
  - 随机扫描显示器：只在需要显示的位置（比如屏幕上有字的位置）进行扫描。

### 打印机

- 科普罢了

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102014600.png" alt="image-20220610201458244" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102016301.png" alt="image-20220610201611895" style="zoom:50%;" />

## 7.2.2 外存储器

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102040266.png" alt="image-20220610204034864" style="zoom:50%;" />

### 磁盘存储器

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102053669.png" alt="image-20220610205322246" style="zoom:50%;" />

### 磁盘的性能指标

#### 磁盘的容量和密度

- 格式化后的磁盘的容量肯定是小于非格式化的，所以格式化容量小于非格式化容量。
- 记录密度：盘片单位面积上的信息量。
  - 道密度：就是沿着盘片的半径方向上，单位长度上有几圈，也就是用总的圈数除以半径。
  - 位密度：磁道上单位长度能记录的二进制代码的位数，也就是某一圈上，这个圈上的单位长度能记录的位数。
  - 由于要保证所有磁道能够记录的信息总量是相等的，所以越外圈，半径越大，其道密度应该是越小的，每个磁道的位密度都不同。
  - 一个盘片上的总容量就是：每一圈能够记录的位数乘以圈数。面密度则是盘面的密度。磁盘的总容量就是一个盘片的容量乘以盘片数。
  - 面密度等于(位密度*2πR) * （道密度 * R）/（2πR^2^） = 位密度 * 道密度。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102133664.png" alt="image-20220610213317148" style="zoom:50%;" />

#### 平均存取时间

- 寻道时间如果题目没有给的话，按照寻道时间算。
- 旋转延迟时间也是，看题目怎么给。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102146843.png" alt="image-20220610214644295" style="zoom:50%;" />

#### 数据传输率

- 一秒转多少圈乘以一圈的字节容量即可
- ![image-20220610215214835](https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102152122.png)

### 磁盘的地址和磁盘的工作过程

- 磁盘地址的编址和之前的编址的思想是类似的
- 硬盘在工作的时候是串行工作的，不能同时读写，也不能同时读写多组数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102154616.png" alt="image-20220610215441231" style="zoom:50%;" />

### 磁盘阵列

- 磁盘阵列类似下面这样：
  - 条带法：每个逻辑盘的条带实际上是存储在不同的磁盘上，这样读取数据的时候可以并行读取几个物理盘。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102201384.png" alt="image-20220610220136071" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102159883.png" alt="image-20220610215955259" style="zoom:50%;" />

### 光盘存储器

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102203271.png" alt="image-20220610220343874" style="zoom:50%;" />

### 固态硬盘

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206102204970.png" alt="image-20220610220453643" style="zoom:50%;" />

## 7.3 I/O接口

### I/O接口的功能

- 数据缓冲的存在是因为发送方和接收方可能存在的速度差

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206110045003.png" alt="image-20220611004558665" style="zoom:50%;" />

### I/O接口的基本功能

- 反映设备状态的几个触发器都是一位。
- 在CPU这一侧都是进行并行的数据传输的，在外设这一侧则可能是串行也可能是并行。
- 注意一下内部接口和外部接口
- 设备选择电路负责判断选中的是否是当前设备（？）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206110052967.png" alt="image-20220611005227521" style="zoom:50%;" />

### I/O设备工作过程举例

- 以CPU要控制外设输入为例：
- 工作过程大概如下：
  1. CPU通过地址线传递地址，到达设备选择电路。
  2. 设备选择电路判断是否是当前设备，从而启用相应的设备。
  3. 被选中的设备通过状态线将设备状态标记传递给CPU，反馈设备状态。
  4. 如果被选中的设备是就绪状态，CPU通过命令线发出控制命令，控制命令暂存在命令寄存器并被命令译码器译码，转换为外设的控制信号。
  5. 转化得到的控制信号通过命令线传递给外部设备。
  6. 外部设备通过数据线将数据输入到数据缓冲寄存器中。
  7. 外设通过状态线将输入完成的信号传递给外部接口，从而更新设备状态标记，I/O接口通过状态线向CPU发出信号。
  8. 如果CPU决定响应这个信号，它就通过命令线发出响应。
  9. 接口通过数据线先传递一个中断类型号给CPU，告知CPU要干什么，然后再传输数据给CPU。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206110057873.png" alt="image-20220611005714424" style="zoom:50%;" />

### 接口与端口

- CPU访问端口实际上是对端口的寄存器进行读写。
- 看图
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206111906427.png" alt="image-20220611190608009" style="zoom:50%;" />

### I/O端口及其编址

- 统一编址：将I/O端口也看做是主存的一部分，将它和主存的储存单元一起进行编址。这种情况下储存单元的地址和I/O端口的地址是不会重合的。
  - 比如地址总共有十位，可以有1024个地址，有十个I/O端口。则需要从这1024个地址中腾出十个给I/O端口。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206111911448.png" alt="image-20220611191100150" style="zoom:50%;" />

- 独立编址：将I/O端口进行独立编址，因此I/O端口的地址和储存单元的地址是有可能相同的。依靠指令的类型来区分是哪一种。
- 两种编址方式的优缺点看图

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206111909028.png" alt="image-20220611190911560" style="zoom:50%;" />

### I/O接口的类型

- 主要注意一下在内部接口那一侧数据总是并行传送的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206111921473.png" alt="image-20220611192114124" style="zoom:50%;" />

## 7.4.1程序查询方式

### 流程图

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112053076.png" alt="image-20220611205316663" style="zoom:50%;" />

### 接口结构

- 一次传送数据只能有一个字是因为数据是存放在CPU的寄存器中的，受寄存器的位数限制

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112056944.png" alt="image-20220611205604635" style="zoom: 50%;" />

### 例题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112103373.png" alt="image-20220611210342849" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112144839.png" alt="image-20220611210451416" style="zoom:50%;" />

## 7.4.2 中断系统

### 中断的基本概念

- 外中断又可以分为可屏蔽中断和不可屏蔽中断，不可屏蔽中断即使禁用了中断也会被响应。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112143688.png" alt="image-20220611214331263" style="zoom:50%;" />

- 内中断又可以分为三类：
  - 陷阱
  - 终止
  - 故障
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112146017.png" alt="image-20220611214606622" style="zoom:50%;" />

### 中断请求标记

- 用于CPU判断发出的中断是哪一种中断。
- 每个中断源都有一个中断请求标记触发器与之对应，用来标志这个中断源是否有中断请求。
  - 这个中断请求标记触发器可以集成在CPU中，所有中断源的触发器组成一个类似数组（寄存器？）的东西
  - 也可以每个中断源的中断请求标志触发器与中断源的硬件直接集成，如打印机的中断请求标志触发器和打印机集成。
- 注意CPU响应中断的三个条件
  - 条件三可以说就是中断判优问题
- CPU响应中断的时间是每条指令执行完毕的时候，也可以说是每条指令执行结束之前。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112149186.png" alt="image-20220611214926762" style="zoom:50%;" />

### 中断判优问题——实现

- 硬件实现使用逻辑门电路，制造一个叫硬件排队器的东西，这种东西其实都可以自己试着去设计一下。
  - 图上给了个例子。说明这种硬件实现是怎么工作的。
  - 也可以列出它的真值表，写出逻辑表达式，来设计逻辑门电路。
  - 
- 软件实现通过查询程序

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112156600.png" alt="image-20220611215610226" style="zoom: 50%;" />

### 中断判优——优先级设置

- 具体的看图

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112203867.png" alt="image-20220611220302401" style="zoom: 50%;" />

### 中断处理过程

1. 当前指令执行结束，查询到有中断请求需要响应，此时PC的值为K+1。
2. 中断隐指令保存PC现有的值，同时将PC的值改为中断服务程序的入口地址，**中断隐指令只做了关中断，并没有做保存犯罪现场的事情。**
3. 执行完中断服务程序，恢复PC的值，回到原有程序。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112204794.png" alt="image-20220611220436426" style="zoom:50%;" />

### 中断隐指令

- 关中断是为了保证中断服务程序保存当前现场的时候不被新的中断所打断。
  - 保存现场：指保存当前CPU中的所有有关状态等。
- 保存断点就是保存PC原有的值。关中断和保存断点没有固定的先后顺序，可能是并行执行的。
- 引出中断服务程序就是将PC的值修改为中断服务程序的入口地址。
- 给出入口地址的两种方法：
  - 软件查询法，类似中断判优的软件查询的流程
  - 硬件向量法

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112211710.png" alt="image-20220611221123331" style="zoom:50%;" />

### 硬件向量法

- 将中断服务程序的入口地址保存在主存中。
- 向量地址：中断服务程序的入口地址的地址。
  - 中断类型号和向量地址是有一个固定的倍数关系的，所以给出中断类型号也可以找到对应的向量地址，从而找到相应的入口地址。
- 工作过程：
  1. 硬件排队器输出中断源，作为中断向量地址形成部件的输入
  2. 中断向量地址给出入口地址所在的内存地址，由此索引到相应的内存单元
  3. 找到相应的内存单元后即可找到中断服务程序的入口地址，就是内存单元保存的数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112218110.png" alt="image-20220611221845722" style="zoom:50%;" />

### 中断处理过程——中断服务程序

- **隐指令并没有做保存CPU的所有状态的工作，而是由中断服务程序完成，隐指令只是做了关中断来保证这个保存犯罪现场的工作不被新的中断打断**
- 保存现场可以使用堆栈也可以使用其他寄存器，这个参见CSAPP。使用堆栈保存当前现场的值的时候，恢复现场的时候就需要出栈指令。
- 执行完中断服务之后，中断服务程序需要恢复现场，并修改PC的值回到原来的断点处。
- **由于中断服务程序其实本质上也是一个普通的程序，所以它也可以被其他中断所打断，这就是多重中断**。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112232337.png" alt="image-20220611223255004" style="zoom:50%;" />

- 没有考虑多重中断的情况下的流程图是这样的：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112236111.png" alt="image-20220611223656790" style="zoom:50%;" />

- 多重中断大概是长这样：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112237206.png" alt="image-20220611223737814" style="zoom:50%;" />

### 单重中断与多重中断

- 流程表格从上往下看
- 多重中断的从上往下第一次开中断是为了允许中断服务程序执行的过程中能够响应新的中断
- 多重中断的第二次关中断是为了保证恢复现场和屏蔽字的时候不被打断
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112239854.png" alt="image-20220611223944497" style="zoom:50%;" />

### 中断屏蔽技术

- 屏蔽字存在的意义就是规定哪些中断作为新中断时可以打断现有中断，哪些中断作为新中断时不能打断现有中断。
- 其他的结论直接看图，很清楚。硬件的原理可以不看。 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112243810.png" alt="image-20220611224358318" style="zoom:50%;" />

### 中断屏蔽例题

- Ａ能屏蔽谁，就在谁那一位下取１，然后就可以得到屏蔽字。其他同理。
- 重点关注一下第二问。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112249756.png" alt="image-20220611224924352" style="zoom:50%;" />

### 中断作用总结

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112252627.png" alt="image-20220611225211288" style="zoom:50%;" />

## 7.4.3 I/O：程序中断方式

- 流程：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112300850.png" alt="image-20220611230009468" style="zoom:50%;" />

### 例题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112304538.png" alt="image-20220611230412115" style="zoom:50%;" />

## 7.4.4 I/O：DMA方式

### DMA控制器

- DMA的存在进一步解放了CPU。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112309057.png" alt="image-20220611230916646" style="zoom:50%;" />

- DMA的结构：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112312479.png" alt="image-20220611231255948" style="zoom:50%;" />

### DMA传送过程

1. CPU做预处理：
   1. 将主存的起始地址写入AR
   2. 将I/O设备的地址写入DAR（DeviceAR）
   3. 将要传输的数据的个数写入WC（Word Counter？）
2. DMA完成数据传输：
   1. 设备将数据写入DR，DR写满后DMA请求触发器发出DMA控制器请求。
   2. DMA控制器向CPU发出总线请求，占用总线。
   3. DMA控制器接管总线后完成一次数据传输
3. 后处理

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112316343.png" alt="image-20220611231624927" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112315639.png" alt="image-20220611231545274" style="zoom:50%;" />

### DMA传送方式

- 看图即可，信息量足够。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112323141.png" alt="image-20220611232307615" style="zoom:50%;" />

### DMA方式的特点



<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112324811.png" alt="image-20220611232414379" style="zoom:50%;" />

### DMA对比中断

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112333294.png" alt="image-20220611233324950" style="zoom:50%;" />

### 例题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112335512.png" alt="image-20220611233547024" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/NewPicBed0/master/202206112337532.png" alt="image-20220611233733079" style="zoom:50%;" />
