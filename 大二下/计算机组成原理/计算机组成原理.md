# 第一章 计算机系统概述

## 1.1 计算机的发展

- 关注下硬件的发展

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282024090.png" alt="image-20220428202438903" style="zoom: 50%;" />



## 1.2.1 计算机硬件的基本组成

- 存储程序的概念：
  - 主存储器：指的是内存，不是硬盘。是那个16G的，不是那个512G的
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282026638.png" alt="image-20220428202642549" style="zoom:50%;" />

- **在计算机系统中，软件和硬件是等效的。**

  - 同一个功能，既可以用软件实现，也可以用硬件实现。
  - 软件实现成本低，人效高，效率低。
  - 硬件实现则效率高，人效低。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282035393.png" alt="image-20220428203529303" style="zoom: 80%;" />

- 传统的冯诺依曼式计算机的特点：
  - 指令和数据都是以二进制的形式表示的。
  - 指令和数据以同等的地位存于存储器，可按地址寻访。
  - 计算机由五大部件构成。
  - 指令由操作码和地址码构成。
    - 操作码指定进行什么操作。
    - 地址码指定数据存放的地方。
  - 存储程序。
  - 以运算器为中心。I/O设备与存储器之间的数据传输通过运算器完成。
- **现代计算机**：
  - 以存储器为中心。
  - CPU = 运算器 + 控制器
  - 控制器负责解析指令，并指挥运算器完成相关的运算。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282044818.png" alt="image-20220428204404692" style="zoom:50%;" />

## 1.2.2 认识各个硬件部件

### 主存储器的基本成（内存）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282109435.png" alt="image-20220428210916330" style="zoom:50%;" />

- 内存：
  - 用于存放数据的东西叫存储体。
    - 存储体由编好码的（也即是地址）存储单元组成，每个存储单元可以存放一串二进制数据（比如一字节）。
    - 储存字：存储单元中的二进制代码。
    - 存储字长：一个存储单元存放的二进制串的位数（一般是8比特）。
      - 注意区分字和字节，不是同一个概念。
    - 存储元：用来存储一个比特的电子元件。
  - 地址寄存器（MAR）：存储内存地址，这个地址可以是从这里数据的，也可以是从这里读数据的
    - **可能会被集成到CPU中**
    - 要从内存的哪个地方取数据
    - 或者将数据写入内存的哪个地方
    - **地址寄存器的位数也反映了内存的大小，也就是存储体中存储单元的个数。**
      - 比如地址寄存器是16位的，那么就有$2^{16}$个存储单元。
  - 数据寄存器（MDR）：存储数据，这个数据可以是从内存里取出来的，也可以是要写入内存的。
    - **可能会被集成到CPU中**
    - **存的东西，可能是计算要用的数据，也可能是要执行的一条指令。**
    - 从内存里取出数据，然后放置在数据寄存器中。
    - 把数据先放置在数据寄存器中，然后把存在这里的数据写入内存。
    - **数据寄存器的位数应该和存储单元的存储字长是一致的，比如一个存储单元存八位，那么数据寄存器也是八位**。

### 运算器的基本组成

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282111092.png" alt="image-20220428211134944" style="zoom: 50%;" />

### 控制器的基本组成

- 当初计导大作业的那些寄存器终于知道都在哪里了。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204282113541.png" alt="image-20220428211321407" style="zoom: 50%;" />

## 1.2.3 计算机系统的层次结构

### 微指令

- 机器只能识别二进制的机器指令，比如乘法指令，加法指令。
- 但是由硬件(CPU)直接执行的是粒度更细的微指令，一条机器指令还要更进一步地细分为多条微指令。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011332759.png" alt="image-20220501133251607" style="zoom: 50%;" />

### 汇编语言

- 直接使用机器语言编写程序过于不方便，所以又出现了汇编语言。
  - 汇编语言也不是机器能够直接识别的指令，要经过汇编器将汇编程序翻译成机器指令才可以。

### 高级语言

- 出于同样的理由出现了更高级的编程语言。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011336292.png" alt="image-20220501133641097" style="zoom: 45%;" />



## 1.3 计算机的性能指标

- CPU主频：CPU内数字脉冲信号振荡的频率。
  - 主频和CPU的时钟周期是倒数关系。
- CPI(Clock cycle per Instruction)：执行一条指令所需的时钟周期数。
  - 微观下来考虑意义不大，能够影响一条指令的CPI的因素太多。
  - 不同的指令CPI不同，同一条指令的CPI也可能发生变化。
  - 一条指令的执行时间等于其CPI与CPU时钟周期的乘积。
- 指令条数 * 平均CPI / CPU主频 = 执行完所有指令所需的总时间，也叫CPU时间。
- IPS(Instruction Per Second)：每秒执行多少条指令。
  - IPS = 主频 / CPI = 一秒相当于的时钟周期数 / 一条指令需要的时钟周期数
  - KIPS、MIPS
- FLOPS(Floating-point Operations Per Second)：每秒执行多少次浮点运算
  - KFLOPS、MFLOPS

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011411126.png" alt="image-20220501141123050" style="zoom:50%;" />

- 数据通路带宽、吞吐量、响应时间：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011420871.png" alt="image-20220501142028725" style="zoom: 60%;" />
- ![image-20220501142615080](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205011426154.png)



# 第二章 数据的表示和运算

## 2.1.1 各种进制及其之间的转换

- 其他进制转十进制：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021148801.png" alt="image-20220502114818705" style="zoom: 50%;" />
- 十进制转其他进制：
  - 分为整数部分和小数部分分别求取。
  - 整数部分使用短除法。其本质如下图：
    - 余数$K_0$就是用$r$进制表示的情况下的最低位
    - 然后接着用商去除以进制基数$r$，得到次低位，以此类推，直到商为0。
    - ![image-20220502115320326](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021153433.png)
  - 小数部分使用乘以进制基数，取积的整数部分的方法。本质和上面的类似，见下图：
    - 小数部分乘以进制基数，得到的积留下整数部分，再拿积剩余的小数部分去继续乘以进制基数。
    - 得到的积的整数部分是小数部分的更高位。
    - 有时候这个过程可以一直循环下去，因为可能是无限小数。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021202804.png" alt="image-20220502120234704" style="zoom: 50%;" />
    - ![image-20220502115728353](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021157447.png)
- 二进制和八进制、二进制和十六进制之间的相互转换：
  - 八进制和十六进制之间的转换则通过二进制做媒介。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021149083.png" alt="image-20220502114944951" style="zoom:50%;" />

### 真值和机器数

![image-20220502120412640](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021204707.png)

## 2.1.2 BCD码



- BCD：	Binary-Coded Decimal，使用二进制编码的十进制
- 计算机处理8421BCD码的方法：8421码是有权码，每一位编码的权值是固定的。
  - 先将两个数对应的编码直接相加，得到的结果分两种情况：
    - 如果这两个数相加的值在0到9的区间内，那么BCD码相加得到的结果就是正确的结果。
    - 如果这两个数相加的值不在0到9的区间内，那么给编码相加得到的结果加上一个6的BCD码（0110），得到的就是和的正确编码。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021217333.png" alt="image-20220502121759209" style="zoom:50%;" />

- 关于余三码和2421码：
  - **余三码是无权码，而2121码则是对每一位的权值做了重新定义**。
  - **2421码对大于等于5的数的编码方式做了人为规定，最左边第一位一定是1**
    - 因为对于2121码来说，5有两种表示5 = 2 + 2 + 1 = 4 + 1
    - 采用5 = 4 + 1 编码，得到的是5的编码是0101，和BCD码是一样的。
    - 所以为了避免歧义，就规定了大于等于5的数的编码最左边第一位一定是1。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021220424.png" alt="image-20220502122046284" style="zoom:50%;" />

## 2.1.3 字符与字符串

- 英文的表示：ASCII码

### 汉字的表示与编码

- 区位码看做一个94*94的二维矩阵，两个区位码相当于坐标轴的两个坐标，可以定位到一个汉字。
- 给区位码（0到93）的每个字节加上32，使得编码从32开始，避开ASCII的通信和控制字符，得到国标码。
- 给国标码（32到125）的每个字节加上128，避开ASCII码的其他字符，得到汉字机内码。
  - 机内码就是内存中存放汉字时使用的实际编码。
  - 由于ASCII码只用了一个字节中的低7位，所以，这个首位(最高位)上的“1”就可以作为识别汉字编码的标志，计算机在处理到首位是“1”的编码时就把它理解为汉字，在处理到首位是“0”的编码时就把它理解为ASCII字符。
- 输出码可以理解为对汉字的图像的像素编码。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021405204.png" alt="image-20220502140520993" style="zoom:50%;" />

### 字符串

- 按地址递增的顺序看，先遇到最高有效字节就是大端模式，先遇到最低有效字节就是小端模式。
- 注意汉字使用的是机内码来保存。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021420954.png" alt="image-20220502142014773" style="zoom:50%;" />



## 2.1.4 奇偶检验码

### 计算机硬件如何实现奇偶校验

- 计算校验位：
  - 偶校验：对给定的比特串进行连续异或，得到最终的结果就是校验位。
    - 对收到的编码进行检错：对收到的比特串进行连续异或，结果不为零就说明一定发生了错误。
    - 结果为0也不能百分之百确定没有发生错误。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021448275.png" alt="image-20220502144838132" style="zoom:50%;" />
  - 奇校验的硬件实现：
    - 校验位的计算：对偶校验校验位的计算结果取个非。
    - 对收到的编码进行检错：也是对偶校验情况下的计算结果取非，结果不为1就说明一定出错。
    - 同样只能百分百否定，但不能百分百肯定。

## 2.1.5 汉明码

## 2.1.6 循环冗余校验码

## 2.2.1 定点数的表示

- 定点数：小数点的位置固定不变，比如$114.514$
- 浮点数：小数点的位置不固定，比如使用科学计数法，随着阶码的变化小数点位置也变，$1.14514 \cross 10^2、11.4514 \cross 10^1$

### 无符号数的定点表示

- 没什么好说的，注意一下无符号都是整数就行了

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021501529.png" alt="image-20220502150138362" style="zoom:50%;" />

### 有符号数的定点表示

- **这里既有整数，也有小数，并且我们规定小数的小数点的位置是固定的。**
- 定点整数的小数点在最低位的后面隐含，定点小数的小数点在最高位的左边隐含。
  - 如果一个小数既有整数部分也有小数部分，就分开保存整数部分和小数部分
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021541594.png" alt="image-20220502154138483" style="zoom:50%;" />

#### 原码

- 用原码表示定点数的时候，真值为0会同时有正零和负零的两种编码。
  - 符号位为1，尾数全0，负0
  - 符号位为0，尾数为0，正0
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021548279.png" alt="image-20220502154835169" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021544477.png" alt="image-20220502154451287" style="zoom:50%;" />



#### 反码

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021551090.png" alt="image-20220502155151909" style="zoom:50%;" />

#### 补码

- 由原码求补码：
  - 正数的原码和补码是一样的
  - 负数：
    - 先求原码。
    - 对原码的尾数位全部取反，得到反码，**符号位保持不变**。
    - 将反码加一（考虑进位），得到补码。
- 由补码求原码：
  - 正数的补码和原码是一样的。
  - 负数：先对补码的尾数全部取反，然后再加1，得到原码。
- 由$[x]_补$快速求$[-x]_补$:
  - **符号位和尾数**都全部取反，然后再末位加一。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021601939.png" alt="image-20220502160146732" style="zoom:50%;" />

#### 移码

- 在补码的基础上将符号位取反，**只能用于表示整数**
- **补码的0也不存在正0负0的情况**
- 移码很方便硬件判断两个数的相对大小。
  - 将移码比特串看做一个无符号数的话，两个移码的相对大小和其对应真值的相对大小是一样的。
  - 随着真值的递增，移码所对应的无符号数值也是逐渐增大的
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205021607119.png" alt="image-20220502160725972" style="zoom:50%;" />

## 2.1.2 原码补码反码的作用

- 补码：让减法操作天然的变成了加法操作。
  - 减去一个数就是加上它的补码。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022001881.png" alt="image-20220502200055657" style="zoom:50%;" />

## 2.2.3 移位运算

### 算术移位

##### 原码定点整数

- 不管是左移还是右移，移的次数太多都会丢失精度。

- 右移：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022103884.png" alt="image-20220502210306713" style="zoom:50%;" />
- 左移：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022104012.png" alt="image-20220502210458863" style="zoom:50%;" />

##### 原码定点小数

- 左移和右移都和原码定点整数是一样的

##### 反码的算术移位

- 正数的反码和原码是一样的，所以正数的反码移位和原码移位的相同
- 负数：可以从借助原码来理解，负数的反码对应的原码在移位之后要补的是0，补了零之后的结果的反码，补的零要取反变成一。
  - 所以负数的反码在移位时，需要补的是1，且该丢弃的丢弃，丢弃的部分和原码没什么区别。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022111871.png" alt="image-20220502211133749" style="zoom:50%;" />

##### 补码的算术移位

- 正数的补码和原码是一样的，所以正数的补码移位和原码相同
- 负数的看图：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022120180.png" alt="image-20220502212015033" style="zoom:50%;" />

### 逻辑移位

- 逻辑移位，不管左移右移都直接补0，要舍弃的位直接舍弃

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022122408.png" alt="image-20220502212256272" style="zoom:50%;" />

### 循环移位

- 就是原本移位的时候要舍弃的那一位，给它放到移位的时候空出来的位置上去
- 带进位位的循环移位就是把循环位也当做是数位的一位。
- 可以用于大端法和小端法的转换

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022136610.png" alt="image-20220502213644455" style="zoom:50%;" />



## 2.2.4 加减运算和溢出判断

### 原码的加减法

- 计算机内不会直接使用原码来做加减法。逻辑很复杂
  - 所以通常都是使用补码

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022216374.png" alt="image-20220502221615241" style="zoom:50%;" />

### 补码的加减法

- **加法就直接拿两个补码去加，符号位也参与运算**,加就是普通的二进制加法。
- 减法就转变成加上被减数的相反数就可以。
- 还要考虑溢出问题。最后两个例子都溢出了。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205022226599.png" alt="image-20220502222627410" style="zoom:50%;" />

### 溢出判断（补码）

- **只有两个相同符号的数相加时，才可能会发生溢出。**
  - 上溢：正数 + 正数 = 负数，这种情况下是两个正数之和过大，往上比上限还大，所以叫上溢。
  - 下溢：负数 + 负数 = 正数，这种情况下是两个负数之和过小，往下比下限还小，所以叫下溢。
  - **正数 + 负数是不会溢出的**。
    - 因为和数肯定小于原来的正数而大于原来的负数，原来的两个加数都没有溢出，和数夹在二者之间自然也就不会是溢出的。
  - **发生上溢，则来自最高数值位的进位一定是1，因为只有这样，才能使两个加数的0符号位加上进位1，得到和数的符号位变为1**
  - **发生下溢，则来自最高数值位的进位一定是0，因为只有这样，才能使两个加数的1符号位加上进位0，得到和数的符号位变为0**
  - 方法二和方法三实际上就是基于上述两点。
- 因为最终减法也会转化成加法，所以我们只需要判断加法的溢出即可。
- 计算机硬件如何判断溢出：
- 方法一：采用一位符号位，$A_S$和$B_S$是两个加数的符号位，$S_S$是运算结果的符号位。
  - 判断溢出的布尔代数表达式为$V = A_SB_S\bar{S_S} + \bar{A_S} \bar{B_S} S_S$
    - $A$的符号位为$1$，$A_S$取值为$1$，其他几个也是相同规则。
    - 这个逻辑表达式用与或非门很方便使用硬件实现。

  - $V = 0$则无溢出，$V = 1$则有溢出。
  - $V = 1$解析一下就是两种情况：
    - $A_SB_S\bar{S_S}= 1$，也就是$A_S = 1\and B_S = 1 \and S_S = 0$，就是两个加数为正数，而得到的结果为负数，发生了上溢。
    - $\bar{A_S} \bar{B_S} S_S = 1$，也就是$A_S = 0 \and B_S = 0 \and S_S = 1$，就算两个加数为负数，而得到的结果为正数，发生了下溢。
    - 而溢出无非就是这两种情况之一。

- 方法二：采用一位符号位，根据数据位进位情况判断溢出
  - 上溢：符号位进位为0而最高数值位进位为1。
    - 最高数值位的进位指的是数值位向符号位进的那一位。
    - 符号位进位指的是那个进位位寄存器的值，也就是符号位向更高位产生的进位。

  - 下溢：符号位进位为1而最高数值位进位为0。
  - 也就是符号位的进位和最高数值位的进位不同，就发生了溢出，采用一个异或门实现即可。
  - 因为溢出就两种情况，正+正 = 负，或者负 + 负 = 正。
    - 第一种情况下，两个加数符号位都为0，在最高数值位进位为1的情况下，两个符号位加上来自最高数值位的进位，会使得最终结果的符号位为1，也就是最终结果变成了负数，发生上溢。而这种情况下，符号位的进位为0。
    - 第二种情况下，两个加数符号位都为1，在最高数值位进位为0的情况下，两个符号位加上来自最高数值位的进位，会使得最终结果的符号位为0，也就是最终结果变成了正数，发生下溢。而这种情况下，符号位的进位为1。
    - 最终结果指的是两个数相加得到的和。

- 方法三：采用双符号位：
  - $S_1$和$S_2$，$S_1$是和数预期的符号，$S_2$是和数实际得到的符号。
  - 还是因为溢出就两种情况，正+正 = 负，或者负 + 负 = 正。
    - 第一种情况下，两个加数符号位为00，如果发生溢出那么来自最高数值位的进位会为1，使得从左往右第二个符号位变为1。
      - 而从左往右第一个符号位在发生上溢的情况下，肯定是0的。这个0就记录了预期的正确符号。
      - 第二个符号位就记录了实际得到的符号。
      - 所以双符号位其实是可以拿来纠错的？

    - 第二种情况类似，就不细写了。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031503988.png" alt="image-20220503150357781" style="zoom:50%;" />


### 符号扩展

- **注意，扩展是在原有的符号位和最高数值位的中间添加新位**。

- 正整数：符号位为零，直接在原有的八位的后面填零
- 对于整数，**补码的情况下，扩展都是直接用符号位在开头扩展即可**。
- 对于定点小数：
  - **由于要保证扩展后的各个位的位权不变，所以应该在右侧末尾补位**，而不是符号位和数值位之间补位。
  - 负定点小数的补码符号扩展可以记不住的话可以直接使用原码加反码进行推导。
  - **负定点小数的补码进行扩展时在末尾添零**。
  - 正定点小数的补码进行扩展时在末尾添零。

![image-20220503150630921](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031506130.png)

## 2.2.5 乘法运算

### 原码的乘法

- 这里是原码的乘法：**符号位是不参与运算的**

  - 对于原码的乘法我们符号位单独处理，然后使用两个因子的绝对值再去做乘法，得到的值再添加上符号。
  - 这样就可以将所有的乘法都转化成两个正数的乘法
  - 将两个因子的符号位进行异或，即可得到乘积的符号，因为异或是相同得零，相异得一，恰好对应了乘法的同号得正异号得负。

- 关于一位乘法：

  - 可能还是视频里讲的清楚。如果描述不清楚就还是看原视频吧。
  - 首先有一个寄存器叫ACC，累加器，这个寄存器在开始计算之前会被清零，用来存储乘积的高位或运算结果。
  - 然后有一个有一个普通的通用寄存器叫X，这个寄存器用于存放被乘数，就是手算的时候写在上面的那个。
  - 然后还有一个寄存器叫MQ，这个寄存器用于存放乘数，还有乘积的低位。
  - 一位乘法的过程如下：**请注意，X、MQ存的都是两个乘数的绝对值，ACC的结果也就是乘积的绝对值**
    1. 首先将ACC清零。然后对MQ中的乘数的最低位（记作ｑ）进行与Ｘ的一位乘法。
    2. 引入规则：如果q的值为1，那么就让ACC加上X，如果q的值为0，那么ACC就加上一个0。
    3. 在进行完一轮加法后，ＭＱ右移一位，将已经进行过乘法的老ｑ舍弃，同时原先新的ｑ挪到最右侧最低位。
    4. 同时ACC也右移一位，此前MQ右移在其左侧腾出的空位，用于存放从ACC右移出来的数，ACC的空位则补0。
    5. 然后进行下一轮的一位乘法和加法，直到MQ中乘数的符号位到达了MQ的最低位。
    6. 然后对两个乘数的符号位进行异或，得到乘积的符号位，并添加到符号位（ACC最左边）上去。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031556117.png" alt="image-20220503155656937" style="zoom:50%;" />

- 一个手算的例子：

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031556976.png" alt="image-20220503155609763" style="zoom:50%;" />

### 补码的乘法

- 也是一位乘法，**但是符号位是参与运算的**
- 整个的运算过程是和原码的一位运算差不多相同的，只不过引入的规则和原码引入的不一样。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031624291.png" alt="image-20220503162432093" style="zoom:50%;" />

- 关于辅助位：是给ＭＱ寄存器多加了一位，出于寄存器长度一致性的考虑，会给X寄存器和ACC寄存器也多加一位，多加的一位补符号位。
  - 因此X保存的数其实采用的是双符号位的补码。
  - 这里多出来的一次加法其实是ＭＱ中保存的补码的符号位参与了运算（原码中符号位是不参与运算的）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031625940.png" alt="image-20220503162557702" style="zoom:50%;" />



## 2.2.6 除法运算

### 原码的除法运算

- 首先有一些前提，就是二进制的除法，商的某一位要么是0，要么是1，（使用竖式手算的时候）商0的时候，余数减去的是0，商1的时候，余数减去的是除数本身。
- 如果是定点小数的除法，由于定点小数是无法表示大于1的数的，所以我们会隐式的要求被除数的绝对值要小于除数的绝对值（否则商的绝对值会大于一）

#### 原码除法：恢复余数法

- 与原码的乘法原理类似。

- 会有一个寄存器ACC，保存被除数和余数(余数其实不就是下一次求商的被除数么)

- 还有一个寄存器MQ，保存的是商，当然，也会通过类似的移位的方法来模拟手算的过程。

- 最后还有一个寄存器X，保存的是除数。

- 计算的过程：**要注意这里也是只保存了被除数和除数的绝对值，计算出来的也是商的绝对值**

  1. 首先将保存商MQ的寄存器清零，然后把MQ的最低位（最右侧）记作位置q。同时将ACC保存被除数，X保存除数。

  2. 在Q位上保存的是当前我们求商的那一位。

  3. 首先计算机默认商1，也就是将Q位填1，然后由ALU去更新ACC的值为得到的余数。

     - 如果ACC的新的值符号位为0，也就是正数，也就是新得到的余数大于零，那么商1是正确的。

     - 如果ACC的新的值符号位为1，也就是负数，也就是新得到的余数小于零，那么商1是错误的，ALU将会将余数恢复到原有的值，并且改商为0。这就是叫恢复余数法的原因。
     - 新得到的余数就是用ACC现存的值减去通用寄存器X的值，也就是ACC~新~= ACC~老~ - X = ACC~老~ + $[-x]_补$（因为X保存的是除数的绝对值哈）
     - 恢复余数就是新得到的错误的余数再加上除数的值即可。
     - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032029734.png" alt="image-20220503202949595" style="zoom:50%;" />

  4. 然后将ACC整个左移一位，低位补零，ＭＱ也左移一位，低位补０，然后回到３，直到求得的商的位数满足了精度要求，停止。

  5. 然后对被除数和除数的符号位进行异或，得到商的符号，把得到的符号位填充到ＭＱ的符号位（MQ的最左边）去。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205031955230.png" alt="image-20220503195511996" style="zoom:50%;" />

#### 原码除法：不恢复余数法（加减交替法）

- **符号位仍然是采用单独异或处理的方法，下面计算的仍然是商的绝对值**。

- 在恢复余数法中，当我们发现商1新得到的余数是负值时，我们会做的事情有：
  - 此时ACC的值是新得到的负余数，记作$a$，X保存的是除数，记作$b$。
  - 我们需要做的是恢复余数，并且将商修正为0。
  - 也就是说，恢复余数后，ACC的值是$a + b$，对应的商位是0。
  - 然后进入下一位商的计算，先对ACC进行一次逻辑左移，此时ACC的值是$2a + 2b$
  - 然后计算机默认商1，得到新的余数$2a + b$。然后进入判断余数的符号的那一步。
- 因此不恢复余数法的改进就是，当得到负的余数时，直接将商位修正为1，并让ACC左移一位，然后加上除数的值，置为下一次的余数$2a + b$。
  - 如果$2a + b$是负的呢？直接商零，用ACC左移一位再加上X的值。
  - 如果是正的那就说明商1是对的，和恢复余数法的处理是一样的。
    - 也就是直接计算新的余数，用ACC左移一位再减去X的值。
  - 若最终的余数为负，还是要进行一次恢复余数。

![image-20220503205122385](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032051610.png)

### 补码的除法运算

- 补码的符号位也参与运算，其他的和原码的加减交替法完全一样。
- 还有就是补码的商的最后一位商恒置为1，不去判断商1是否正确，只是为了硬件设计省事。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032101334.png" alt="image-20220503210142115" style="zoom:50%;" />



## 2.2.7 强制类型转换

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032111990.png" alt="image-20220503211131764" style="zoom:50%;" />



## 2.2.8 数据的存储和排列

### 大小端模式

- 大端模式和人类的阅读习惯是保持一致的。
- 小端模式则方便机器处理数据，因为机器处理数据一般也是从低地址往高地址读取数据，所以采用小端法的时候，机器先读入的是低位字节。
  - 比如CPU要做加法时是从低位开始相加，这个时候如果最先读入的是低位的数据就会快些。



### 边界对齐（内存对齐）

- 不管是哪一种寻址方式，最终使用的都是按字节编码的地址。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205032120694.png" alt="image-20220503212002503" style="zoom:50%;" />

## 2.3.1 浮点数的表示

- 定点数的问题在于，定点整数和定点小数表示的范围是有限的，但我们又不能无限制的增加数据的长度。
- 而浮点数则可以解决这个问题。浮点数采用的思想类似科学计数法。
- 例如下面的例子，在失去一定精度的情况下，我们可以将表示这个数所需的数据长度大大缩短
  - 由于底数肯定是$10$，所以我们可以直接省略不写这个作为底数的$10$，而是直接用两个数来代替整个科学计数法，一个数代表小数部分，一个数代表指数部分（也就是它的阶）。
  - 阶码部分就是底数的次数，尾数部分就是科学计数法的小数部分，都各自带有符号。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041438579.png" alt="image-20220504143804336" style="zoom:50%;" />

### 浮点数的表示

- 浮点数其实就可以看做是以二进制为基础的科学计数法。
- 阶码部分就是2的次数，也就是科学计数法的那个底数2的阶。阶码的位数反映了浮点数的表示范围和小数点的实际位置。
- 尾数部分就是科学计数法的那个小数部分，尾数的位数越多，精度就越高。
- **阶码和尾数本身都是采用定点的方式保存的**。
- **阶码是定点整数，尾数是定点小数**
- 之所以叫浮点数，是因为对于同一个数，阶码取不同的值，小数点的位置是会浮动的。
  - 可以举一个十进制的例子，$114514$可以写成$11.4514 * 10^4$（阶码取4），也可以写成$1.114514 * 10^5$（阶码取5）。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041443484.png" alt="image-20220504144341284" style="zoom:50%;" />

###  浮点数尾数的规格化

- 解决的是因为尾数的位数不够而导致的损失精度问题。
  - 举个例子：有一个二进制的数，科学计数法记为$2^{10} * 0.00001101$。
  - 假如要用八比特的空间来存储，肯定是存不下的，但是这个数的小数部分是有很多无效位数的。
  - 所以我们让尾数左移5位，同时阶码减少相应的次数，得到$2^5 * 1.101$。精度不变，而尾数的位数减少。
  - 这样八位恰好可以存的下。
  - 这个操作就是浮点数的左规。
  - 右规就类似十进制的科学计数法，$302.15 * 10^1$规格化变为$3.0215*10^3$。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041501636.png" alt="image-20220504150105397" style="zoom:50%;" />

### 规格化浮点数的特点

- 浮点数的尾数可以使用原码表示，也可以使用补码表示。
- 使用原码表示尾数时，要遵循的规则：
  - 正数的尾数必须为$0.1xxxxxxxx$的形式，0是符号位，数值位的最高位必须为1。
  - 负数的尾数必须为$1.1xxxxxxxx$的形式，1是符号位，数值位的最高位必须是1。
  - 也就是说，使用原码表示尾数时，最高数值位一定是1。
  - 很好理解吧，总不可能最高数值位是0（二进制要么1要么0嗷），那不就是一个无效位了。。。
- 使用补码表示尾数时，要遵循的规则：
  - 正数的尾数必须为$0.1xxxxxxx$的形式，0还是符号位，最高数值位与符号位相反。
  - 负数的尾数必须为$1.0xxxxxxx$的形式，1还是符号位，最高数值位与符号位相反。
  - 这样的设计是出于简化硬件设计的考虑。
  - 对于给定的例子的尾数1.1110100，要将其规格化为$1.0xxxxx$的形式，只能把**小数点右移**(也就是数左移)到夹在两个1之间的那个零前面了。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041504632.png" alt="image-20220504150453386" style="zoom:50%;" />

### 关于浮点数的溢出问题

- 浮点数的表示范围也是有限的，只不过比定点数的表示范围要大了很多。
- 浮点数表示的小数也是有一个最低下限的。正数的尾数最小值只有$0.100000...$，负数的尾数的最大值是$1.100000...$
- 浮点数表示正数有一个范围，表示的负数也有一个范围，这两个范围可以看做是没有交集的。
- 所以会有四种溢出：
  - 超过正数的最大值：正上溢，系统给出一个异常。
  - 低于正数的最小值但还是一个正数：正下溢，当做机器零。
  - 高于负数的最大值但还是一个负数：负下溢，当做机器零。
  - 低于负数的最小值：负上溢，抛出异常。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041523363.png" alt="image-20220504152353220" style="zoom:50%;" />





## 2.3.2 IEEE754标准

- 标准化浮点数，本质上是为了解决跨平台的问题，将不同设备制造商对浮点数的解析和存储方式统一，使得不同机器之间可以交换数据。

### 阶码（使用移码表示）

- IEEE754标准中，阶码是用移码的形式来表示的，所以有关移码：
  - 移码：在补码的基础上将符号位取反即可。移码只能表示整数
  - 移码的定义：移码（二进制） = 真值（二进制值） + 偏置值（二进制值）。
  - 偏置值取$2^{n - 1}$，$n$为位数。此时移码恰好就是补码的符号位取反
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041552308.png" alt="image-20220504155243123" style="zoom:50%;" />

- IEEE754标准的偏置值取的是$2^{n-1} - 1$。

### IEEE754

#### 一般情况下的：（阶码不为全0也不为全1）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041604780.png" alt="image-20220504160443513" style="zoom:50%;" />

- 32位浮点数：1 8 23。64位浮点数：1 11 52。
- 在计算阶码的真实值时，将阶码的二进制的移码看做无符号数，然后减去偏移值就可以得到真正的幂的次数。
  - 反过来，计算阶码的移码时，可以用幂的次数加上偏移值，得到的数转换成二进制无符号数，就是对应的阶码的移码。
- **尾数部分使用的是原码，隐藏了整数部分的1**。尾数部分的原码缺少符号位是因为把符号位转移到了数符位，而尾数部分去掉了符号位。
- **阶码部分没有去掉符号位。**
- 十进制转浮点数的例子：<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041608737.png" alt="image-20220504160830548" style="zoom:50%;" />
- 浮点数转十进制的例子：<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041613538.png" alt="image-20220504161328360" style="zoom:50%;" />

#### 浮点数的最大值和最小值（除去特殊情况）

- 由于阶码的全1和全0都拿来表示特殊的情况（NaN或者无穷），并且计算幂次的实际值的时候是把阶码看做无符号数的。
- 所以阶码看做无符号数且不能为全1或者全0的情况下，阶码的最大值就是111111110，最小值就是0000000001。
- 最大值：最低位为0其他全为1。最小值：最低位为1其他全为零。



- 以32位的浮点数为例，阶码是8位，则阶码的最大值为11111110（十进制的254），最小值为00000001（十进制的1）
  - 再减去偏移量127，得到幂次的实际最大值127，实际最小值-126。
  - 然后再考虑尾数部分，由于尾数部分是隐含1的，所以最小尾数就是$1.00000000...$，最大是$1.1111111....$
  - 然后再考虑符号，负数肯定小于正数。
  - 因此浮点数的最小值是最大尾数乘以最大幂次再添个负号，最大值就是把符号去掉。
  - 而浮点数的**最小绝对值**则是最小尾数乘以最小幂次
- **浮点数是没办法表示绝对的0的，因为阶码部分肯定是正的，而尾数部分又是1.M，也肯定是正的，只能表示极小极其接近零的数**。
  - 所以要表示比最小绝对值还小的数，就需要用那些特殊用途。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041625357.png" alt="image-20220504162521163" style="zoom:50%;" />

#### 特殊情况

- 要表示那些比规格化的情况下的最小绝对值还小的数，就需要使用特殊的情况。
- 当阶码全为0时，**尾数部分也不视作是1.M的形式，而是视作0.M的形式，其幂次也固定视为-126，不是-127**
  - $1\leq E \leq 254$指的是将阶码看做是无符号数的情况。 
  - **当阶码全为0且尾数全为0时，根据符号位可以表示正负0。**
  - ![image-20220504181717148](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041817437.png)





## 2.3.3 浮点数的运算

### 加减运算

- 和十进制的科学计数法来类比一下：
  - 小阶向大阶对齐是处于硬件原因。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041824108.png" alt="image-20220504182416837" style="zoom:50%;" />
- 关于舍入：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041835449.png" alt="image-20220504183517155" style="zoom:50%;" />

### 强制类型转换

- **long转化为double是建立在long只有32位而double是64位的情况下的，如果long和double都是64位，转换会损失精度**。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041838585.png" alt="image-20220504183811423" style="zoom:50%;" />



## 2.4.1 ALU简介、加法器设计

- 介绍算术逻辑单元ALU，加法器的设计

### ALU

- 输入信号A和B是两个操作数，本质上是高低电平。
- 实例中：
  - $A_i、B_i$就是两个四位操作数输入的地方。
  - $M$表示进行哪一大类运算，是进行算术类运算还是逻辑类运算
  - $S_0$到$S_3$表明要进行大类中的哪一个小类运算（比如是算术运算类的加法）。
  - $F_0$到$F_3$是输出信号，输出ALU运算得到的结果。
  - 机器字长实质上就是指的ALU能一次处理多少位的单个数据。
  - 一般来说其他寄存器的位数会和ALU的位数保持一致，为了硬件适配，毕竟你输出一个4位的结果总要放到一个4位的寄存器去的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205041849300.png" alt="image-20220504184903067" style="zoom:50%;" />

### 一位全加器

- 一位全加器考虑的是一位上的加法，全的意思是考虑了来自低位的进位的值。
- 三个输入$A_i、B_i、C_{i-1}$，分别为第$i$位的两个加数，以及来自更低一位的进位值。
- 两个输出：
  - $S_i$：第$i$位的和（满2进1的时候本位的和为0）
  - $C_i$：第$i$位向更高位的进位。
  - $S_i = A_i \bigoplus B_i \bigoplus C_i$。本位的和就是两个加数的本位加上来自低位的进位，得到的和再去模二。
  - $C_i = A_iB_i + (A \bigoplus B_i)C_i$。当两个加数的本位都为1时（不管来自低位的进位是什么值），或者两个加数其中一个为1且来自低位的进位为1时，本位向高位进位。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205042050658.png" alt="image-20220504205042391" style="zoom:50%;" />

### 串行加法器

- 如何使用一位全加器来实现n位二进制数的加法。
- 每次输入两个加数的一位，然后加上来自进位触发器的低位的进位($C_i$)，得到向更高位的进位以及本位的和，前者保存在进位触发器中，后者则输入到另外一个寄存器保存，然后再输入更高一位的两个加数的位，如此循环。
- 进位触发器用于保存来自低位的进位，也就是$C_{i - 1}$
- 以下面的为例：
  - 第一轮，输入$A_i = 1、B_i = 0$，由于这是最低位，无进位，计算得到$S_1 = 1$，输出，并将进位$0$保存在进位触发器中。
  - 第二轮，输入$A_i = 1、B_i = 1$，进位触发器输入来自低位的进位$0$，计算得到$S_2 = 0$，输出，并将进位1保存在进位触发器中。
  - 第三轮，输入两个加数的第三低位的两个数，以及来自第二低位的进位，后面不多说。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205042107444.png" alt="image-20220504210733229" style="zoom:50%;" />

### 并行加法器

- 要计算$n$位的两个二进制数的加法，就把$n$个全加器串联在一起，低位的全加器的进位输出作为其相邻高位的全加器的低位进位输入。
  - 最低位的全家器输出$S_1$的同时，其向第二位的进位$C_2$也作为了第二位全加器的“来自低位的进位”的输入
  - 以此类推。
- 这样可以同时将一个加数的$n$位数据同时输入，但是每一级的进位都依赖于其前一级的进位。
  - 也就是说，第2位只有得到了来自第一位的进位输入之后，才能开始计算它本位的进位以及本位和。以此类推。
  - 也就是说，只有$S_i$的结果出来之后（也就是这一位向相邻高位的进位出来后），$S_{i+1}$才能开始计算。
  - 所以这个叫做串行进位的并行加法器。
  - 因此这样的加法器的计算速度取决于进位的产生和传递速度。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205042114255.png" alt="image-20220504211436019" style="zoom:50%;" />



## 2.4.2 加法器优化（留坑）

# 第三章 存储系统

## 3.1-3.2 主存简单模型和寻址概念

### 主存储器的简单模型

- 一个主存储器由三部分构成：
  - 存储体
  - 数据寄存器
  - 地址寄存器
  - **实际设计上俩寄存器可能会和CPU集成在一起**
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071832891.png" alt="image-20220507183239704" style="zoom:50%;" />
- 有关存储体：
  - 存储体是由很多个存储单元一排排构成。
  - 一排的存储单元又是由单个从存储元构成。
  - 存储元能够保存一比特的信息，有一个控制开关来控制对存储元的写入和读取。
  - 存储体的存储容量就是用存储体的行数乘以列数那么多个比特。
- 如下图，红色的线是一条控制线，它控制一整行的存储单元，给一整行的8个存储元同时发出读信号或者写信号
- 绿色的线可以看做是一条直接连接到寄存器的某一位上的电路，负责传输来自一个存储元上的电平信号（也就是0和1）
  - 绿色的线其实是负责传输它左侧的那一列存储元的信号的，但是每次只有那一列上的某一个存储元的信号能够有效。
  - 也就是说，在读取数据的时候，每次只能读取一整行存储单元的数据。
  - 这个由输入进来的控制信息实现，

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205051421659.png" alt="image-20220505142119344" style="zoom:50%;" />

- 一个主存的简单模型：

  - 有关控制信息
    - 有一个译码器将控制信息传入，每次只会有一个输出端口的控制信息是有效。
    - 如下图。

  - 数据寄存器通过绿色的线和存储体相连，绿色的线负责将从存储单元读取到的数据放入数据寄存器，或者将外界写入数据寄存器中的数据写入存储单元。
    - 数据寄存器还有与外界相连的绿色的数据线，负责从外界将数据写入数据寄存器，或者将从存储单元读取并存放在数据寄存器中的数据传递给外界。
    - **数据线的根数和数据寄存器的位数是相等的。**

  - 地址寄存器与译码器通过红色的线相连。
    - 同时还有与外界相连的地址线，地址线将地址写入地址寄存器。
    - **地址线的根数和地址寄存器的位数是相同的**。

  - 片选线类似开关，有高电平有效和低电平有效两种模式。
    - 高电平有效就是高电平时，整个电路工作。

  - 读控制线负责控制读操作和什么时候读。写控制线类似。
    - 由于读和写通常是互斥的（同一时间只能读或者写），所以可以将两条控制线合并为一条，称作读写控制线，决定当前操作是读出去还是写进来，以及什么时候。

  - 将这些东西封装起来，就得到一个存储芯片。

  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205052100183.png" style="zoom:50%;" />

- 将上面的简单主存模型封装一下，大概是这样的：
  - 地址线和数据线都是暴露在外的存储芯片的接口。
  - 片选线和读写控制线也是暴露在外的接口。
  - 译码驱动起的是增强信号的作用，比如以前控制第一个存储元的那个1，现在要控制第一整行存储单元，就需要对电平进行增强.(大概意思一下)
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061112265.png" alt="image-20220506111202028" style="zoom:50%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205052116338.png" alt="image-20220505211639024" style="zoom:50%;" />

### 寻址

- 下图每一小格是一个字节。假设总容量为1KB(1024字节)
  - 则需要十根地址线。
  - 可以按字节寻址、按字寻址、按半字寻址、按双字寻址。
  - 一个字这里是4字节。
  - 大端方式和小端方式看图。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061102405.png" alt="image-20220506110213019" style="zoom:50%;" />

## 3.3.1 半导体存储器RAM

### 半导体随机存储器

- 关于SRAM:
  - 使用触发器来存储信息，触发器是可以保持两个稳定的状态的，一个作为0，另一个作为1即可。
  - 对SRAM进行读出的时候，只需要查看SRAM的状态就好，不会对状态造成破坏，因此也就不需要回写操作。
  - 由于触发器可以保证两种稳态，所以也不需要对SRAM中的信息进行定期刷新。
  - SRAM通常将行地址和列地址分割为长度不相等的两部分，所以只能同时送行地址和列地址，整个地址放到寄存器里面。
  - 假设行地址加列地址总长度是10位，那么就需要10根地址线。
  - 由于SRAM在读取的时候不需要对信息进行回写操作，也不需要定期对信息进行刷新，所以运行速度快于DRAM。
  - 需要的元件更多所以集成度更低发热量更大成本更高。
  - 成本更高所以常用作高速缓存。
- 关于DRAM：
  - 使用电容的带电量作为两个状态表示0和1，假设电容充满电为1，电容不带电为0。
  - 由于对DRAM的读出是连接电容并检测是否有电流流出，所以假设里面存储的是1，读取之后电容中的电荷就全部流失了（破坏性的读出），所以要进行回写，将电荷充回去，保持存储的信息为1。
  - 由于DRAM的电容中的电荷即使不去读取也会自己快速流失，所以要对整个存储矩阵进行定期刷新。
  - DRAM的行地址和列地址被划分为长度相等的两部分，所以可以分两次送，先送行地址，再送列地址（反过来也可以吧，看情况）。
  - 能分两次送使得地址线能被复用，线的根数减少一半。
  - 假设行地址加列地址总长度是10位，那么只需要5根地址线。
  - 由于需要回写和刷新等操作，运行速度慢于SRAM。
  - 集成度高发热低成本低，所以常用作大容量的主存。
  - 目前主流的主存应该是采用SDRAM。 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061121513.png" alt="image-20220506112117158" style="zoom:50%;" />

### DRAM的刷新

- 刷新周期：由于DRAM的电荷持续周期一般是两毫秒，所以刷新周期也是两毫秒。
- 以行为单位，每次刷新一行存储单元（一行有多个存储单元哈，不是一行这一整行作为一个存储单元）。
- 由于行地址选通后可以同时选通一行存储单元，所以可以直接对一行进行刷新。
  - 刷新的时候传一个行地址就够了
- 刷新由硬件支持，不需要CPU支持，读出一行的信息之后重新写入，**占用一个读/写周期**。
- 在有容量扩充的情况下，存储器中所有芯片的同一行同时刷新。

- 关于三种刷新方式：
  - **由于在2毫秒内电荷不会完全流失干净，所以在这两毫秒内任意一个存储单元的信息都是可读的，所以只要在两毫秒内刷新一次即可**
  - 假定DRAM是128 * 128的矩阵，读/写周期为0.5微秒。
  - 则在2毫秒内，总共有4000个读写周期。
  - 分散刷新：
    - 将读写周期由0.5微秒扩大一倍，变为1微秒。
    - 实际的读写占一半，另外一半用来刷新需要刷新的某一行，不一定是当前读取的那一行。
  - 集中刷新：在2毫秒的时间内集中安排时间，将128行一次性全部刷新。
    - 128行刷新需要占用128个读写周期。
    - 因此2毫秒内的4000个读写周期内，前3872个读写周期用于读写。
    - 最后的128个周期专门用于刷新。
    - 专门刷新的那段时间内存储器无法被访问，称为访存死区。
  - 异步刷新：结合了前两种刷新。
    - 由于128行在两毫秒内都需要刷新一次，所以我只要保证在这两毫秒内完成128次刷新就可以了。
    - 也就是每隔2ms / 128 = 15.6 微秒，要进行一次刷新。
    - 也就是说，将2毫秒分为128段，每段15.6微秒，每段时间内完成对某一行的刷新操作。
    - 则每个15.6微秒内，有0.5微秒用于刷新的死时间，其他的15.1微秒都可以用来读写。
    - 通过指令的灵活安排，可以将死时间的影响直接消去（在死时间内干别的）。

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061832751.png" alt="image-20220506183214380" style="zoom:50%;" />

#### 为什么要使用行地址和列地址

- 假设使用原先建立的模型，只使用一个译码器，那么在地址的位数$n$比较大时，选通线的条数就非常大了。
  - 比如$n = 10$，那就需要1024条选通线来控制1024行存储单元。
  - 但是如果将DRAM的地址划分为行地址和列地址，并且将存储单元排列成矩阵的形式，将存储阵列划分成$2^{n/2}$行乘以$2^{n/2}$列，那么就可以使用类似坐标轴定位的方式来选通某个存储单元。
  - DRAM的行地址长度和列地址长度是相等的，则行地址译码器和列地址译码器都各自有$n / 2$位地址输入，选通线都是$2^{n/2}$条。
  - 总共需要的选通线的条数就变为$2 * 2^{n / 2} = 2^{n + 2 / 2}$条。如果取$n = 10$，则选通线条数由$1024$变为$128$条，直接缩小十倍。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061814182.png" alt="image-20220506181428874" style="zoom:50%;" />

### SRAM的读周期

- 一个菱形代表地址线传入的一个地址。
- CS是片选线，D~OUT~为数据线，在读的过程中负责输出从主存读取到的数据。
- 读的过程：
  - 首先地址线传入地址，但是并不是立刻开始读，因为通过地址线传输过来的信号可能不是同时到达的。
  - 所以要等一段时间（也就是第1和2根竖线之间的间隔），等地址信号稳定。
  - 然后片选线才开始打开，方便从存储矩阵读取数据。
  - 由于读取数据也需要一段时间，所以打开也会持续一段时间，直到信号稳定下来，然后关闭（第2个间隔）。
  - 开关关闭之后可能数据线上的信号还在传输，所以数据线上的信号会维持一段时间，地址信号也维持一段时间关闭。
  - 将数据从存储矩阵读取之后的那一段时间主要是为了保持数据的正确性，所以需要一段恢复时间。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061901456.png" alt="image-20220506190125125" style="zoom:50%;" />



### SRAM的写周期

- 和读周期是类似的。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061912538.png" alt="image-20220506191253241" style="zoom:50%;" />

## 3.3.2 半导体存储器ROM

- 首先纠正我的一个多年的误解：**只读存储器和固态硬盘之类的不完全是一个东西**
  - ROM其实可以看做是写了BIOS的地方，ROM在开机的时候告诉CPU，操作系统放在磁盘（辅存）的哪个位置，然后电脑就可以开机了。
  - 或者这么说，ROM就是负责在电脑开机的时候，告诉CPU，把辅存里的哪里的哪些内容放进RAM。
  - ROM在最开始出来的时候甚至是不可以写入的，只在出厂的时候被写入一次，所以叫$Read\ Only\ Memory$
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061926125.png" alt="image-20220506192606807" style="zoom:50%;" />

## 3.3.3 存储器基本概念

### 存储器的分类

- 辅存不能直接与CPU交流，主存与高速缓存与CPU直接交流
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061928067.png" alt="image-20220506192846801" style="zoom:50%;" />
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205061932338.png" alt="image-20220506193206025" style="zoom: 50%;" />

### 存储器的性能指标

- 关注一下存储速度的计算

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205062118167.png" alt="image-20220506211820871" style="zoom:50%;" />

### 存储器的层次化结构

- 主存与辅存是解决主存容量不够大的问题（以及主存的易失性问题？）
- 高速缓存和主存解决的是CPU和主存之间读写速度差距过大的问题。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205062120723.png" alt="image-20220506212028468" style="zoom:50%;" />



## 3.4.1 主存与CPU的连接

### 主存容量扩展——位扩展

- 增加存储器芯片的位数
  - WE是读写控制线，CS是片选线，$A_0$到$A_{15}$是CPU的地址线。
  - 存储芯片是8K * 1位的，8K说明有13条地址线。
  - 需要对储存容量进行位扩展的时候，就新增一块芯片，地址线都连接在CPU的地址总线上（红色）
  - 绿色的是CPU的输入输出线，和存储芯片的输入输出线一对一相连，看图。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071746746.png" alt="image-20220507174627481" style="zoom:50%;" />

- 如果要扩展更多位，就需要更多芯片
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071751645.png" alt="image-20220507175125415" style="zoom:50%;" />

### 主存容量扩展——字扩展

- 增加存储芯片的字数

#### 线选法

- $A_{13}、A_{14}$分别和两片存储芯片的片选信号相连，需要哪一块的时候就把哪一块的片选信号置为1，另一块置为0
  - 也就是说$A_{13}、A_{14}$两条线不能同时为1或同时为0，四个状态只用了两个。
  - 这种情况下地址空间是不连续的
- 数据线看绿色的，地址线看红色的，这也是决定了为什么需要两条不同的线选线。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071801120.png" alt="image-20220507180105814" style="zoom:50%;" />

#### 译码片选法

- 对上面的稍作一些改进，增加一个非门，就可以减少一根线的消耗。
  - 这本质上就是采用译码器了，如果新增更多的存储芯片使用一个译码器即可。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071807138.png" style="zoom:50%;" />



- 比如一个使用了四个存储芯片的字扩展：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071814137.png" alt="image-20220507181435839" style="zoom:50%;" />

### 主存容量扩展——字位扩展

- 以下图为例，CPU的数据线是八位的，单个的存储芯片是16K * 4位的。
  - 先以两片为单位进行位扩展，得到的一个整体就是16K * 8位的。
  - 然后两片作为一个整体再进行字扩展，此时就需要使用译码器。
  - 译码器输出的信号是并行传输到一个整体的两片芯片上的，比如译码器的一号输出的电路在第二片分了叉的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071818783.png" alt="image-20220507181839508" style="zoom:50%;" />

## 3.4.2 主存与CPU的连接例题

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071830997.png" alt="image-20220507183009664" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071830105.png" alt="image-20220507183035840" style="zoom:50%;" />

## 3.5 双口RAM和多模块存储器

#### 双端口RAM

- 有两套接口，也就是两套数据线，两套地址线，两套控制线。
  - 同时和两个CPU相连，两个CPU可以同时对主存进行访问。
  - 对于可能会出现读出错误和写入错误的情况，增加了两条忙线，用来保证两个CPU同时对同一存储单元操作时不会出错。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071840985.png" alt="image-20220507184014695" style="zoom:50%;" />

#### 多模块存储器

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071851500.png" alt="image-20220507185125174" style="zoom:50%;" />

#### 多体并行存储器

- 两种编值方式：
  - 高位交叉编值：地址的高位决定访问的是哪一个存储体。
  - 低位交叉编值：地址的低位来决定。
- 两种编址方式针对连续访问的表现：
  - 对于高位交叉编址，对下一个地址的访问，只能在前一个地址结束访问之后才能开始。
    - 也就是说，下面的例子中，对$M_o$的访问，必须是访完第0个单元后，才能开始访问下一个地址对应的存储单元。
  - 对于低位交叉编址，在对当前地址访问开始之后的很短的一段时间内，就可以立即开始对下一个地址对应的存储单元的访问。
    - 也就是说，在对$M_0$的0号单元访问开始之后的很短一段时间$\tau$后，由于第二条地址所对应的存储单元不在$M_0$上，对第二条地址对应的存储单元的访问也可以直接开始，而不必等待前一个访问完毕。
    - 整体的时间就比高位交叉编址要短很多。
    - 设计得好的话，让$\tau$特别小，可以相当于这多个存储体并行工作。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071934183.png" alt="image-20220507193435844" style="zoom:50%;" />



#### 流水线

- **低位交叉编址的耗时的结论$T + (n - 1)\tau$只有在$m \geq T /r$的时候才适用，实际设计取等号**
  - 如果存储体的个数$m$过少，则在最后一个存储体的读写工作开始时，再经过$\tau$的时间，由于第1个存储体还没有恢复，不能立即开始工作。
  - 如果存储体的个数$m$恰好等于$T / r$，那么在最后一个存储体读写工作开始时，再经过$\tau$时间，第一个存储体恰好恢复，可以立即开始工作。
  - 如果存储体的个数$m$更大，那么在最后一个存储体读写工作开始时，再经过$\tau$时间，第一个存储体早已恢复完毕甚至已经空闲了一段时间。
    - 所以取等号，把空闲时间去掉。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071947471.png" alt="image-20220507194727267" style="zoom:50%;" />



- 
  - $n$较大时，$(W / r) / (W/T) = T / r = m $，相当于$m$个存储体并行工作
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205071944539.png" alt="image-20220507194457202" style="zoom:50%;" />

## 3.6.1 局部性原理及性能分析

### 局部性原理

- 空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的。
- 时间局部性：在最近的未来要用到的信息，很可能是现在正在用到的信息。

#### 性能分析

- 命中率$H$：CPU欲访问的信息已在Cache中的比率。
  - 设在程序执行期间，CPU访问Cache的参数为$N_C$，访问主存的次数为$N_M$，则$H = N_C / (N_C + N_M)$

- 缺失率：$1 - H$，把分子的$N_C$换成$N_M$。
- 设$T_c$为命中时的Cache访问时间，$T_M$为未命中时的访问时间。
  - 未命中则有两种模式：
    - 主存先将数据传输给Cache，然后CPU再从Cache中取出
    - 主存同时向CPU和Cache传输数据。
  - Cache——主存系统的平均访问时间：
    - $T_C * H + T_M * (1 - H)$ 



- 例题注意一下两种不同的未命中下的访问模式：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081140649.png" alt="image-20220508114018164" style="zoom:50%;" />

## 3.6.2 Cache-地址映射

### Cache基本工作原理

- 主存中的块在Cache中如何放置：
  - 空位随意放：全相联映射。随意放哪个空位。
  - 对号入座：直接映射。给每一个块固定分配一个号，在Cache中只能放置在固定位置
  - 按号分组，组内随意放：组相联映射
- Cache满了如何处理？
  - 随机算法
  - 先进先出算法
  - 近期最少使用算法
  - 最不经常使用算法
- 由于CPU会对Cache进行读和写，如何保持Cache中的内容和主存中相应内容的一致性？
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081150317.png" alt="image-20220508115020057" style="zoom:50%;" />

### 地址映射

#### 全相联映射

- 有效位用于标记Cache中的某一块是否已经保存了来自主存其他块的数据，只有被标记为空的Cache块才能存放新的数据。
- 在将主存中块的数据放入Cache的时候，块内的地址是没有变化的。
- 为了标识Cache中保存的那一块数据是来自原来主存中的哪一块，会将主存块的地址的高位也存入。
- 在将主存中的某一块放入Cache的某一块的时候，会将有效位标记为已占用，同时写入主存地址的高位起到溯源的作用。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081157885.png" alt="image-20220508115714514" style="zoom:50%;" />

#### 直接映射

- 概括一下就是第$i$块主存放在Cache的第$i \ mod \ 8$块。
  - 将主存地址分成三部分：
    - 主存字块标记：用于标记放在某一块Cache的内容来自主存的哪一块
      - 由于同一块Cache可以存放来自不同主存块的内容，所以是必要的，比如第0块Cache可以放置第0、8、16块主存的内容。
    - Cache字块地址：能够放置在同一块Cache的主存块，它们的Cache字块地址是一样的，所以这一部分的三位不需要写入Cache作为标记。
    - 字块内地址：最低的6位，还是和上面是一样的。
- 这里和上面不一样的地方在于，用作溯源的主存地址高位，只选取了高位的19位，而没有一并加上中间的三位。
- 与第一种放置方法相比：
  - 优势在于，存放的额外信息少了（也就是起到溯源作用的高位地址的位数少了），硬件电路更简单
  - 劣势在于，第8块主存只能放在第0块Cache，空间利用率肯定是更低的，而第一种方法的就没有这个限制，

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081207619.png" alt="image-20220508120758243" style="zoom:50%;" />

#### 组相连映射

- 先将Cache分组，一个主存块在Cache组内时可以随意放。
  - 每几个Cache块为一组，就称作几路组相联。
  - 以二路组相联为例，将Cache分为4组，第$i$块主存放入第$i \ mod \ 4$组。
- 主存地址就可以分为三部分：
  - 主存字块标记：用于写入Cache后溯源
  - 组地址：标记当前主存块应该放入哪个组，组内可以随机选择一块Cache块放置
  - 字块内地址：不再赘述

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081405588.png" alt="image-20220508140537164" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081411034.png" alt="image-20220508141154720" style="zoom:50%;" />

- 直接映射相当于一路组相联。

## 3.6.3 Cache-替换算法及写策略

### 替换算法

- 对于近期最少使用算法的计数器，可以看做是用来记录某个块“经历了几轮CPU访问但是访问的不是它”的次数。
  - 比如某个Cache块的计数器的值是10，说明CPU访问了十次Cache，但是10次都没有访问到它。
  - 计数器为0就说明该行近几轮CPU访问被命中过。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081424392.png" alt="image-20220508142407084" style="zoom:50%;" />

### Cache原理图

- Cache主存地址映射变换机构负责将CPU给出的主存地址映射成Cache中的块地址和块内地址。
- 数据总线负责CPU和Cache以及主存之间的数据传输，在命中的情况下Cache之间将数据传输给CPU。
- 在未命中的情况下，主存通过Cache替换机构将CPU访问的主存块的内容替换进Cache。
  - CPU则有可能在主存将内容传输给Cache后访问Cache，也有可能主存同时将内容传输给Cache和CPU
- 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081436747.png" alt="image-20220508143617445" style="zoom:50%;" />

### 写策略

#### 命中情况下的写策略

- 写回法：增加一个脏位，用于标记当前块是否被修改过。
  - 在CPU对Cache写命中时，考虑到CPU后续可能还会对同一块做其他写入操作，所以不会马上把改变写回主存对应块。
  - 在等到这块被替换出去的时候，CPU对它不再有修改的可能性了（CPU对它的所有修改工作都完成了），再将这块内容写回CPU。
  - 在替换的时候，如果脏位标记为内容未修改，就直接覆盖掉，如果脏位标记为已修改，就将内容写回主存再覆盖。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081441416.png" alt="image-20220508144117107" style="zoom:50%;" />

- 全写法：CPU对Cache写命中时，同时将修改写入Cache和主存。
  - 由于CPU写Cache和写主存的速度差异很大，采用写缓冲。
  - 如果CPU写的频率太高可能会导致缓冲区溢出

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081446294.png" alt="image-20220508144610992" style="zoom:50%;" />

#### 未命中情况下的写策略

- 写分配法，将主存中的块调入Cache，然后对Cache修改。搭配写回法使用。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081511303.png" alt="image-20220508151141994" style="zoom:50%;" />

- 非写分配法：将修改直接写入主存，搭配全写法使用。
  - ![image-20220508151302862](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081513161.png)

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081516640.png" alt="image-20220508151602397" style="zoom:50%;" />

### 多级Cache

- L1和L2之间使用全写法，L2和主存之间使用写回法。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081516617.png" alt="image-20220508151646381" style="zoom:50%;" />

## 3.6.7 虚拟存储器

- 用户给出的地址和实际在存储器上的物理地址是不同的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081611942.png" alt="image-20220508161101621" style="zoom:50%;" />

### 页式虚拟存储器

- 将虚拟空间与主存空间划分为同样大小的页
  - 主存的页称为实页，因为主存是真实存在的。
  - 虚拟内存的页称为虚页，因为虚拟内存是不存在的。
- 主存的地址分为两部分：类似Cache的地址映射
  - 页内地址
  - 实页号
- 虚页的地址也分为两部分：页内地址 + 虚页号
- **一个虚页地址和其对应的实页的页内地址是相同的**，因为虚页和实页是同样大小的页。
- 页表：
  - 页表的一项有两个域：
    - 实页号：记录某个虚页号对应的实页号。
    - 装入位，记录虚拟地址指向的那部分数据是已经被装入主存，还是只存在于外部磁盘中。
      - 如果装入位是1，则将实页号和页内地址拼接一下，得到数据在主存中放置的地址。
      - 如果装入位是0，则操作系统先将虚页对应的数据调到主存中，再访问主存中的数据。
  - **页表本身也是处于主存中的，所以页表的每一项都可以使用主存地址去访问。**
- 由虚页号得到对应实页号的流程：
  - 硬件提供一个寄存器，页表基址寄存器，存放页表的起始地址。
  - 寄存器中的页表起始地址和虚页号进行拼接，就可以得到页表中一个页表项的完整地址。
  - 根据得到的完整地址去访问页表项，然后得到其对应的实页号，以及装入位。
  - 将实页号取出，与虚页地址的页内地址部分进行拼接，就得到了数据在主存当中的地址。
  - 然后访问数据即可。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081632111.png" alt="image-20220508163245827" style="zoom:50%;" />

### 段式虚拟存储

- 将虚地址分为两部分，段号 + 段内地址
  - 由于段的大小是不固定的，所以不将主存地址也分为两部分。
- 段表：
  - 每行是一个段表项。
  - 段表同样是存储于主存当中的，每一项都可以使用主存地址访问。
  - 一个段表项的域有：
    - 某个段对应的段号
    - 装入位
    - 段起点和段的长度。
- 得到主存地址的流程：
  - 硬件有一个寄存器，段表基址寄存器，纪录了段表的起始地址。
  - 将段表起始地址与段号拼接，得到段表项的地址。
  - 根据段表项的地址，取出其中内容与段内地址相加，得到主存地址。
  - 然后访问数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081709301.png" alt="image-20220508170926949" style="zoom:50%;" />

### 段页式虚拟存储器



<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081719034.png" alt="image-20220508171859759" style="zoom:50%;" />

### 快表和慢表

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081726114.png" alt="image-20220508172630783" style="zoom:50%;" />

### 例题

- **不要把最后的大写H也当做地址的一部分，那个是16进制的标记**。
- **标记指的是虚页号，页框号指的是实页号。**
- 虚拟地址空间32位，包括12位页内地址，以及20位虚页号
- 主存地址空间28位，包括12位页内地址，以及16位实页号。
- 有效位表示在Cache中是否有给定虚拟地址指向的数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205081733054.png" alt="image-20220508173352694" style="zoom:50%;" />

# 第4章 指令系统

## 4.1 指令格式

### 指令的定义

- 定义：指令是指计算机执行某种操作的命令，是计算机运行的最小功能单位
  - 一台计算机的所有指令的集合构成该计算机的指令集。
  - 只能执行属于自己指令集系统的指令，不能执行其他系统的指令。

### 指令格式

- 指令的长度称作指令字长

#### 地址码

- ​	四地址指令到三地址指令的改进是增加了程序计数器PC
  - 在四地址指令的情况下，指令是分散分布在主存各处的，所以需要给出下一条指令的位置。
  - 新增程序计数器之后，指令是集中存储在内存的某一块，只需要让程序计数器自动的指向下一条指令的位置即可。

- 三地址指令到二地址指令是因为略去了存放结果的内存位置，而使用原来存储某个操作数的空间存储得到的结果。
- 定长指令字结构：指令的长度是固定的，从四地址指令到一地址指令都是定长指令。
- 变长指令字结构：指令的长度不等，比如既有零地址指令又有二地址指令。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101449039.png" alt="image-20220510144901609" style="zoom:50%;" />

#### 操作码

- 定长操作码：操作码的长度是固定的，对于一个$n$位长的操作码来说，指令的种类有$2^n$种。
  - 只考虑操作码的可能性，条数就是这么多。

#### 扩展操作码

- 将4位定长操作码的三地址定长指令进行扩展：
  - 首先不进行扩展的情况下，4位操作码全用于三地址指令，则有16条。
  - **如果将16种状态中的某一种保留下来用于下一层扩展操作码，三地址指令为15条**。这里我们保留`1111`
    - 则当4位操作码为`1111`时，我们知道我们进入了扩展的操作码的范畴。
  - 将前四位为全一的指令，翻译成二地址指令，原先$A_1$的部分也扩展为操作码的一部分。
  - 同样的我们保留$A_1$位置为`1111`的情况用作扩展，这样就得到了15条二地址指令。
  - 以此类推，我们将$A_2$部分也扩展为操作码的一部分，同时也保留其为`1111` 情况用做扩展，得到15条一地址指令。
  - 再进一步扩展，由于无法再进行扩展，所以无需保留$A_3$为`1111`，得到16条零地址指令。
- 当机器在分析指令的过程：
  - 如果读到前四位不为全`1111`，那就说明这是一条三地址指令，可以开始执行。
  - 否则说明这是一条扩展操作码的指令，继续向后读取四位，如果读取到的四位不全为1，说明是二地址指令，可以执行。
  - 否则说明这不是一条二地址指令，继续向后读取四位，如果读取到的四位不全为1，说明是一地址指令，可以执行。
  - 以此类推下去。
  - 四个位置中，某一个位置上的`1111`相当于告诉机器把下一个位置上的四位也看做操作码来读。
  - **所以应该尽量把使用频率较高的指令分配较短的操作码，这样对指令的译码的时间就越短**。
- 设计扩展操作码时应该注意的：
  - 操作码必须是无前缀编码，即某一个短操作码不能是另外一个长操作码的前缀。
  - 各指令的操作码不能重复
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101533888.png" alt="image-20220510153313624" style="zoom:50%;" />
- **每一层其实可以留出多个状态来为下一层进行扩展，所以扩展的方式有很多种**

<img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220510151103017.png" alt="image-20220510151103017" style="zoom:50%;" />

- **一个前一层扩展给下一层留出不同数目状态用作扩展的例题：**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101536025.png" alt="image-20220510153628682" style="zoom:50%;" />

- 总结：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101554934.png" alt="image-20220510155408583" style="zoom:50%;" />

### 操作类型

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101556239.png" alt="image-20220510155647887" style="zoom:50%;" />



## 4.2.1 指令寻址

### 数据存放（编址）的一些概念复习

- 各种编址方式：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101601749.png" alt="image-20220510160142356" style="zoom:50%;" />

- 大端法和小端法：
  - 大端法是符合人类阅读习惯的方法。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101603345.png" alt="image-20220510160322055" style="zoom:50%;" />

- 三个字长：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101612548.png" alt="image-20220510161230284" style="zoom:50%;" />
- 内存对齐：
  - 对齐的好处：不写了。复习的时候想
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101613727.png" alt="image-20220510161329446" style="zoom:50%;" />



### 指令寻址

- 这里给出的只是一个最基本的模型，基本上结合大一的CPU模拟器大作业以及CSAPP有关汇编语言的部分内容就全面了。
- 顺序寻址：PC按顺序自动加一指向下一条指令
- 跳跃寻址：由跳转指令修改PC的值，跳转指令给出的应该是PC相对的寻址方式（CSAPP遥远的记忆）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101620819.png" alt="image-20220510162023487" style="zoom:50%;" />

## 4.2.2 数据寻址1

### 操作数类型

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101640130.png" alt="image-20220510164058873" style="zoom:50%;" />

### 数据寻址

- 以一地址指令为例进行后续讨论。
  - 可以推广到两个地址以上的指令。
  - **每个形式地址都有一个自己的寻址特征，因为每个形式地址可以使用不同的寻址方式**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101739616.png" alt="image-20220510173947350" style="zoom:50%;" />
- 指令的地址码分为两部分
  - 形式地址：并不是操作数真实的在主存中的地址，是用于根据寻址特征求出操作数在主存中的真实地址的。
  - 寻址特征：表征寻址方式的。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101737935.png" alt="image-20220510173711540" style="zoom:50%;" />

#### 立即寻址

- 指令的形式地址就是操作数本身，这样获取操作数的时候就不需要去访存，可以减少指令的执行时间。
- 寻址特征采用井号表示
- 立即数一般使用补码形式来表示
- 立即寻址的缺点是形式地址的位数限制了操作数的数据范围。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101758953.png" alt="image-20220510175826638" style="zoom:50%;" />

#### 直接寻址

- 就是把操作数处于主存中的真实地址存入形式地址。
- 要获取操作数的时候，就直接按照指令给出的形式地址去主存的位置寻找即可。
- 缺点是形式地址的长度限制了操作数的寻址范围，并且由于指令中的地址是固定的，就不能轻易修改操作数在内存中的位置。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101802432.png" alt="image-20220510180216097" style="zoom:50%;" />

#### 间接寻址

- 形式地址段保存的是一个指向操作数的地址的指针，也就是保存的是操作数的地址的地址。
  - 也就是说A保存的是EA的地址，EA是操作数的地址。
- 由于操作数的地址的地址是可以灵活变化的，所以形式地址是可以灵活变化的。
  - 也就是可以把EA存到不同的主存位置。
- 在进行多次间接寻址的时候，主存中的每个地址的标志位（图中是最高位）用于表明当前取到的地址是否是指向操作数的有效地址，如果不是就还要继续往前取地址。如果是，则下一次取到的就是操作数。
- 缺点就是多层嵌套的指针访问会增多访存的次数，优点是扩大了寻址范围。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101809426.png" alt="image-20220510180951079" style="zoom:50%;" />



#### 寄存器（直接）寻址

- 将操作数保存在寄存器中，而指令中的形式地址保存的就是寄存器的编号。
- 类似于内存的直接寻址。
- 优点是取操作数的时候非常快
  - 取操作数的时候不需要访存的，因为寄存器在CPU里。
  - 可能比立即寻址还是慢点，毕竟立即寻址操作数就在指令里面，都不需要去取操作数

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101920434.png" alt="image-20220510192057007" style="zoom:50%;" />

#### 寄存器间接寻址

- 这种寻址方式在CSAPP遥远的记忆中就出现了。
- 形式地址仍然是寄存器的编号，**但是寄存器中保存的值不再是操作数，而是操作数在主存中的有效地址**。
- 取指令访存一次，然后从指令指明的寄存器取出操作数的有效地址，然后根据有效地址访存，取得操作数。
- 比一般的简洁寻址要快。
  - 因为一般的简洁寻址，有效地址是存在主存中的，而寄存器间接寻址，有效地址是存在寄存器中的，访问寄存器肯定更快。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205101954560.png" alt="image-20220510195431200" style="zoom:50%;" />



- ### 以上都是以一地址指令为例说明的，对于多地址指令，每个地址都会有自己的寻址特征码，根据它的寻址特征码来计算有效地址即可。

#### 隐含寻址

- 其中一个操作数由形式地址给出，另外一个操作数约定放在ACC中，运算的结果也放入ACC中

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102003505.png" alt="image-20220510200338221" style="zoom:50%;" />



## 4.2.3 数据寻址2——偏移寻址

- 三种偏移寻址计算有效地址的形式都是一样的。
- 基址寻址：将CPU中基址寄存器的内容加上指令格式中的形式地址A，得到操作数的有效地址。
- 既可以使用专用的寄存器来基址寄存器，也可以使用通用寄存器作为基址寄存器。
  - 采用通用寄存器作为基址寄存器的时候，形式地址要给出通用寄存器的编号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102021262.png" alt="image-20220510202110927" style="zoom:50%;" />

### 基址寻址

- 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。
  - 在程序执行过程中，基址寄存器的内容保持不变，作为基地址。
  - 而作为偏移量的形式地址是可变的。
  - 采用统一寄存器作为基址寄存器时，用户可以决定采用第几个通用寄存器，但是还是不能决定寄存器中的内容。
- 扩大寻址范围是每个偏移寻址都有的优点。**有效地址的位数和位数长的那个一致。**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102032132.png" alt="image-20220510203227754" style="zoom:50%;" />

### 变址寻址

- 对于数组来说，形式地址A中的基址，就是数组的第0个单元的地址。
- 如果使用通用寄存器作为变址寄存器，同样需要指出通用寄存器的编号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102046288.png" alt="image-20220510204631985" style="zoom:50%;" />

### 相对寻址

- PC的值是会变化的。
- 形式地址A给出相对当前地址的位移量，使用补码表示。
- 来自CSAPP遥远的记忆，应该是`PC相对的寻址`。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102105092.png" alt="image-20220510210503702" style="zoom:50%;" />

- 例题，里面的第二问是使用补码计算的。。减去一个数，替换成加上它的补码。
  - 因为A是使用补码保存的，但是右边两个地址都是无符号数。转换成补码再求结果。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102125257.png" alt="image-20220510212526864" style="zoom:50%;" />

## 4.2.4 数据寻址3——堆栈寻址

- 没什么好说的，就是利用栈这种数据结构，CSAPP遥远的记忆。
  - 使用出栈来给出操作数。
  - 使用入栈将运算的结果存入。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102322635.png" alt="image-20220510232251151" style="zoom:50%;" />

- 堆栈一般是从主存中划出一块专用区域或一组专用寄存器组来实现。分为硬堆栈和软堆栈。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102325418.png" alt="image-20220510232521119" style="zoom:50%;" />

## 4.3 RISC和CISC

### CISC($Complex \ Instruction \ Set \ Computer$)

- 复杂指令集
- 设计思路：一条指令完成一个复杂的基本功能

### RISC($Reduced \ Instruction \ Set \ Computer$)

- 精简指令集，基于2-8规律。
  - 且用到的2通常是较简单的指令。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102332463.png" alt="image-20220510233232156" style="zoom:50%;" />
- 设计思路：一条指令完成一个最基本的动作，多条指令组合完成一个复杂的基本功能。

### 对比

- CISC通用寄存器少一个原因是指令复杂，产生的中间结果少，另一个原因是指令本身的实现就占用了大部分面积。
- RISC则恰恰相反

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205102341981.png" alt="image-20220510234123613" style="zoom:50%;" />

# 第5章 中央处理器

## 5.1 CPU的功能和基本结构

### CPU的功能

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111040669.png" alt="image-20220511104031298" style="zoom:50%;" />

### 运算器和控制器的功能

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111042182.png" alt="image-20220511104237861" style="zoom:50%;" />

### 运算器的基本结构

- 两种结构：总线结构和专用数据通路结构。

#### 专用数据通路结构

- 算术逻辑单元的A和B是两个操作对象保存的地方。

- 每个寄存器都有与A和B直接相连的数据通路（电路）。
  - 所以性能较高， 也不存在数据冲突的问题，但结构复杂，硬件量大不易实现。
  - 数据冲突和总线结构对比的。
- 由于每个寄存器都有导线直接和ALU相连，所以需要一些控制措施来保证不会出现多个寄存器同时向ALU的同一个位置传输数据的情况。
  - 使用多路选择器，选择一路寄存器输入传入ALU中。
  - 使用三态门：每一条导线都有一个三态门，控制这条导线是否输出到ALU。**PPT上无法输出应该是Ａ端不是Ｂ端。**
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111143401.png" alt="image-20220511114351066" style="zoom:50%;" />

-  <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111138765.png" alt="image-20220511113834395" style="zoom:50%;" />

#### 总线结构

- CPU内部单总线结构：将所有寄存器的输入端和输出端都连接到一条公共的数据通路上，也就是总线上。
  - 总线结构必然带来数据冲突，所以每个寄存器的对总线的输出线都有一个三态门用于控制是否输出。
  - 结构简单容易实现，但是数据冲突比较多，性能也低一些。
    - 寄存器只能轮流使用总线来传输而不能像专用数据通路那样同时传输。
  - 图中绿色的线是用来控制总线对寄存器的输入的，$RIin$用于控制，绿色箭头用于传输。
- 暂存寄存器的作用：由于AB是和总线同时相连的，所以如果没有暂存寄存器的话，AB中的数据永远是一样的，无法做到两个操作数。
  - 所以使用暂存寄存器，第一个操作数暂存在这里，第二个操作数在第二次总线传输的时候传输给B。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111215518.png" alt="image-20220511121502231" style="zoom:50%;" />
- 有关移位寄存器：
  - 也可以用作暂存ALU运算的结果。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111215944.png" alt="image-20220511121537708" style="zoom:50%;" />
- 程序状态字寄存器($PSW$)：
  - 这个寄存器的每一位都有自己的含义。
  - 这个寄存器是可以按位寻址的，可以直接给出某一位的内容。
  - 可能还有中断的控制信息。
- 

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111202037.png" alt="image-20220511120257636" style="zoom:50%;" />

### 控制器的基本结构

- 程序计数器PC：
  - PC有自增功能。
  - PC会跟CPU内部总线有数据交流，用来设置PC的值
- 指令寄存器：
  - 由于保存当前正在执行的指令。
  - **地址码部分会将有效地址传递给总线，然后再通过总系传递给地址寄存器。**
  - 操作码部分传递给指令译码器进行译码。
- 指令译码器：
  - 将指令寄存器传递来的操作码译码，将结果传递给微操作发生器。
- 微操作信号发生器：产生控制整个计算机系统所需的各种控制信号。
  - 图中所有的绿色的蓝色的信号，都是由微操作发生器产生的。
- 地址寄存器：
  - 在逻辑上是属于主存的，但是硬件实际是整合在CPU内部。
  - 与CPU内部总线相连，外连地址总线，地址总线与主存相连。
- 数据寄存器：
  - 在逻辑上是属于主存的，但是硬件实际是整合在CPU内部。
  - 与CPU内部总线相连接，也与数据总线相连，两边的总线都会有输入和输出。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111412472.png" alt="image-20220511141211018" style="zoom:50%;" />

### CPU的基本结构

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111427338.png" alt="image-20220511142733005" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202205111428337.png" alt="image-20220511142759975" style="zoom:50%;" />
