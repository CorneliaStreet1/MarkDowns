# 第 0章 一些基本概念

- 信道(channel)：传送信息的媒体
- 数据率(bit rate)：数据传输速率(bps，比特率？)
- 波特：码元传输速率。
  - 一般比特速率大于等于波特速率。
  - 一个码元可以携带多个比特。1 波特等于lov~2~(V) bps，V是信号的电平级数。

- 传播速度：信号在通信线路上单位时间走过的距离
- 带宽：信号占用的频率范围。
- 信道容量：信道的最大数据率，换句话说就是信道的最大传输速率。
- 吞吐量：单位时间内网络可以传输的数据位数(bps)
- 误码率(Bit Error Rate)：传送错的位数 / 传送总位数。
- 时延(delay)：从网络中发送数据块的第一个比特开始，到最后一位数据被接收为止。
  - 传播时延：信号通过传输介质的时间
  - 发送时延：设备发送一个数据块所需的时间（数据块长度 / 信道带宽）
  - 处理时延：交换设备检查数据、选路的时间。
  - 排队时延：在交换机/路由器中排队等待的时间。
- 单工：单信道，只能在一个方向上传送，如FM广播。
- 半双工：传输数据可以发生在两个方向，但是某一时刻只能有一个方向传输数据。如对讲机。
- 全双工：传输数据可以发生在两个方向，并且可以同时往两个方向发送数据。如电话。
- 并行：有多根并行的通信线路存在于通信双方。同一个时刻可以一起发出去多个比特。
- 串行：只有一条通信线路。一个时刻只能发送一个比特。更常见。
  - 异步通信方式：
    - 收发双方没有时钟线，双方不需要同步。
    - 发送两个字符之间的间隔是任意的
    - 以字符为单位。接收方依靠字符中的起始位和停止位来同步。
  - 同步传输：双方使用同一个时钟信号。以数据块为单位传输。

# 第1章

- 计算机网络：大量相互独立但彼此连接的计算机，共同完成整个组织的计算任务的系统。
- 本书中计算机网络表示通过单一技术相互连接的自主计算机集合。与分布式系统不同。
- 分布式系统：通过中间件使得不同的机器看起来都是一致的。分布式系统就是一个模型范式。隔离不同机器的这一层抽象的软件就是中间件。
  - 计算机网络中，用户对不同机器之间的差异完全可见。

## 1.1 使用计算机网络

### 1.1.1

- 资源共享：让网络中的任何人都可以访问所有的程序、设备、数据，这些资源与用户所处的物理位置无关。
  - 共享物理设备：如一台通过网络使得所有工作人员可以使用的打印机设备。
  - 共享信息。
- **客户机——服务器**模型：
  - 应用广泛。
  - 双方的通信过程：客户机进程**通过网络**发出请求消息并等待应答===>服务器进程收到消息并执行相关请求===>服务器发回应答消息。

### 1.1.2

- 除了`客户机——服务器`模型之外的另外一种模型：对等通信技术(peer to peer)。
  - 大家都是地位同等的。一个群体中的个人可以与群体中的其他人通信。
  - 原则上每个人都可以与一个或多个其他人通信，没有固定的客户端和服务器分工。
  - <img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220312151813531.png" alt="image-20220312151813531" style="zoom:50%;" />
  - 许多对等系统没有中央数据库，每个用户维护自己的本地数据库并为附近群体的其他成员提供服务。
  - B：business C: consumer<img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220312152506605.png" alt="image-20220312152506605" style="zoom:50%;" />

### 1.1.3

### 1.1.4



## 1.2 网络硬件

按照传输技术和网络尺度两个尺度，可以对计算机网络进行分类。

- 点到点(point to point)链路。也称为单播(unicasting)
  - 点到点链路将**一对**单独的机器连接起来。
  - 短消息(包或数据包)经过一个或多个中间机器，从源端到达目的端。
  - 通常存在多条不同长度的路由。需要找到一条最优路由。

- 广播式链路。通信信道被网络上所有机器共享。
  - 任何一台机器发出的数据包能被所有其他机器收到。每个数据包的地址段指定了预期的接收方。
  - 收到数据包的机器会检查地址段，如果自己刚好符合地址段，那么就处理这个数据包，否则忽略这个数据包。
    - 因此可以通过一种特殊的地址编码，将目标机器指定为所有的机器。
  - 组播（multicasting）：只给一组机器发送数据包，这组机器是订阅了的机器。

- 根据网络尺度分类：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203121601807.png" alt="image-20220312160148610" style="zoom: 50%;" />

### 1.2.1 个域网 （Personal Area Network，PAN）

- 设备围绕一个人进行通信。
  - 计算机的各种外设，键盘鼠标显示器等，通过线缆或者蓝牙与计算机进行通信。
  - 手机与蓝牙耳机，汽车与车载设备。
- 最简单形式下的蓝牙采用主-从操作模式。外设通常是从设备。



### 1.2.2 局域网(Local Area Network，LAN)

- 一种私有网络，被广泛用来连接个人计算机和消费类电子设备，使它们能共享资源和交换信息。
- 通常来说无线局域网中的多台计算机与某个设备通信，这个设备负责中继工作，计算机之间的中继以及Internet与计算机之间的中继，称作接入点(AP,access point)、无线路由器(wireless router)或者基站(base station)。
- 有线局域网：
  - 以点到点链路为基础的拓扑结构。
  - 交换式以太网：
    - 有一个交换机负责中继与之连接的计算机之间的数据包，根据数据包的地址决定这个数据包要发送给哪一台计算机。
    - 一个交换机有多个端口，每个端口与一台计算机相连。
    - 交换机插入彼此之间的端口，形成更大的局域网。
- 有时会将一个大的物理局域网分成两个较小的逻辑局域网。
  - 虚拟局域网，VirtualLAN。
- 有线和无线广播网络的静态设计和动态设计。
  - 动态和静态指的是如何分配信道。
  - 一种典型的静态分配方案：将时间划分为离散的时间段并使用轮循算法，每台机器只能在属于自己的时间槽到来时进行广播。
    - 明显的缺点：如果一台机器在属于自己的时间槽到来时没有数据要发送，这段时间内的信道容量就被浪费了。
    - 因此大多数系统都采用动态分配，也就是按需分配。
  - 动态分配：可以是集中式的也可以是分散式的。
    - 集中式中有一个中心实体，负责决定接下来由谁使用信道。
    - 分散式信道分配方法中不存在中央实体，每台机器自行决定是否可以传输。

### 1.2.3 城域网（Metropolitan Area Network，MAN）

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203131602023.png" alt="image-20220313160205770" style="zoom: 50%;" />

### 1.2.4 广域网（Wide Area Network ,WAN）

- 子网由传输线路和交换元素组成。网络运营商所拥有的一组路由器和通信线路。
  - 传输线路负责在机器之间移动比特。
  - 交换机是专用的计算机，路由器。负责连接多条线路，为从入境线路传输来的数据选择一条处境线路。
- 路由算法：网络决定使用哪条路径的策略。
- 转发算法：每个路由器决定如何把一个数据包发送到哪个位置的策略。
- ISP: Internet 服务提供商。

### 1.2.5 互联网络

- 网关：将两个或多个网络连接起来并提供必要转换的机器，其硬件和软件方面的总称。

## 1.3 协议层次结构

### 1.3.1 协议层次结构

- 为了降低网络设计的复杂性，绝大多数网络都组织成一个层次栈。
  - 每一层都建立在其下一层的基础之上。
  - 每一层向上一层提供特定的服务，而把如何实现这些服务的细节对上一层加以屏蔽。
- 一台机器上的第n层与另一台机器上的第n层进行对话，对话中使用的规则和约定统称为第n层协议。
  - 协议(protocol)：通信双方就如何进行通信的一种约定。
  - 违反协议使得通信成为不可能，也不是完全不可能啦，但是还是很蓝的啦。
  - 不同机器上构成相应层次的实体称为对等体。对等体可能是软硬件可能是人。
  - **数据并不是从一台机器的第n层直接传递到另一台机器的第n层，而是一台机器的每一层自顶向下地将数据传递给下一层，直到传递到最底层，最底层再通过物理介质进行实际的通信。**
  - <img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220313164430506.png" alt="image-20220313164430506" style="zoom: 50%;" />
  - 处于一对相邻的上下层之间的是接口。
    - 接口定义了下层向上层提供哪些原语操作和服务。
    - 层与层之间清晰的接口使得同层协议的替换更加容易，新协议只需要给上层提供与旧协议完全相同的服务即可。
  - 层和协议的集合称为网络体系结构。实现细节和接口规范不属于体系结构的内容，因为它们隐藏在机器内部。    
- 一个更有技术性的例子。关于某层给消息加上一个头、消息的分片（数据包）。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203131711725.png" alt="image-20220313171107518" style="zoom: 67%;" />

- **协议层次结构中的较低层次往往由硬件或固件实现。**



### 1.3.2 层次设计问题

- 信息的检错和纠错。
- 路由。消息传输过程中路由的灵活决策。
- 寻址(addressing)和命名(naming)。
- 网络互联。如何将具有不同技术限制的网络技术连接起来，如对消息的拆分、传输和重组解决消息大小限制，对消息编号解决信道不能维护消息顺序的限制。
- 资源分配。信道的分配，动态共享网络带宽，统计复用。
- 流量控制。如何保持快速发送方不会用数据把慢速接收方淹没。
- 网络超载。太多的计算机要发送太多的流量，导致拥塞。发生拥塞时所有的计算机都减少其对网络带宽的需求。
- 服务质量。调和高吞吐和延迟需求。
- 保密性和完整性。

### 1.3.3 面向连接与无连接服务

- **两种服务都是下层向上层提供的服务：面向连接的服务和无连接服务。**每个服务都可以使用服务质量来表述其特征。

- 面向连接的服务：先建立一个连接，然后使用该连接传输数据。打电话先要拨号，然后电话通了才能说话，最后挂电话。
  - 像一个管道，发送方从管道的一端压入数据，接收方从管道的另一端取出来。
  - 有些情况下，建立一个连接时，发送方、接收方以及子网一起协商连接将要使用的参数。
- 无连接服务：类似邮政系统。每个消息都携带了完整的目标地址，每个报文都由系统中的中间节点路由，并且路由独立于后续消息。
  - 消息在不同层次有不同的称呼，如数据包。
  - 存储-转发交换（store-and-forward switching）：中间节点只能在收到消息的全部内容之后再将该消息发送给下一个节点。
  - 直通式交换(cut-through switching)：在报文(消息，message)还没有被完全接收完毕之前就向下一个节点传输。
  - 通常来说先发往目的地的报文先到达，先发送的报文也可能因为延迟而比后发送的报文晚到达。
- 可靠的面向连接服务有两个细微的变异形式。
  - 报文序列：报文的边界得以保持。
  - 字节流：连接只是一个字节流，没有任何报文边界。
- 数据报服务：不可靠的无连接服务，接收方不会给发送方反馈任何确认消息。与之相反的是有确认的数据报服务。
- 请求-应答服务：发送方传输一个包含了某个请求的数据报，接收方以一个包含了请求结果的应答数据作为反馈。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203131821370.png" alt="image-20220313182139153" style="zoom: 50%;" />

### 1.3.4 服务原语

- 一组服务由一组原语(primitive)正式说明，用户进程通过这些原语来访问该服务。其实就是一些“函数”，或者说“方法”吧，各个层次上的。

### 1.3.5 服务于协议的关系

- 服务：某一层向它的上一层提供的一组原语。服务定义了该层可以执行哪些操作。低层是服务提供者，上一层是使用者。
- 协议：协议是一组规则，规定了同一层上对等实体之间所交换的数据包或者报文的格式与含义。对等实体利用协议来实现它们的服务定义，它们可以自由地改变协议，只要不改变呈现给它们用户的服务即可。**服务和协议是完全分离的**。
- 服务涉及层与层之间的接口，而协议涉及不同机器上两个对等实体之间发送的数据包。



## 1.4 参考模型

`OSI`参考模型和`TCP/IP`参考模型

### 1.4.1 OSI参考模型

<img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220313203910405.png" alt="image-20220313203910405" style="zoom: 50%;" />

- 物理层：关注在一条通信信道上传输原始比特。
- 数据链路层：将一个原始的传输设施转变成一条没有漏检传输错误的线路。
  - 数据链路层通过将真实的错误掩盖完成其任务。
  - 流量调节，避免数据淹没接收方。
  - 广播式网络的数据链路层的另外一个问题：如何控制对共享信道的访问。介质访问控制层（子层）负责处理。
- 网络层：控制子网运行。
  - 处理拥塞。
  - 路由问题。
  - 服务质量。
  - 解决不同网络的兼容问题。
- 传输层：接收来自上一层的数据，在必要时将数据分片，然后确保将数据包正确地传输给网络层。
  - 必须上下隔离地完成，下层硬件技术随时间（技术的进步）的改变对上层来说完全是没有存在感的。
  - 还决定了向上层以及用户提供哪种类型的服务。最常见的是完全无错的点到点。建立连接时就确定下来。
  - 真正的端到端的层。源和目标进行会话。
- 会话层：允许不同机器上的用户建立会话。
  - 对话控制：记录该由谁传输数据。
  - 令牌管理：禁止双方同时执行同一个关键操作。
  - 同步功能。
- 表示层：表示层以下的层关注如何传递数据位，而表示层关注的是所传递信息的语法和语义。
- 应用层：包含用户通常需要的各种各样的协议。如超文本协议HTTP。



### 1.4.2 TCP/IP 参考模型

- 链路层
  - 存在感很低。
- 互联网层：将整个网络体系结构贯穿在一起的关键层。
  - 任务：允许主机将数据包注入到任何网络，并且让这些数据包独立地到达接收方。将IP分组投递至正确位置。
  - 数据包的到达顺序被打乱的话，排序由高层完成。
  - 定义了官方的数据包格式和协议，IP和ICMP。
  - 考虑路由和拥塞问题。
- 传输层：允许源和目标主机的对等实体进行对话。
  - 传输控制协议TCP。
    - 可靠、面向连接的协议。
    - 将输入的字节流分割成离散的报文并传递给互联网层。
    - （目标机器上）将收到的离散的报文重新装配到输出流中。
    - 流量控制，避免数据淹没接收方。
  - 用户数据报协议UDP。
    - 不可靠，面向无连接的协议。
    - 广泛应用于及时交付比精确交付更加重要的应用。如语音电话。
    - 应用于基于客户机-服务器模型的查询应用。
- 应用层：TCP/IP模型没有会话层和表示层，应用层包含了所需的会话和表示功能。
  - <img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220313212232500.png" alt="image-20220313212232500" style="zoom: 50%;" />

### 1.4.3 本书使用的模型

OSI参考模型在于模型本身，TCP/IP 参考模型在于TCP/IP协议。

讲了个勾八。

- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203132129864.png" alt="image-20220313212955574" style="zoom:50%;" />

### 1.4.4 

### 1.4.5

### 1.4.6

## 1.5 网络实例



## 1.6 网络标准化

## 1.7 度量单位

- 大写的B：Byte
  - KB 2 ^10^
  - MB 2^20^
  - GB 2^30^
  - TB 2^40^

- 小写的b：bit
  - kbps：10^3^ `位/秒`
  - Mbps：10^6^
  - Gbps：10^9^
  - Tbps：10^12^



# 第2章 物理层



## 2.1 数据通信的理论基础

- 一般而言对于导线来说，从0到某个频率**F~c~**的范围内，传输信号的振幅在导线介质上传输过程中不会衰减，而在截止频率F~c~之上的都会有不同程度的衰减。这段在传输过程中振幅不会明显减弱的频率的宽度就称为带宽。

- （模拟）带宽：在传输过程中振幅不会明显减弱的频率的宽度。一般取衰减为原来的一半为临界点。
  - 和数字带宽区分。
  - 带宽是传输介质的物理特性。
  - 可以用滤波器来进一步限制信号的带宽。
  - 从0到某个最大频率的信号称作基带信号。

### 2.1.3 信道的最大数据速率

- 香农定律：
  - **考虑信道的噪音**
  - `S / N`：信噪比，用信号功率于噪声功率的比值来度量。S为信号功率，N为噪音功率。
    - **通常使用对数来适用很大的范围，单位为分贝(dB)， 换算公式为(S/N db) =  10log~10~(S / N)。也就是对信噪比取十的对数再乘以十。**

  - 最大比特率 = Blog~2~(1 + S / N)，给出以`dB`为单位的信噪比，先换算成`S / N`再代入计算。 

- 奈克斯特定律： 如果一个任意信号通过了一个带宽为B的低通滤波器，那么只要进行每秒2B次采样，就可以完全重构出被过滤的信号。
  - 最大数据率 = 2Blog~2~V (比特 / 秒)，V为信号包含的离散等级
    - 低通：可以理解成高电平为1，低电平为0

  - **不考虑信道的噪音。**




## 2.2 引导性传输介质

- 物理层的作用：将比特从一台机器传输到另一台机器。
- 介质大致可分为两种：
  - 引导性介质，也称为有线介质。
  - 非引导性介质，也称为无线介质。



### 2.2.1 磁介质

- 将数据写到磁带或其他可擦写介质(如DVD)上，再运输到目标机器，然后再读取出来，也是一种常见的从一台机器传输数据到另外一台机器的方法。
  - 用这种方法的带宽可能究极大，毕竟卡车可以一次运几千个磁盘。带宽可能有上千GB每秒。
  - 永远不要低估一辆满载着磁带在高速公路上飞驰的旅行车的带宽。笑死。
  - 但是延迟高，毕竟车子来回怎么也得以分钟为单位来计算了。这就不适用于在线应用，比如CSOL。

### 2.2.2 双绞线

- 由两根相互绝缘的铜线螺旋状平行绞合而成。
  - 平行绞合可以显著降低电线的辐射。
  - 信号通常以两根电线的电压差来承载，对外部噪声有更好的免疫力，因为噪声对两根线的影响是一样的，电压差不会变。
  - 既可以传输模拟信号，也可以传输数字信号。
- 双绞线的一种常见类型：5类线。
  - 4对双绞线被套在一个塑料保护套内。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161532852.png" alt="image-20220316153233633" style="zoom: 50%;" />
- 对全双工、半双工、单工的更好理解的定义：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161534245.png" alt="image-20220316153415095" style="zoom: 50%;" />

- 非屏蔽双绞线：到6类线为止。其他看图
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161536135.png" alt="image-20220316153612756" style="zoom: 50%;" />

### 2.2.3 同轴电缆

- 比`非屏蔽性双绞线`有更好的屏蔽特性和更大的带宽，能以很高的速率传输相当长的距离。
  - 两种电缆，50和75Ω的。


<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161543421.png" alt="image-20220316154339036" style="zoom: 50%;" />

### 2.2.4 电力线

- 同样可以使用传输电力的线传输数据，进行低速率的通信。困难挺多的。



### 2.2.5 光纤

- 光纤技术的可达带宽超过50000 Gbps，现在还远未达到这个极限。
  - 限制在于我们把电气信号转化到光学信号的速度不够快。
  - 可单条光纤并发地使用多个信道来传输信号以提高链路容量。
- 主要用途：网络骨干的长途传输、高速局域网、高速Internet接入。
- 光纤传输系统的关键构成：
  - 光源。一个光脉冲表示比特1，没有光脉冲表示比特0。
  - 传输介质：超薄玻璃纤维。
  - 光探测器。探测器检测到一个光脉冲时产生一个电脉冲。
- **单向**光纤传输系统的工作原理：**如果需要双向通信，使用两根光纤，或者在同一根光纤上划分两个频段。**
  - 两端一端装上光源，另一端装上光探测器。（只有一端有光源所以是单向的）
  - 光源端接收到电子信号，将其转换成光脉冲并输出出去。
  - 光脉冲经过传输介质到达光探测器端。
  - 光探测器端接收到光脉冲并转换成电子信号输出给接收端。
- 多模光纤和单模光纤：
  - 多模
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161620041.png" alt="image-20220316162012912" style="zoom:50%;" />
  - 单模：
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161621985.png" alt="image-20220316162100779" style="zoom:50%;" />

- **光纤传输光还是会有衰减的，实际使用的是衰减较少的几个波长段。**
- 光缆：<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161627626.png" alt="image-20220316162724355" style="zoom: 50%;" />
- 光缆的三种连接方式：**每一种都会发生衰减，并且在结合点都可能发生光的反射干扰原来的信号。**
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161630982.png" alt="image-20220316163016770" style="zoom:50%;" />

- **光源：**发光二极管或半导体激光
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203161631652.png" alt="image-20220316163150554" style="zoom: 50%;" />
- **光探测器：**一个光电二极管。
  - 光电二极管的响应时间，也就是光信号转换成电信号的时间，限制了光纤的传输速率。

## 2.3 无线传输

### 2.3.1 电磁频谱

- 当一个大小适中的天线被连接到一个电路上，电磁波就可以被有效地广播出去，在一定距离内的接收者就能收到电磁波。
  - 所有的无线通信技术都是基于这个原理。
- 在光纤或铜线上，电磁波的速度会慢三分之一左右，跟电磁波的频率有关。
- 跳频扩频
- 直接序列扩频。
- 超宽带通信。



### 2.3.2 无线电传输

- 可以传输很长的距离，很容易穿透建筑，从信号源沿着所有方向传播，所以接收设备不需要与发送设备在物理上对齐。
- 低频沿着地标传输
- 高频通过电离层传输

### 2.3.2 微波传输

- 100MHz以上频段的电磁波几乎按直线传播，所以可以使用抛物线形状的天线将它们聚集成一束，从而获得极高的信噪比。
  - 发射端和接收端的天线必须精准地相互对齐。
  - 定向地传播使得多个排成一行的发射器和多个排成一行的接收器同时进行通信，因为只要相互之间满足最小距离，信号就是平行线，不会相互干扰。
  - 不能很好地穿透建筑物。
  - 多径衰落。
- 电磁频谱政策
  - 非许可性频段：
    - ISM：工业、科学、医学
    - 允许任何人传输数据，但对所用的功率进行控制，使得发射台只能在很短的距离内工作。
    - 比如无线鼠标、蓝牙，大概十米的传输距离。

### 2.3.4 红外传输

- 广泛用于短程通信。
- 不能穿过固体物体，也即决定了一个房间内的红外信号不会穿透墙壁干扰到另外一个房间。



### 2.3.5 光通信

- 将两个建筑物内的局域网通过安装在各自房顶的激光连接起来。通信的每一端都需要有光源和光探测器。
- 对容错工程要求比较高。

## 2.4 通信卫星

- 一个通信卫星可以看做一个大型微波中继器。
  - 它包含几个转发器，每个转发器侦听频谱中的某一部分，对入境信号进行放大，然后在另一个频率上将放大后的信号广播出去。
  - 出境信号采用不同的频率可避免与入境信号相互干扰。
- 范艾伦辐射带：高带电粒子层，飞进去的卫星很快会损坏。

- 卫星本质上是一个广播介质
  - 任何人都可以听到传输的内容，所以必要时要进行加密。
  - 传播一条消息的成本与该消息经过的距离无关。
- 中地球轨道卫星：主要用于GPS。
- 卫星与光纤：
  - 卫星可以快速部署，而光纤不能，这对于救灾以及军事行动极其重要。
  - 卫星可以为地面设施不发达的地区提供服务。那些地方根本不会有人愿意部署光纤。比如群岛之间通信。

## 2.5 数字调制与多路复用

- 有线和无线信道运载模拟信号，模拟信号可表示成诸如连续变化的电压、光照强度或者声音强度。
- 为了发生数字信息，我们必须设法用模拟信号表示比特，**比特与代表它们的信号之间的转换过程称为数字调制。**
- 基带传输：信号的传输占有传输介质上从零到最大值之间的全部频率，而最大频率取决于信令速率。有线传输常用。
- 通带传输(passband transmission)：信号占据了以载波信号频率为中心的一段频带。无线以及光纤信道常用。
- 多路复用(multiplexing)：单个信道被多个信号共享。

### 2.5.1 基带传输

- 符号率：信号改变的速率。
- 比特率：符号率与每个符号的比特数的乘积。
- 曼彻斯特：电平由高变低位1，由低变高为0。
- NRZ：不归零码，最朴素的想法，高电平为1，低电平为0。
  - 问题在于：
    - 效率太低了，根据奈克斯特定律，需要的带宽为比特速率的一半。
    - 解决方法：增加电平级数。信号的电平级数不一定就刚好是2^n^。
  - 最大的问题：
    - 长时间连续地传输`1`或者传输`0`，不好划分到底是传输了几个0还是1。114514个0和114515个零不好划分。
    - 解决方法：加一条时钟线。
- NRZI：不归零逆转。当信号出现1的时候，在中间有一次跳变，如果0就是高电平。
  - 高电平为0，1则表现为在那个时钟周期内信号由高变低或由低变高，也就是跳变。
  - 但是还是没法解决长时间为0的情况，比如114514个0。
  - 解决方法：直接规定用户不能发送太多的0.
  - 真正的解决方法：4B/5B，将连续多个0的比特组映射成稍微长一点的比特模式。
    - 收到的时候查表就可以译码。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203231750123.png" alt="image-20220323175003775" style="zoom: 33%;" />
- 平衡信号：在很短的时间内正电压与负电压一样多的信号。
  - 不平衡度信号在传输过程中会浪费能源。
    - 8B/10B、AMI
    - <img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220323175834632.png" alt="image-20220323175834632" style="zoom: 50%;" />







### 2.5.2 通带传输

- 将二进制信号进行调制，调制后的信号变成某个特定范围内的信号。接收到之后再调制回来就是。
- 将二进制信号变成连续变化的模拟信号，模拟信号限定在某个频率范围之内。
  - 幅度调制：出现0的时候没有正余弦信号，出现1的时候有正余弦信号。
  - 频率调制：用两种不同频率的信号来代替0和1，比如0的时候频率为F，1的时候频率为2F。
  - 相位调制：

### 2.5.3 频分复用FDM

- 将频谱分为几个频段，每个用户完全拥有其中一个频段来发送自己的信号。相邻信道之间的频谱间隔足够大，以便防止干扰。

- 用频率区分不同的用户。将信号搬离到不同的频率，然后再在接收端还原到原来的频率。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203231813360.png" alt="image-20220323181358192" style="zoom:50%;" />

### 2.5.4 时分复用TDM

- 将信道的时间分解成离散的时间分片，每一个时间分片一个用户去占用，用户在时间片内发送信号。
- 为了适应时钟的微小变化可能要增加保护时间间隔。
- 同步时分复用：时间片的分配是固定的。
- 异步时分复用：时间片没有固定的分配，大家动态分配排队竞争。
  - 计网是采用异步的。
  - 如何区分是谁发的数据：在信息里嵌入一些其他标识性的东西，比如用户戳。

### 2.5.5 码分复用(CDMA)

- 给每个用户分配一个码片序列，如果用户发送的是1，那么就发送这个码片序列，如果发送的是0，就发送这个码片序列的反码。
- 不同的用户的码片是两两正交的。
- 多个用户的信号可以叠加在一起。
- 相互通信需要知道对方的片码





### 2.5.6 波分复用(WDM)

- 光纤上的频分复用。
  - 使用不同波长的信号。
  - 多模光纤。
  - 在接收端分开。





## 2.6 公共电话交换网络

### 2.6.3 本地回路：调制解调器、ADSL和光纤

- 本地回路的问题：
  - 衰减
  - 延迟畸变
  - 噪声
- 调制解调器：在发送端对计算机发出的数字信号进行调制，调制成模拟信号，在接收端对信号进行解调，还原成数字信号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203251330976.png" alt="image-20220325133053770" style="zoom:33%;" />

- DSL：数字用户线

- 中继线和多路复用

### 2.6.5 交换

- 电路交换：当计算机或电话发出一个电话呼叫时，电话系统的交换设备就会寻找到一条从你通向被叫电话的物理路径。
- 包交换：





# 第3章 数据链路层

- 两台相邻机器实现可靠有效的完整信息块通信的算法。
- 相邻：两台机器通过一条通信信道连接起来，通信信道在概念上就像一条线路。
- **信道上传递的比特顺序与发送顺序完全相同。**

## 3.1 数据链路层的设计问题

- 数据链路层的功能：
  - 向网络层提供一个定义良好的服务接口。
  - 处理传输错误
    - 错误侦测
    - 错误纠正
  - 流量控制。确保慢速的接收方不会被快速的发送方淹没。

- 为了实现这些目标，数据链路层从网络层获得数据包，然后将这些数据包封装成帧以便于传输。
  - 每个帧包含一个帧头、一个帧尾、一个有效载荷（用于存放数据包）。

### 3.1.1 提供给网络层的服务

- 数据链路层将数据从源机器的网络层传输到目标机器的网络层。
- 我们使用图(a)的模型：两个数据链路层的进程使用一个数据链路层协议进行通信。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203251722451.png" alt="image-20220325172218267" style="zoom:33%;" />

- 数据链路层通常会提供的服务：
  - **所谓的确认，指的应该是确认发送的帧是否已经正确到达目的地。**
  - **在数据链路层上提供确认只是一种优化手段，永远不应该成为一种需求。**
    - 对于可靠性极高的信道，比如光纤，这种开销可能就是没有必要的。
    - 但在无线信道上，由于其自身内在的不可靠性，这种开销就是值得的。
  - 无确认的无连接服务：源机器向目标机器发送独立的帧，目标机器并不对这些帧进行确认。
    - 不需要建立和释放逻辑连接。
    - 数据链路层不会去检测丢帧以及恢复丢失帧。
    - 适用场景：错误率很低的场合，差错恢复交由上层完成。
    - 适用场景：数据迟到比数据受损更难以忍受的情况，实时通信。
  - 有确认的无连接服务：发送的每一帧都需要单独确认，这样发送方可知道一个帧是否已经正确地到达目的地。
    - 仍然没有使用逻辑连接。
    - 如果一个帧在指定时间间隔内还没有到达，则发送方将再次发送该帧。
    - 适用场景：不可靠的信道，比如无线系统，802.11(WiFi)。
  - 有确认的有连接服务：源机器和目标机器在传输任何数据之前要建立一个连接。
    - 连接上发送的**每一帧都被编号**，数据链路层确保发出的每个帧都会被接收方接收到。
    - 数据链路层保证**每个帧只被接受一次**，并且**所有的帧按正确的顺序被接收**。
    - 使用面向连接的服务时，数据传输经过的三个阶段：
      - 第一阶段，建立连接，双方初始化各种变量和计数器，**这些变量和计数器记录哪些帧已经接收到，哪些帧还没有收到**。
      - 第二阶段，传输数据帧。
      - 第三阶段，释放连接，将所有的变量、缓冲区以及其他用于维护该连接的资源释放。

### 3.1.2 成帧

- 数据链路层要对接收到的比特流进行检测错误和纠正错误的工作。
- **Header和Trailer都是属于帧内的。**
- 检测错误的通常做法：
  - 源机器的数据链路层将比特流拆分为多个帧，为每个帧计算一个称为校验和的短令牌，并将该校验和放在帧中一起传输。
  - 目标机器接收到帧，重新计算该帧的校验和，如果新算出来的校验和与传输过来的校验和不同，则数据链路层知道传输过程中产生了错误。
  - 处理错误的措施，比如丢掉坏帧，发回一个错误报告。
- **拆分比特流的方法**：一个好的设计方案必须使接收方容易发现一个新帧的开始，同时所使用的信道带宽要少。
  - 字节计数法：在头部中的一个字段来标识该帧中的字符数。当接收方看到字符计数值时，就知道后面跟着多少个字节。**用得少**
    - 存在的问题：计数值可能在传输过程中出现错误。导致从出错的帧起始位置开始，后面的全部帧都找不到正确的起始位置。具体看图。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203251834918.png" alt="image-20220325183416605" style="zoom: 33%;" />
  - 字节填充的标志字节法：考虑了出错之后的重新同步问题。每个帧用一些特殊的字节做为开始和结束。
    - 这些特殊字符通常都相同，称作标志字节(flag byte)，作为帧的起始和结束分界符。
    - **两个连续的特殊字节就代表了前一帧的结束和后一帧的开始。**
    - **如果在要传输的数据本体出现了标志字节：发送方的数据链路层在处于数据之中的标志字节的前面插入一个特殊的转义字节(ESC)，通过查看标志字节前有无转义字节，就可以区分作为帧分界符的标志字节和作为数据的标志字节。**
    - **接收方的数据链路层在将数据传递给网络层之前必须删除转义字节。**所有情况下，去掉填充字节之后交给网络层的字节序列都与原始序列相同。
    - **如果转义字节也作为了数据，那么给转义字节再填充一个转义字节。**转义字节并不是帧分界符，所以并不会影响帧的划分。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203252024064.png" alt="image-20220325202409822" style="zoom: 33%;" />
  - 比特填充的标志比特法：每个帧的开始和结束由特殊的比特模式`0x7E(01111110)`标志。
    - 优化了字节填充只能使用以字节为单位的缺点。
    - 比特翻转可能会导致帧中间出现一个Flag，也可能导致两相邻帧之间的Flag消失，两个帧合并。**但是没关系，只会影响到这两个帧而言，不会影响其他帧。**
    - **一个帧的两端可以有多个帧标志。并不一定是一端只有一个帧标志。**
    - 帧的划分可以在比特级完成。帧可以包含任意比特数，而不是只能以8比特为单元。
    - 发送方的数据链路层在数据中遇到连续5个1，就会在输出的比特流中第5个1的后面填入一个0。**这样的做法是保证发送方`输出的(原始数据可能会有，但是用于传输的一定不会有)`数据中不会出现连续6个1的标志模式。**（也就是说用户数据中如果包含01111110，用于传输的实际上是011111010）
    - 接收方的数据链路层看到连续入境5个1，后面紧跟着一个比特0，它就会自动剔除比特0。
    - **比特填充对双方的网络层是完全无感的**
    - 比特填充技术在失去同步的情况下也很容易找到帧的边界，因为这些标准只可能出现在帧的边界，不可能出现在数据中。
    - 比特填充和字节填充的**副作用**：一帧的长度取决于它所携带的内容，如果数据中全是标记字节，帧的长度要增长一倍，比特填充则增长大约八分之一。
  - 物理层编码违禁法：看图。
    - 比如曼彻斯特编码，使用的是高低(HL)为1，电平低高(LH)为0，这时候就有常高（HHHHHH...）和常低（LLLLLLL...）既不为0，也不为1，可以用来做帧的分界标志。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203252102571.png" alt="image-20220325210215339" style="zoom:33%;" />
- 许多数据链路协议为安全起见综合使用了上述划分比特流的方法。如WiFi：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203252103005.png" alt="image-20220325210357840" style="zoom: 33%;" />
- 这一节解决了如何标识每一帧的起始和结束位置的问题。



### 3.1.3 差错控制

- 这一节解决如何确保所有的帧最终都被传递给目标机器的网络层，并且保持正确的顺序。
- 现在假设接收方可以知道它收到的帧包含了正确的或者错误的信息。

- 确保可靠传递的常用方法是接收方向发送方发送一些有关线路另一端状况的反馈信息。
  - 协议要求接收方发回一些特殊的控制帧，这些控制帧中**对于**它**所接收到的帧进行**肯定的或否定的确认。
  - 肯定的确认表明帧已经安全到达（并且没有错误），否定的确认意味着传输过程中产生了错误（**到达了**，但是数据有错误），这帧必须重传。
  - **更复杂的情况：**某一帧在传输过程中直接完全丢失了，根本**没有到达**接收方。**或者是帧到达了但是确认信息在传输过程中丢失了。**
    - （对应前一种）那么接收方也就没有办法发回一个控制帧，因为没有收到帧，它会没有任何反应。
    - 发送方也不知道该如何处理，因为接收方没有发回控制帧（或者是控制帧丢失了），它会永远等待下去。
  - **解决这个更复杂的情况的方法**：在数据链路层引入计时器来解决。
    - 发送方在发出一帧时，也会启动一个计时器。
    - 计时器的超时值要设置得足够长，以保证正常情况下帧能够到达接收方，接收方发回的控制帧（确认信息）能够传回给发送方。
    - 帧被正确接收，确认帧也被传回来后，计时器取消。
    - 没有收到确认帧（**可能是发送帧丢失了，也可能是控制帧丢失了**），则计时器被触发，从而警告发送方存在问题。
    - 丢失的帧可以通过重发解决，但是要避免接收方将**接收到的重复的**帧多次传给网络层（控制帧丢失的情况）。给帧分配序号以解决。
- 管理好计时器和序号，以保证每一帧最终都恰好一次被发送给接收方的网络层，是数据链路层工作的重要组成部分。



### 3.1.4 流量控制

- 解决发送方发送帧的速度超过了接收方能够接收这些帧的速度，发送方该如何处理的问题。
  - 在接收方被帧淹没的情况下，即使所有的帧都成功到达了接收方，数据也没有问题，也必然会丢弃一些帧。
- 常用的两种方法：
  - 基于反馈的流量控制(feedback-based flow control)：接收方给发送方返回信息，允许它发送更多的数据，或者至少告诉发送方自己的情况怎么样。
    - 停-等：发一帧等待一次，收到反馈再发下一帧，没收到反馈（超时）就重发。
    - 滑动窗口协议：一次发送若干个帧再等响应。
  - 基于速率的流量控制(rate-based flow control)：使用这种方法的协议有一种内置的机制，它能限制发送方传输数据的速率，而无须利用接收方的反馈信息。
- 基于速率的流量控制方案仅在传输层的一部分中可见，基于反馈的流量控制方案则出现在链路层以及更高层。
- 基于反馈的流量控制大多数使用了同样的基本原理，使用规则规定了发送方什么时候可以发送下一帧。



## 3.2 差错检测和纠正

- 差错的分类：
  - 丢帧：帧根本没有到达接收端。
  - 帧受损：帧标志没坏，帧内若干比特翻转了。

- 对于某些信道来说，传输出错是常态，而从性能的角度看，这些错误不能在合理的成本开销内彻底解决。
- 针对错误处理的两种策略：两种策略都在发送的数据中加入冗余信息。
  - 使用纠错码，在每一个被发送的数据块中包含足够多的冗余信息，接收方能够根据冗余信息推断出被发送的数据是什么，也叫前向纠错。
  - 使用检错码，包含的冗余信息只能让接收方推断出是否发生了错误，而推断不出哪个发送了错误，然后接收方可以请求重传。
  - **无论纠错码还是检错码都不可能应对所有可能的传输错误，因为提供保护措施的冗余比特本身就可能出错。**
- 每一种错误处理的策略都占据着不同的生态位置。
  - 在高度可靠的信道上（比如光纤），使用检错码即可，偶尔发生错误时只需要重传整个数据块，数量很少。
  - 在错误发生较频繁的信道上（无线链路），使用纠错码，FEC被用在有噪声的信道上，**因为重传的数据本身可能也出错**，倒不如直接纠错。

- 两种错误模型：
  - 偶尔出现的极端热噪声快速淹没了信号，引起孤立的单个比特错误。
  - 源自物理过程，如瞬态电气干扰，传输错误往往呈现突发性而不以单个形式出现。



### 3.2.1 纠错码

- **单向通信那就只能有检错码了，因为反馈信息没办法回传，也就没办法请求重发帧。**

- 4种不同的纠错编码：
  - 汉明码。剩下三种知道个名字就好。汉明只需要掌握单比特纠错。
  - 二进制卷积码
  - 里德所罗门码
  - 低密度奇偶校验码
- 一帧由m个数据位（即信息）和r个冗余位（即校验）组成。
- 在块码(block code)中，r个校验位是用与m个数据位相关的函数计算获得的。
- 系统码(systematic code)：直接发送m个数据位，然后发出r个校验位，而不是在发送前对它们进行编码。
- 线性码(line code)：r个校验位是作为m个数据位的线性函数被计算出来的。
- 记帧的总长度n = m + r，将此描述为(n, m)码。
- 一个包含数据位和校验位的n位单元称为n位码字。码率是 m / n，数据本身占的比例。高度可靠信道上码率接近1，而有噪声的信道上可能只有0.5。

#### 汉明码

- 将两个码字按位异或，然后计算结果中的1的个数，即为两个码字不同的位数，也就是汉明距离。
  - 如果两个码字的汉明距离为d，那么需要d个1位错误才能将一个码字转变成另一个码字。
- 编码方案的距离：方案中任意两个编码的距离的最小值。码表的汉明距离越大，冗余度越多。
- 为了可靠地检测d个错误，需要一个距离为d + 1 的编码方案。

  - 因为在这个编码方案中，d个1位错误不可能将一个有效码字改变为另一个有效码字。当接收方看到一个无效码字，他就知道发生了传输错误。
- 为了纠正d个错误，需要一个距离为2d + 1 的编码方案。
  - 只有满足这个条件，才能使得正确的编码恰好是离错误编码（汉明）距离最近的编码。
  - 或者说，在这样的方案中，合法码字之间的距离足够远，即使d位发生变化，结果还是离它原来的码字最近。
  - 这就意味着可以根据纠错码唯一地确定原来的码字。
- 比如汉明距离为5的码表，它可以纠正两比特的错误，可以检测出四比特的错误。
- 关于**纠正单比特错误**的汉明码的所需最少校验位数的结论：m + r + 1 <= 2^r^。
- 关于汉明码的编码方案：
  - 2的幂次方位作为校验位，其余位用来填充数据。

- 一个采用偶校验的( 11, 7 )码计算ASCII字母A的例子：**只能解决1个比特的错误**

  - 首先在发送端，发送的码字是(0 0 1 0 0 0 0 1 0 0 1)，这个如何来的：

    - 十一位的码字，7位数据位，4位校验位。从左往右，从1开始计数，依次递增编号。
    - 编号是2的幂的位置作为校验位，其他的位作为数据位，也就是1,2,4,8位为校验位，其余为数据位。
    - 依次记作(C~1~  C~2~  M~3~ C~4~ M~5~ M~6~  M~7~ C~8~ M~9~ M~10~ M~11~)。
    - 将各数据位的编号写作2的幂之和。左边是数据位的编号，右边是数据位所参与的校验位的编号
      - 3 = 1 + 2，1和2号校验位参与3号数据位的校验。
      - 5 = 4 + 1，6 = 4 + 2 ，7 = 4 + 2 + 1，9 = 8 + 1 ，10 = 8 + 2, 11 = 8 + 2 + 1 

    - 然后统计各个校验位参与的数据位的情况。某个校验位的1的个数加上它所参与的数据位的1的个数应该满足偶校验的条件。
      - 1号校验位参与了3 、5、 7、 9、 11号的校验，这些数据位总共有两个1，采用偶校验，故C~1~号位的值为0。
      - 2号位参与3 6 7 10 11，总共两个1，故C~2~号位也为1。以此类推。

  - 然后在接收端，接收到的码字是(0 0 1 0 1 0 0 1 0 0 1)，这个是有一位出错的码字。

    - 首先根据各个数据位的情况，重新计算各个校验位的值，与码字中的校验位的值去比对，发现有对不上的，说明传输出错。
    - 分别针对8 4 2 1位的计算校验码，得到的是0 1 0 1
    - 说明同时参与第4位和第1位校验码计算的那个比特出了问题，也就是编号为5和编号为7的出现了问题。
    - 但是编号为7的还参与了第2位校验码的计算，而第2位校验码并没有出错。所以是编号为5出错。
    - **简化一下，把出错的校验位的编码加起来，就是出错的数据位的编号。**
    - 将编号为5的地方的比特值翻转一下，就得到了原先的正确的码字。
    - 再将纠错后的码字中的校验位去掉，得到全部的信息。

### 3.2.2 检错码

- 相比光纤，无线链路嘈杂不堪而且容易出错，如果没有纠错码，将很难从该链路获得任何信息。
- 光纤或高品质的铜线的错误率要低得多，所以对于偶尔出现的错误，采用错误检测和重传的处理方式通常更加有效。
- 发送方根据数据计算出校验码，把校验码和数据一起打包到一帧内，发送过去，接收方接收到帧之后，用同样的方法计算校验码，和收到的校验码比对，对不上就说明出错，请求重传，对得上就接收这一帧，发回肯定的确认。
- 三种检错码：
  - 奇偶校验码
  - 校验和：课上一笔带过了，不管
  - 循环冗余校验：要求掌握。
- 奇偶校验：
  - 只能检验一比特的错误。（只能检验奇数个数的比特差错）

- 循环冗余校验（CRC）：也称为多项式编码
  - 基本思想：将位串看做是系数为1或0的多项式。一个K为的比特串看做是一个K - 1次多项式的系数列表。
    - 多项式的次数从0到K - 1，比特串的每一位都是对应的多项式的系数，**次数的排列左端是K - 1**。
      - 如110001：1 * X^5^ + 1 * X^4^ + 0 * X^3^ + 0 * X^2^ + 0 * X^1^ + 1 * X^0^。 
  - 两个（被看成多项式的比特）多项式的加和减运算**都是**对两个多项式进行**按位异或**。
  - 使用多项式编码时，发送方和接收方必须预先商定一个生成多项式，记作G(x)。
    - 生成多项式的最高位和最低位系数必须是1。
  - 发送方在帧的**尾部附加（Trailer出现力！）**一个校验和，使得附加之后的帧所对应的多项式能被G(x)除尽。
  - 接收方收到帧之后，就用G(x)去除它，如果有余数，说明传输过程中有错误。
    - **还是不可能检测出所有的错误，如果足够巧合，出错之后的码字对应的多项式也能够整除G(x)，那就逃过了**。
  - 计算CRC的算法：阶：最高幂次的值
    - 假设G(x)的阶为`r`，在帧的低位端加上`r`个0位（计算机中其实就是**左移r位**），使得该帧现在包含m + r位，对应多项式为x^r^M(x)
    - 利用模2除法，用对应于G(x)的位串去除对应于x^r^M(x)的位串。
    - 利用模2减法，从对应于x^r^M(x)的位串中减去余数（**加减是一样的，都是按位异或）**。结果就是将被传输的带校验和的帧。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203262048443.png" alt="image-20220326204807159" style="zoom:33%;" />









## 3.3 基本数据链路层协议

- 在学习协议之前，先明确一些有关底层通信模型的基本假设：

  - 首先假设物理层、数据链路层和网络层都是独立的进程，它们通过来回传递消息进行通信。
    - 物理层进程和某些数据链路层进程运行在一个称为网络接口卡的硬件上。
    - 数据链路层进程的剩余部分和网络层进程作为操作系统的一部分运行在CPU上，链路层进程的软件通常以设备驱动器的形式存在。
    - 首选的实现方式会随技术权衡发生变化。
    - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203262117894.png" alt="image-20220326211736747" style="zoom:50%;" />

  - 第二个假设：机器A希望用一个可靠的、面向连接的服务向机器B发送一个长数据流。
    - 先只考虑单工的情况，之后再推向双工。
    - 假定A所要发送的数据总是已经准备好了，不必等待网络层数据生成。也就是说，网络层总是能够立即满足数据链路层的请求（后续会去掉）。
  - 第三个假设：机器不会崩溃，也就是说这些协议只处理通信错误，不处理因为机器硬件出错崩溃而引起的问题。

- **在涉及数据链路层时，通过接口从网络层传递到数据链路层的数据包对于数据链路层来说是纯粹的数据，数据链路层会把它从网络层接收到的一切比特原封不动地发送给接收方的网络层。**目标机器的网络层可能会把接收到的数据的一部分解释为一个头，但这不是数据链路层要考虑的范围。

- 数据链路层接收到一个数据包，它就在数据包前后增加一个数据链路层`Header`和`Tailer`，由此把数据包封装在一个帧中。

  - 一个帧由一个内嵌的数据包，头部中的控制信息，尾部的校验和组成。
  - 被封装好的帧被传输到接收方机器的数据链路层。
  - 我们假设有现成的代码完成计算和附加校验和，以及检查校验和是否正确的工作，这一部分我们无需考虑，通常由硬件完成。

- 当一帧到达接收方，校验和被计算和对比。

  - 如果校验和对不上，数据链路层会收到帧损坏的通知。
  - 校验和对上了，数据链路层也会收到帧完好的通知，于是数据链路层调用代码得到该帧，并对其进行处理。
    - 检查头部的控制信息，没有问题就将内嵌的数据包传递给网络层。
    - 帧头的信息不会被交给网络层。（保证良好的封装性，保证层与层之间的完全分离）

- 后面要讨论的许多协议公用的一些声明：`protocol.h`

  - 一帧中的`kind、seq、ack`包含控制信息，称作帧头。

  - 控制帧的`info`字段没有用处。

  - 网络层从传输层获得一个报文，然后在该报文上增加一个网络层头，由此创建一个数据包。这个数据包传递给数据链路层，放到`info`字段

    ```c
    #define MAX_PKT 1024  /*determines packet size in bytes*/
    typedef enum (false,true} boolean; /*布尔类型*/
    typedef unsigned int seq_nr; /*用来对帧编号，0<= 编号 <= MAX_SEQ*/
    /*网络层发给自己的数据链路层或对方网络层的数据包，实际环境中大小应该是可变的*/
    typedef struct {unsigned char data[MAX PKT];} packet;
    typedef enum (data, ack, nak) frame kind; /*这一帧是数据帧，还是肯定确认帧，还是否定确认帧*/
    typedef struct{
        frame kind kind; /*这一帧是哪种类型的帧，*/
        seq nr seq;/*这一帧的编号*/
        seg nr ack;/*确认*/
        packet info;/*网络层使用的那个数据包*/
    }frame;/*数据链路层要传输的帧*/
    /* 等待事件的发生，将事件的类型放在event中*/
    void wait_for_event(event type* event) ;//没有帧到达的时候，将进程挂起
    /*从网络层抓取一个包以在信道上传输*/
    void from_network_layer(packet* p);
    /*将到达帧中的信息传递给网络层*/
    void to_network_layer(packet* P);
    /*从物理层中获得一个到达帧，将其拷贝到r中*/
    void from_physical_layer(frame *r);
    /*将帧传递给物理层以便传输*/
    void to_physical_layer(frame *s);
    /* 启动计时器并启用超时事件*/
    void start_timer(seq nr k) ;
    /*停止计时器并禁用超时事件*/
    void stop_timer(seqnr k) ;
    /* 启动辅助计时器并启用确认超时事件.*/
    void start_ack_timer(void) ;
    /* 停止辅助计时器并禁用确认超时事件*/
    void stop_ack_timer(void) ;
    /* Allow the network layer to cause a network_layer ready event.*/
    void enable_network_layer(void) ;
    /*Forbid the network layer from causing a network layer ready event.*/
    void disable_network_layer(void)
    /* Macro inc is expanded in-line;increment k circularly.*/
    #define inc(k) if (k < MAX SEO) k=k +1: else k =0;//循环的编号，不会去使用无限长递增
    ```


### 3.3.1 一个乌托邦式的单工协议

- 假设：
  - 不需要考虑任何出错的情况
  - 数据只能单向传输
  - 发送方和接收方的网络层总是处于准备就绪的状态
  - 数据处理的时间忽略不计
  - 可用的缓存空间无穷大
  - 数据链路层之间的通信永远不会损坏帧或丢失帧
- 其他看图。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203271432949.png" alt="image-20220327143247631" style="zoom: 50%;" />





### 3.3.2 无错信道上的单工停-等式协议

- 假设信道不会出错，数据流量还是单工的。
  - 不会出错决定了发送方的数据链路层根本不会检查它接收到的来自接收方的哑帧，因为它总是接收方的肯定确认。
- **引入流量控制，发送方发送的帧将接收方淹没。**
- 停-等式协议：
  - 接收方将数据包传递给网络层后给发送方发送一个许可（哑帧），发送方收到许可后才能继续发送。
  - 数据流量是单工的（从发送方到接收方），但是帧是双工的（接收方也要发送哑帧作为确认给发送方）。
  - **采用一个半双工的物理信道。**
- 伪代码：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203271441014.png" alt="image-20220327144144741" style="zoom:50%;" />





### 3.3.3 有错信道上的单工停-等协议

- 考虑常规的情形：
  - 信道可能会出错。
    - 帧可能会到达，但是是损坏的帧。
    - 帧可能根本没有到达，直接丢失。
    - 帧可能完好无损的到达，但是接收方回传的肯定的确认帧丢失。
    - 接收方回传的否定的确认帧丢失。
  - 对于不太可能出现的，帧损坏之后仍然通过了校验的情况（也即损坏帧逃过了检测），由于数据链路层没有检测出，网络层递交了错误的数据包，我们直接认为数据链路层及其更上层的所有协议失败。
  - 必须要有帧序号，保证数据链路层不会将已经递交过的数据包重复递交给网络层。
    - 这种情况可能发生在：
    - 到达帧完好无损，但是接收方发回的确认帧丢失了。
    - 发送方没有收到确认帧，于是认为帧没有成功到达接收方，于是重传该帧。
    - 重传的帧完好无损地到达，由于没有序号，又被接收方数据链路层重复递交了一遍。
- 对于协议的序号至少需要用多少位表示，没有明确规定，由链路层协议自己决定。只需要帧携带的序号足够大到保证协议正常工作即可。
- **关于检查序号以确定是否是重复帧:**
  - **由于预期序号就两种情形：原来的序号、下一个新序号。所以使用一个比特就可以。**
  - **或者说，预期的帧就两种情形，是新的帧，不是新的帧（预期旧的重传）**
  - 一比特的编号空间只能做到停-等。
- 工作过程:
  - 发送方发出一帧，启动计时器，如果计时器此前已经在运行，就重置计时器。
    - 计时器的超时值应该足够长，取帧到达，并被接收方按照最坏情形处理，然后确认帧到达发送方所需的全部操作时间。
    - 超时间隔太短，发送方就会发送一些不必要的重复帧，会大大降低协议的性能。
  - 启动计时器后分三种情形：
    - 确认帧完好无损的到达了发送方，则发送方从它的网络层获取下一个数据包，并把它放入缓冲区覆盖掉原来的数据包，同时递增帧的序号。
    - 如果到达了一个受损的确认帧，或者计时器超时，则缓冲区和序号都不做任何改变，以便重传原来的帧。
  - 当一个有效帧到达接收方：
  - 接收方先检查序号，确定是否为重复帧，如果不是则接受该数据包并将它传递给网络层，然后生成一个确认帧。
  - **即便是收到了重复帧，也要为这个重复帧回送一个ack，这个ack其实就是告诉发送方我已经收到了（虽然这个被我丢掉了）。**
    - 毕竟只要收到重复帧，那就说明此前的ack没有在超时之前到达发送方（所以才会有重发），所以你要再发一个ack（不发万一前面那个ack丢了呢，你又不能确定此前的ack是晚到了还是丢掉了，所以还是重发一个ack吧）。
  - **接收到一个帧，不管重复不重复，就要回送一个确认帧。**
  - 重复帧和受损帧不会被传递给网络层，但它们的到来会导致最后一个被正确接收到的数据帧的确认重复发送，返回给发送方。



- **协议的本体，PPT上的伪代码可读性更好。**
- 与国际化标准不同的是ack，教材上的ack的含义是接收方收到的那个帧的序号，而标准化的应该是，接收方预期收到的下一个帧的序号。

## 3.4 滑动窗口协议

- 实现全双工的一种最容易想到的方法：
  - 同时运行前面提到的协议的两个实例，两个实例分别负责一个方向上的数据传输。
  - 单个协议实例的链路有两条通道，一个“前向”（用于数据），一个“逆向”（用于确认）。
  - 问题在于，逆向的链路带宽大部分被浪费了。
- 改进：使用同一条链路来传输两个方向上的数据，毕竟即使是单工的，也已经在两个方向上传输帧了。
  - 从机器A到机器B的数据帧和确认帧混合在一起，接收方只要检查入境帧头部的`kind`字段来区别数据帧和确认帧即可。
- 进一步改进：捎带确认(piggybacking)：将确认信息捎带在下一个处境数据帧上。
  - 当机器A的数据帧到达机器B并被B递交给网络层，B并不立即发出一个单独的控制帧，而是等待B的网络层传递给它下一个数据包。
  - B接收到它的网络层传递给它的数据包之后，将确认信息附加在这个即将发送给A的数据帧上。
  - 好处：更好的利用了信道的可用带宽。
- **捎带确认的问题**：
  - 如果捎带方的网络层太长时间没有传递给数据链路层一个数据包，那么捎带的确认就没有办法在超时周期之内到达，就会导致帧重传。
  - **解决方法**：捎带方等待一个固定的毫秒数，如果在这个毫秒数之内，网络层没有传递数据包给数据链路层，那么就发送一个单独的确认帧。
- 滑动窗口协议：
  - 任何一个出境帧都有一个序号。通常是0到2^n^ - 1。
  - 所有滑动窗口协议的本质是在任何时刻发送方总是维持着一组序号，分别对应于允许它发送的帧，称这些帧落在发送窗口(sending window)内。
  - 接收方也维持着一个接收窗口，对应于一组允许它接收的帧。
  - 发送方的窗口和接收方的窗口不必有同样的上下界，甚至不必有同样的大小。
- 发送方的窗口内的序号代表了那些可以被发送的帧，或者那些已经发送但还没有被确认的帧，任何时候当有新的数据包从网络层到来，它被赋予窗口中的下一个最高序号，并且窗口的上边界前移一格。当收到一个确认时，窗的下边界也前移一格。
- 接收方的窗口对应于它可以接收的帧。任何落入窗口内的到达帧都会被放入接收方缓冲区，到达帧中序号等于窗口下边界的会被传递给网络层，同时整个窗口向前移动一个位置。任何落在窗口之外的帧都将被丢弃。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203291135042.png" alt="image-20220329113503792" style="zoom: 33%;" />
- 发送方数据链路层必须有足够多的缓冲区来维持发送窗口内的所有帧，如果窗口到达最大尺寸，则发送方的数据链路层会强行关闭网络层。



### 3.4.1 1位滑动窗口协议

- 发送方必须在发出一帧后收到确认帧，才能发送下一帧。所以使用的是停-等式。
- **在一般情况下，两个数据链路层中的某一个先开始发送出第一帧，整个过程才能开始。**
  - 那个先发送第一帧的数据链路层，协议中才需要包含循环外部的`to_physical_layer()`和`start_timer()`语句。另外一方不需要。
  - 关于协议的解读老师讲得很好。
  - 协议本体：<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202203291347477.png" alt="image-20220329134723223" style="zoom: 50%;" />



### 3.4.2 回退N协议

- 停-等式在长发送时间、高带宽、短帧的情况下，带宽会被极大的浪费，因为大部分时间之下大部分带宽都空闲着，等待一个小确认帧。
- 放宽停-等式协议的限制，也就是允许发送方在阻塞之前发送多大W个帧，而不是一个帧。只要W够大，发送方就可以连续发送帧，因为在W被填满之前，确认帧就返回了，因而防止了发送方进入阻塞。
- 合适的W的值：首先定义b*d = 带宽 * 链路的延迟，称作带宽-延迟乘积，将它除以帧的比特数，化作以帧为单位，记为BD，则W = 2BD + 1。
- 对于较小尺寸的窗口（也就是W的值较小），链路层常常会被阻塞，链路的利用率将小于100%。
- 链路利用率 <= W / (1 + 2BD)，右边是上限，表明了W一定要大。
  - 取上限时，将帧的长度看做是0，并且将帧到达后的处理时间看做是0。
- 保证多个帧同时在传输的技术是管道化(pipelining)的一个例子。
- 管道化及差错恢复：损坏的帧到达接收方时，接收方如何处理后续到达的正确帧的方式。
  - 回退n(go-back-n)：接收方只需简单丢弃所有到达的后续帧，并且针对这些丢弃的帧不返回确认。 
    - 对应于接收窗口大小为1的情形。**发送方窗口大于1**
    - 由于丢弃了从出错帧开始的许多帧，针对出错帧的计时器第一个超时。
    - 如果在超时之前发送方的发送窗口已满，则管道变为空闲。
    - 第一个计时器超时后，发送方就会从出错帧或丢失帧开始，**重传所有未被确认的帧。**
    - 如果信道的错误率很高，会浪费大量带宽。
  - 选择重传(Selective repeat)：
    - 对应接收方窗口大于1的情形。**发送方窗口大于1**
    - 接收方将收到的坏帧丢弃，但接收并缓存坏帧后面的所有好帧。
    - 发送方超时时，只重传那个最早的未被确认的帧。
    - 如果重传的帧完好无损地到达了接收方，接收方就将它和缓存的帧按顺序递交给网络层。
    - **如果窗口很大，对链路层的内存需求很大。**
    - **选择重传常跟否定策略结合起来一起使用，即当接收方检测到错误，就发送一个否定的确认(NAK)，NAK可以直接触发重传而无需等待相应的计时器超时，可以提高协议的性能。**不管怎么样都有超时重传兜底。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204062047985.png" alt="image-20220406204701683" style="zoom: 33%;" />
- **协议5新增的特性：**
  - 抛弃了网络层永远有无穷多个数据包要发送的假设，当网络层希望发送数据包时，它触发一个`network_layer_ready`事件。
  - 新增了数据链路层和网络层之间的流量控制，阻止网络层给予数据链路层过多工作，`enable_network_layer`和``disable_network_layer`来启用和禁用网络层。
- **累计确认**：n号帧确认到达之后，自动确认n-1，n-2等帧。因为第n帧的ack到达，就说明前面的帧都被接收了。
  - 利用累计确认，可以不一定给每一帧都回传一个ACK。

- 发送方仍然要缓存已经发送出去的帧，因为可能需要重传未被确认的帧。
- 每到达一个确认，数据链路层都会检查是否可以释放出一些缓冲区，这样就可以从网络层接收新的数据。
- **多个未确认的帧就需要同样多个数的计时器，每一帧的超时是独立的，相互之间没有关系。**
- 软件模拟多个时钟：
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204071912589.png" alt="image-20220407191218241" style="zoom: 50%;" />
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202204071913082.png" alt="image-20220407191302915" style="zoom: 50%;" />

### 3.4.3 选择重传协议

- 如果错误很少发生，则回退n协议很好用。如果线路质量很差，重传的帧会浪费大量带宽。
- 选择重传协议允许接收方接收并缓存损坏帧后面的所有帧。
- 发送方和接收方各维持一个窗口：
  - 发送方：可发送或已发送但未被确认的序号。**窗口的大小从0开始，可以增大到一个预定值。**
  - 接收方：可接受的序号。**接收方的窗口大小是固定的。**
- 有关接收方窗口的工作过程：
  - 接收方为其窗口内的每一个序号保留一个缓冲区，与缓冲区关联的还有一个标志位，用来指明该缓冲区是否已满。
  - 每到达一个帧，链路层通过`between()`函数检查该帧是否落入窗口中，如果是，并且以前没有接收过该帧，则接受该帧，放入缓冲区。
  - 接收到的帧不管是不是网络层所需要的下一帧，只要符合条件就会被放入缓冲区，这一帧只会放在链路层，直到轮到它传递给网络层。
  - 当所有序号比上述帧小的帧都被传递给网络层，它才被传递给网络层。
- 有关接收方窗口大小：
  - 接收方窗口的最大尺寸不能超过序号空间的一半。
  - 如果窗口大小超过序号空间的一半，那么窗口移动之后，新窗口和老窗口覆盖的序号范围就会有重叠。（**或者说发送方和接收方的窗口不能重叠）**
  - 假如有一个新帧和重传的老帧有同样的序号（处于重叠范围内），那么接收方无法区分重传的老帧和新帧。
  - 假设采用三位的二进制序号，那么窗口的大小不应该超过4。如果0-3为旧窗口，则4-7为新窗口，通过接收到的帧的序号可以区分新老帧。
- 有关接收方的缓存大小：
  - 缓存区的数量和窗口的大小一样就行，三位序号空间的情况下，缓存区的个数为4，总大小为保存4帧所需空间。
  - 序号为`i`的帧落入`i MOD size`号缓冲区，`size`为窗口大小。
  - 也可以缓存区的数量和序列号的大小一样，这样序号为`i`的就落入`i`号缓存。
- 有关发送方计时器的个数：
  - 计时器的数量和缓冲区的数量一样，一个计时器和一个缓冲区关联，也就和发送出去的这一帧关联。
  - 当某个计时器超时，和这个计时器关联的那个缓冲区中的帧就会被重传。
- 协议5（上一个协议）假设了信道的负载很重，因为协议需要依赖反方向的帧实现捎带确认，如果反向的数据量很小，则确认会被延缓很长一段时间。极端情况下，如果反向完全没有流量，那么发送方的窗口很快会被填满，协议被阻塞。
- 为了不受反向流量的约束，在接收方采用辅助计时器：
  - 当一个按正常次序发送的帧到达接收方，接收方通过`start_ack_timer()`启动辅助计时器。
  - 计时器超时之前没有出现反向流量，则直接发送一个确认帧而不采用捎带确认的方式。
  - 辅助计时器超时引起的中断称为`ack_timeout`事件。
  - 辅助计时器的超时间隔应该足够短（显著短于发送方的计时器）以确保数据帧能被及时确认而不会出现发送方超时重传。
- 协议6的新特性：
  - 增加了NAK帧。当接收方有理由相信出现错误时，它就给发送方传回一个否定确认的帧。这个帧实际上是重传请求。
  - NAK中指定了要重传的帧。
  - 为了避免多次请求重传同一个丢失的帧，接收方应该记录下对于某一帧是否已经发送过NAK。
  - NAK丢失并不会有实质性的影响，总有接收方计时器超时重传兜底。
- **某些情形下**，一帧从发送到被接收再到确认帧被传回发送方，总时间几乎是个常数。这些情况下发送方可以把计时器调紧一些，让超时间隔略微大于总时间，这样NAK的作用就微乎其微了。
- **另一些情况下**，总时间的变化范围就非常大。如果反向流量的分布不均匀，那么会在某段时间内反向流量大，捎带确认快，总时间短。其他时间反向流量没有，则总时间很长。因此发送方必须做出选择。较短计时器（不必要的重传）还是较长计时器（发生错误时更长的空等）
- **当确认间隔的标准偏差与间隔本身相比非常大的时候，将计时器设置得松一些，借助NAK来加速重传**。





## 3.5 数据链路协议实例

- PPP：Point to Point Protocol，点到点协议。



### 3.5.1 SONET上的数据包

- PPP协议的3个主要特性：
  - 一种成帧方法。它可以毫无歧义地区分出一帧的结束和下一帧的开始。
  - 一个链路控制协议(LCP，`Link Control Protocol`)。它可用于启动线路、测试线路、协商参数，以及当线路不再需要时温和地关闭线路。
  - 一种协商网络层选项的方式。协商方式独立于网络层协议。所选择的方法是针对每一种支持的网络层都有一个不同的网络控制协议(NetworkCP)
- PPP帧的扫描过程：
  - 先扫描比特流，寻找`0x7E`





# 第4章 介质访问控制层

- 网络链路分为两大类，使用点到点连接和使用广播信道。本章讨论后者。

- 广播信道的关键问题在于信道分配，也就是多方竞争信道的使用权时如何确定谁可以使用信道。
- 用来确定多路访问信道下一个使用者的协议属于数据链路层的一个子层，称为介质访问控制子层(`MAC，Medium Access Control`)。

- 技术上来说MAC层位于数据链路层的底部。



## 4.1 信道分配问题

- 讨论如何在竞争用户之间分配单个广播信道。信道可以是无线频谱，也可以是连接着多个节点的单根电缆或光纤。
- 信道将每个用户与其他所有用户连接在一起，任何正在使用信道的用户和其他也想使用该信道的用户会相互干扰。

### 4.1.1 静态信道分配

- 在多个竞争用户之间分配单个信道的传统做法：

  - 将信道容量拆开分给多个用户使用。具体方法是某种多路复用。
  - 适用于用户数量较少且固定不变时，每个用户的流量稳定或负载重。
  - FM无线广播电台。
  - 问题1：不够灵活，用户数量变化大的情况下，可能大量频段被浪费，也可能某些用户得不到带宽。
  - 问题2：当拥有某个频段的用户不发送数据时，信道也无法转移给其他用户，带宽被浪费。

- 排队理论：

  - 记信道容量为`C bps`，发送一帧所需的平均时延为`T`。随机到达帧的平均到达率为$$\lambda$$帧，帧长度可变，其均值为$$1/ \mu $$位。
  - 则信道的服务率为$$\mu C$$帧/秒。
  - $$T  = 1 / \mu C - \lambda$$，注意是不存在信道竞争时的。

  - 如果将信道均分为N个独立的子信道，则子信道的容量为$$C/N$$，子信道的平均到达率为 $$\lambda / N $$，代入得$T_N = NT$
  - 对于静态划分的方法，将信道划分为N个子信道，则延迟扩大N倍。

  

  

### 4.1.2 动态信道分配的假设

1. 流量独立。模型由N个独立的站组成，每个站都有程序或用户产生要传输的帧。产生帧的到达率为$\lambda$，t时间内产生帧的总数为$\lambda t$。一旦生成出一帧，则站就被阻塞，直到该帧被成功发送出去。
2. 单信道。所有的站都只能使用这一个信道。所有的站可以在该信道传输和接收数据。所有的站能力都相同，尽管协议可能会给站分配不同的角色。
3. 冲突可观察。如果两帧同时传输，则它们在时间上就重叠，由此产生的信号是混乱的，这种情况称为冲突。所有的站都能检测到冲突事件的发生，冲突的（所有）帧必须在以后再次被发送（属于发送端主动采取的措施，不是可靠重传的问题）。除了因冲突产生的错误外，不会再有其他错误。
   1. 卷入冲突的帧也有可能成功被接收，但很少见，所以假设所有涉及冲突的帧都丢失。
   2. 冲突检测和信道的物理属性有关，比如有线还是无线。
4. 时间连续或分槽。时间可以是连续的，任意时刻都可以开始传输帧。时间也可以是离散的时间片，只能在时间片的开始传输帧，一个时间槽内可以有0或1或多个帧，分别对应无发送帧，成功发送一帧，帧冲突。
   1. 时间槽要求所有的站有一个主时钟，或者它们的行动与其他站同步。所以时间槽并不是永远可用的。
5. 载波侦听或不听。启用载波侦听，则一个站在试图用信道之前就能知道该信道当前是否正被使用，如果侦听到信道被占用，则不会试图使用这个信道。如果没有载波侦听，则站只能盲目地传输，以后再判断这次传输是否成功。
   1. 载波监听也不是总是可用的，有些网络就是没有载波侦听的。
   2. 有线网络通常可以载波侦听，无线网络则不能有效使用载波侦听。





## 4.2 多路访问协议

### 4.2.1 ALOHA

- 时间连续的就是纯ALOHA。
- 时间分槽，就是分槽ALOHA

#### 纯ALOHA

- 基本思想：
  - 用户有帧就直接发送。
  - 发送方通过某种手段检测是否发生了冲突。
  - 如果帧被损坏了，就等待一段随机时间，然后再次发送该帧。
  - 等待事件必须是随机的，否则同样的帧会再次冲突。

- 监听是否发生冲突的方式：
  - ALOHA中，每个站给中央计算机发送帧，由该计算机将帧广播出去，发送站可以收听来自集线器的广播以确定发送是否成功。
  - 如果收到的信号和发送出去的是一样的就成功了。
- 无论何时，只要两个帧在相同时间试图占用信道，冲突就会产生。
- 帧时(frame time)：传输一个标准的、固定长度的帧所需要的时间，帧长度除以比特率。
- 纯ALOHA的效率
  - 在$$G = 0.5$$ 时，最大效率$$S = G / 2e$$，约为0.184。



#### 分槽ALOHA

