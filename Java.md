# Java核心技术 第11版

# 第1章 Java程序设计概述

- Java是一个完整的平台，有一个庞大的库，其中包含很多可重用的代码，以及一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾回收等服务的执行环境。

## 1.2Java 白皮书的关键术语

### 1.2.6 体系结构中立

这个是关于，`java`是如何做到跨体系结构的可移植性的。

- 编译器生成一个体系结构中立的目标文件格式，这种编译过的代码只要有`java`运行时系统，就可以在不同的处理器上运行。
- `Java`通过生成与计算机体系结构无关的字节码指令来实现这一特性。
- 字节码可以在任何机器上**解释执行**，而且可以动态地转化为本地机器代码。
- 解释型虚拟机指令会比全速运行机器代码慢。
- **即时编译：将执行最频繁的字节码序列转换成机器码。**

### 1.2.7 可移植性

- **与C和C++不同，Java规范中没有“依赖具体实现”的地方。基本数据类型的大小以及有关运算的行为都有明确说明。**
  - 比如`Java`中`int`永远是32位的，`C`则“依赖具体实现”。数值类型有固定的字节数。
  - 个人理解对可移植性的好处在于，不管移植到什么平台去，用什么编译器，都不用担心由于不同编译器实现的`int`位数不同，使得要修改代码。
- 二进制数据使用固定的格式进行传输和存储。
- 字符串用`Unicode`储存。

### 1.2.8 解释型

- Java解释器可以在任何移植了解释器的机器上直接执行Java字节码。

### 1.2.9 高性能

- **即时编译**
  - 字节码可以在运行时动态地转换成相应的CPU的字节码。
  - 内联。

## 1.5 关于Java的常见误解

- **Java是解释型的：**
  - 早期的`Java`确实是解释型的。现在`Java`虚拟机使用了**即时编译器**，因此采用`Java`编写的“热点”代码（指那些运行频率高的字节码）运行速度与`C++`相差无几，有时候更快。
- `JavaScript`不是`Java`的简易版，`Java`是强类型的，`JavaScript`则不是。

# 第2章 Java 程序设计环境

## 2.1 安装Java开发工具包

### 2.1.1

- 一些Java术语：
  - JDK ：Java 开发工具包
  - JRE ：Java运行时环境，只包含虚拟机 
  - SE：标准版
  - EE：企业版
  - `OpenJdk`:Java SE的一个开源实现

# 第3章 Java的基本程序设计结构

## 3.1

- **Java类的命名必须以字母开头，且不能使用保留字**
- **源代码的文件名必须与公共类的名字相同**

## 3.2 注释

- 可以用来自动生成文档的第三种注释方法：
  - 以`/**`开始，以`*/`结束。

## 3.3 数据类型

### 3.3.1 整型

- 有一个`byte`型的有符号数。大小为一字节，范围为-128 到 +127。
- 要用二进制表示一个数，在数前面加`0b`或`0B`前缀。
- **Java没有任何无符号形式的整型。**但是有相应的类满足这个需求。

### 3.3.2 浮点型

- 三个特殊的浮点值
  - `NaN`:Not A Number。`Double.NaN`
  - 正无穷。`Double.POSITIVE_INFINITY`
  - 负无穷。`Double.NEGATIVE_INFINITY`
- 检查一个值`x`是否是特殊的浮点值：

```java
//错误的写法
x == Double.NaN;
//正确的写法：
Double.isNaN(x);
```

- 浮点值不适用于不接受舍入误差的计算。
  - 使用`BigDecimal`类。

### 3.3.3 char

### 3.3.4 Unicode和char

- 建议不使用`char`，将字符串作为抽象数据类型处理。

### 3.3.5  boolean 类型

- **整数和`boolean`类型不能相互转换**

## 3.4 变量与常量

### 3.4.1 声明变量

- 变量名大小写敏感。以字母开头，由字母与数字序列构成。
  - 字母与数字的范围更大，比如希腊字母也在这个字母的范围内。

### 3.4.2 变量初始化

- 不能使用未初始化的值。必须对变量进行显式的初始化，不过默认初始化为0和null。

- 关键字`var`。

### 3.4.3 常量

- 使用`final`关键字指示常量。
  - 目前`const`并未使用的关键字。
  - `final`表明这个变量只能被赋值一次。
  - 类常量可以用`static final`定义在main方法的外部。

### 3.4.4 枚举

## 3.5 运算符

### 3.5.1 运算符

### 3.5.2 数学函数与常量

- 使用`Math`类的各种函数

```java
import static java.lang.Math.*;
/*求余数的函数，用来处理对负数做模运算的*/
Math.floorMod(-1 , 2);// -1 % 2
Math.PI;//π
Math.E;//自然常数e
```

- `Math`类提供了一些比单纯使用运算符更好的安全性。
  - 运算符对溢出只会悄悄返回错误的结果而不做任何提醒。而使用Math的函数可以捕获这个异常。

### 3.5.3 数值之间的转换

- 二元运算符的转换优先级
  - `double` > `float` > `long` > `int`

- 会导致信息丢失的转换：
  - `int` ==> `float`
  - `long` ==> `float`
  - `long`==> `double`

### 3.5.4 强制类型转换

```java
//对浮点数进行舍入运算得到最接近的整数
int x = (int)Math.round(9.997);//返回值为long
```

### 3.5.5  +=  -= etc

### 3.5.6 ++ --

- 狗都不用

### 3.5.7 关系和Boolean运算符

- **逻辑与、逻辑或的短路求值**
- 三元操作符狗都不用。



### 3.5.8 位运算符

- 移位
  - java的右移操作一定是算术右移。也即`>>`使用符号位填充。`>>>`运算符则使用0填充高位。
- 按位与或非
- 没了

### 3.5.9 运算符优先级

## 3.6 字符串

- Java并没有内置的字符串类型，而是Java库中预定义的`String`类。

### 3.6.1 子串

```java
//substring(int startPos , int destPos);
//截取从startPos到destPos - 1 的字符
String H = "Hello";
String he = H.substring(0,3);//位置0到2的字符。
```

### 3.6.2 拼接

- 使用`+`拼接，被拼接的两个字符串之间并不会自动添加空格。
  - 非字符串的值与字符串拼接时会自动转换为字符串。
- `String.join(String ...)`
  - 将多个字符串拼接并使用给定的分隔符分割。

### 3.6.3 不可变字符串

- `String`类中并没有提供直接修改字符串中某个单个的字符的方法。
  - 如并不能直接将`Hello`修改为`Help!`。C的话直接从底层数组修改就好。
  - Java的`String`类其实更类似C的`char *`，而不是`char[]`数组。
- 使用字符串拼接。

```java
String str = "Hello";
str = str.substring(0,4) + "p!";
```

- 由于不能直接修改字符串中某个特定的字符所以`String`类称作不可变类。
  - 编译器可以让字符串共享。

### 3.6.4 检测字符串相等

- 使用`string1.equals(string2)`，不使用`==`。
  - ==检测的是地址是否相等。

### 3.6.5 空串与null

- **不是同一个东西**。
  - 空串(`""`)是长度为零的字符串。
  - `null`表示不与任何对象关联。
  - 检查字符串是否为`null`使用`==`，空串使用`str.equals("")`。
  - 检查一个字符串既不是空串也不是`null`。**先检查是不是null**。

### 3.6.6 码点与代码单元

略捏，不想看。

### 3.6.7 String API 

- 看文档的事
- Stack Overflow的事

### 3.6.9 构建字符串

- 使用字符拼接(`+`)来创建字符串很耗时间和空间。
  - 每拼接一个字符串都要创建一个新的`String`对象。
- 使用`StringBuilder`类。

```java
StringBuilder builder = new StringBuilder();
builder.append("Hello");
builder.append("World");
String HW = builder.toString();//HelloWorld, 单词之间没有空格
```

## 3.7 输入与输出

### 3.7.1 输入

- `Scanner`类

```java
import java.util.*;
Scanner in = new Scanner(System.in);//创建与标准输入流关联的scanner对象
int n = in.nextInt();//读取一个数
String str = in.nextLine();//读取一整行
String Aword = in.next();//读取一个单词，由空白分割
double d = in.nextDouble();
```

### 3.7.2 格式化输出

- `System.out.Printf()`

### 3.7.3 文件输入输出

- 读取文件：
  - 构造一个与文件关联的`Scanner`类对象即可。
  - 构造器的参数读文档去。
  - 注意路径反斜杠的转义。
  - 要已知文件的编码。
- 写入文件
  - 构造与一个文件关联的`PrintWriter`对象。
  - 要已知文件名及编码。
  - 正常调用`printf`等函数即可。

```java
import java.util.*;
import java.io.*;
PrintWirter out = new PrintWriter("..\\file.txt",StandardCharacters.UTF_8);
out.print("Hello");
```

## 3.8 控制流程

- 不看

- `break`
  - 带标签的相当于`goto`，否则和C的没什么区别。
- `continue`和C完全一样。

## 3.9 大数

- 用来处理需要绝对精度的算术运算的时候使用。
  - `BigInteger`：任意精度的整数运算
  - `BigDecimal`：任意精度的浮点数运算
  - 加减乘除都必须使用相应的方法，而不是直接使用运算符。

```java
import java.math.*;
import java.util.*
//将基本类型的数转换为BigInteger对象
BigInteger a = BigInteger.valueOf(114514);
//构造巨巨巨巨大的数
BigInteger reallyBig = new BigInteger("1145141919180");
BigInteger result = a.add(reallyBig);//result = a + b
```

- 其他的读文档吧。



## 3.10 数组

### 3.10.1声明数组

- 初始化数组的语法糖。

```java
int[] a = new int[5];
int[] b = {1,2,3,4, 5};
int[] c;
c = new int[] { 1 , 2, 3, 4};
```

- **可以声明长度为0的数组。**
  - 与`null`并不相同。

### 3.10.2 访问数组元素

### 3.10.3 for-each

### 3.10.4 数组拷贝

- `Arrays.copyOf()`
- `System.ArrarCopy()`

### 3.10.5 命令行参数

- **程序本身的名字并不在`args[]`数组中。**

```java
public class example {
    public static void main(String args[]) {
        if (args.length == 0 || args[0].equals("-h")) {
            System.out.print("Hello,");
        }
        else if(args[0].equals("-g")) {
            Systm.out.print("Goodbye,")
        }
        //打印剩下的命令行参数
        for(int i = 1 ; i < args.length ; i ++) {
            System.out.print(args[i] + " ");
        }
    }
}
java example -h nice World
    ===> Hello,nice World
//args[0] ==> "-h"
//args[1] ==> "nice"
//args[2] ==> "World"
```

### 3.10.6 数组排序

- 调用API的事

### 3.10.7 多维数组

- 不看，知道底层怎么回事就行。
- `for-each`循环要嵌套两层

### 3.10.8 不规则数组

- 二维数组由于底层实现的关系，可以交换两行。
- 也是由于同样的原因，二维数组的每一行的行长度甚至可以不一样，也就是不规则数组

```java
//初始化一个第i行有i个元素的不规则数组
int[][] a = new int[10][]//10行，但是不确定每一行的元素个数
for (int i = 0 ; i < 10 ; i ++) {
    a[i] = new int[i + 1];
}
```

# 第4章 对象与类

## 4.1 面向对象程序设计概述

- 每个对象对用户公开特定的功能，隐藏具体的实现。

### 4.1.1 类

- 封装：将数据和行为组合在一个包中，并将具体的实现方式对用户隐藏起来。
  - 对象中的数据：实例字段，`instance field`。
  - 实例字段的值的集合称为对象的状态。
  - 程序**只能**通过对象的方法与对象的数据进行交互。

- Java中所有的类都扩展自`Object`超类。
- 继承。

### 4.1.2 对象

- 对象的状态改变必须是通过调用对象的方法，如果不经过调用方法就可以改变对象的状态，只能说明破坏了封装性。
- 每个对象都有唯一的标识。

### 4.1.3 识别类

### 4.1.4 类之间的关系

- 依赖：use - a
- 聚合：has - a
- 继承：is - a

## 4.2 使用预定义类

- 有些类是没有数据的，不是所有的类都表现出面向对象的典型特征。

### 4.2.1 对象与对象变量

- 要使用对象，必须先构造对象并指定其初始状态，然后对对象应用方法。
- 构造器是一种特殊的方法，用来构造并初始化一个对象。
  - 构造器的名字应该和类名相同。
  - 对象变量引用一个对象
  - `new`。
- **对象变量并没有实际包含一个对象，它只是引用一个对象。任何对象变量的值都是对存储在另一个位置的某个对象的引用。**

### 4.2.2 

### 4.2.3 更改器方法与访问器方法

- 更改器方法：
  - 会更改原有对象的实例字段。
  - 破坏性方法。
- 访问器方法：
  - 访问原有的方法，但不对它做出改变
  - 返回一个新的对象。
  - 非破坏性方法。

## 4.3 用户自定义类

### 4.3.1 employee 类

- **一个`.java`文件中可以有多个类的，但是只能有一个`public`类，`.java`文件的名字要和`public`类相同**
- **类可以没有访问修饰符的，比如同一个文件中的类。**

```java
public class employeeTest {
    /**
    *实例字段
    */
    /**
    *方法
    */
    public static void main(String[] args) {
        /**
        *要有main
        */
    }
 }
//这个类不要嵌套到public类里面去
class employee {
        /**
        *实例字段
        */
        /**
        *方法
        */
    }
```

- 编译的时候会生成多个`.class`文件，`employee.class`和`employeeTest.class`

### 4.3.2 多源文件的使用

### 4.3.3 剖析employee类

- `public`访问修饰符
  - 任何类的任何方法都可以调用`public`的方法
  - 不要将实例字段标记为`public`

- `private`：访问修饰符

- **实例字段本身也可以是某一种类的一个对象。**

### 4.3.4 从构造器开始

- 构造器与类同名。
- 每个类可以有多个构造器。
- 构造器可以有0个到多个参数。
- **构造器没有返回值**
- 构造器总是与`new`一起使用。
- 在构造器中声明与实例字段同名的局部变量会造成同名的实例字段被局部变量遮蔽。

### 4.3.5 使用var声明局部变量

- **如果可以通过变量的初始值反推它们的类型，就可以用`var`关键字声明局部变量**

- **`var`关键字只能用于声明局部变量**
- **参数和字段必须声明类型**

### 4.3.6 使用null引用

- 对`null`使用方法会产生`NullPointerException`。

### 4.3.7 显式参数和隐式参数

- 显式参数：函数签名括号参数表里的
- 隐式参数：可以用`this`来指代



### 4.3.8 封装的优点

### 4.3.9 基于类的访问权限

- 一个方法可以访问`所属类的所有对象`的私有数据。不仅局限于隐式参数。

### 4.3.10 私有方法

- 只要方法是`private`的那么就可以保证这个方法不会在除了所属类以外的其他地方被使用。

### 4.3.11 final实例字段

- **被定义为`final`的实例字段必须要在构造对象时初始化**
  - `final`修饰的字段只能被赋值一次。

## 4.4 静态字段与静态方法

- 有关`static`修饰符

### 4.4.1 静态字段

- 被标记为`static`的实例字段将被类的所有实例共享。
  - 即使没有对象，`static`字段也存在，它属于类，不属于任何单个对象。

### 4.4.2 静态常量

- 即`static final`标记的变量。

```java
public class Math {
    public static final double PI = 3.1415926535;//即使声明为public也没关系，final保证了PI的值不会被修改
}
//使用Math.PI 来访问
//好处在于，可以无需构建一个Math对象就可以访问圆周率的值。
```

### 4.4.3 静态方法

- 静态方法是不在对象上执行的方法。
  - 可以认为静态方法没有隐式参数。
  - 静态方法不能访问实例字段，因为它不在对象上执行操作。
  - 静态方法可以访问静态字段。
- **但是是可以用一个实例对象来调用静态方法的。不过还是推荐用类名调用静态方法。**
- 适用静态方法的情况：
  - 方法不需要访问对象状态，它所需要的所有数据通过显式参数提供。
  - 方法只需要访问类的静态字段。

### 4.4.4 工厂方法

- 静态方法的一种常见用途。
  - 比如要初始化一个Date对象，为当前的时间，`Date now = Date.now()`比`Date now = new Date()`可读性好多了。
  - 为什么不是 `Date now = new now()`?因为构造器要和类同名。

### 4.4.5 main 方法

- main方法不对任何对象进行操作。
- 其实每个类都可以有一个`main`方法用作测试，测试完毕后甚至可以不需要删掉，在程序实际运行时这个测试用的`main`方法永远不会运行。

## 4.5 方法参数

- Java是按值调用传递参数。
  - 方法不能修改基本数据类型的参数。
  - 方法可以修改对象类型的参数的状态。

## 4.6 对象构造

### 4.6.1 重载

- **重载：多个方法有相同的名字，不同的参数。**
  - 构造器也是一种方法。构造器重载机制。
  - `Java`允许重载任何方法。不局限于构造器。
  - 编译器根据方法调用给定的参数查找匹配的方法的过程称作重载解析(`overloading resolution`)。

### 4.6.2 默认字段初始化

- **局部变量与字段的一个重要区别**
  - 方法中的局部变量不初始化无法使用
  - 在类中实例字段不显式初始化则会被赋予默认值

### 4.6.3 无参数的构造器

- 用无参数构造器构造对象，对象的实例字段被设置为默认值。
- 如果写一个类时没有编写构造器，会默认提供一个无参数构造器。
- **如果提供了有参数构造器，没有显式提供无参数构造器，在构造对象时无法合法调用无参数构造器（构造对象时必须通过参数）。**
- **当且仅当**类没有任何其他构造器时，才会得到一个默认的无参数构造器。

```java
//显式提供无参数构造器，这样写即可。
public ClassName() {
    //什么都不写。
}
ClassName d = new ClassName();
```

### 4.6.4 显式字段初始化

- **可以直接在类定义中为任何字段赋值**

```java
public class LinkedList {
    private int size = 0;
}
//如果一个类的所有构造器都希望把某个字段设置为某个固定初值，就可以直接先在类定义中显式初始化它。
```

- **在类定义中为字段赋值，初值不一定是基本类型，不一定是常量。**

```java
public class LinkedList {
    //在类定义中初始化
    private Node head = new Node();//构造器
    private int size = InitSize();//函数调用
    private int InitSize() {
        return 0;
    }
}
```

### 4.6.5 参数名

- `this`在构造器中的使用而已

### 4.6.6 调用另一个构造器

- 在一个构造器中使用`this`来调用同一个类中的另外一个构造器

```java
public class e {
    private int A;
    private int B;
    private String str;
    public e(int a , int b) {
        A = a;
        B = b;
    }
    public e(int a, int b, String s) {
        this(a,b);
        str = s;
    }
}//各个构造器本来重复的代码，只需要写一次
```

### 4.6.7 块初始化

- 不常见的机制，不管。
- `JDK7`之前都可以利用块初始化来编写没有`main`方法的`"Hello World"`

### 4.6.8 对象析构

- `Java`不支持析构器，因为它会完成自动的垃圾清理回收。

## 4.7 包



### 4.7.1 包名

- **使用包的主要原因是确保类名的唯一性**。
  - 重名的类放不同的包即可。
  - 使用域名的逆序作为包名确保唯一性，可以再追加过程名。

### 4.7.2 类的导入

- **一个类可以使用所属包中所有的类，以及其他包中的公共类（public class）。**
- `import`语句位于源文件的顶部，但是位于`package`语句的后面。
- 只能使用`*`导入一个包。
  - `import java.*.*`不可行。
- 通过完整的指出类名，其实可以避免使用`import`机制，所以`import`并不是`#include`。

### 4.7.3 静态导入

- **允许导入静态的方法和静态字段，而不只是类**

### 4.7.4 在包中增加类

- 想将类放入包中，将包的名字放在源文件的开头。
- 没有在源文件中放置`package`语句，这个文件就属于无名包。无名包没有包名。



### 4.7.5 包访问

**对类、方法、变量**：

- `public`：可由任意类使用。
- `private`：只能由定义它们的类使用。
- 没有指定是`public`还是`private`：可以被同一个包中的所有方法访问。

- **变量必须显式的标注为`private`，否则将默认为包可访问，会破坏封装性。**



### 4.7.6 类路径

- 类存储在文件系统的子目录中，**类的路径必须与包名相匹配**。
- 类也可以存储在`JAR`文件中，压缩形式的类文件和子目录。
- 关于如何保证类文件可被多个程序共享：看书吧 不写。

### 4.7.7 设置类路径

## 4.8 JAR文件

- `JAR`：Java归档文件。
  - 可以包含类文件
  - 也可以包含图像和声音等其他文件。
  - ZIP压缩的。

### 4.8.1 创建JAR文件

- 使用`jar`工具。命令行。

```java
jar options file1,file2
```

### 4.8.2 清单文件

### 4.8.3 可执行jar文件

### 4.8.4 多版本JAR文件

## 4.9 文档注释

JDK包含一个很有用的工具，Javadoc，它可由源文件生成一个HTML文档。

### 4.9.1 注释的插入

### 4.9.2 类注释

- 放在`import`之后，类定义之前，`/** ...*/`。

### 4.9.3 方法注释

- 放在方法定义之前，`/**...*/`。
- 除了通用标记还有一些可用标记。

```java
/**
*a example
*@param void
*@return nope
*@throw a exception
*/
```

### 4.9.4 字段注释

```java
/**
*PI
*/
public static final PI = 3.1415926535;
```

### 4.9.5 通用注释

- 看文档的事

```java
/**
*@author name
*@version text
*@
*/
```

### 4.9.6 包注释

### 4.9.7 注释抽取

- 看文档的事

## 4.10 类设计技巧

- 保证数据私有。
- 对数据进行初始化。Java**不会为你初始化局部变量**。
- 不要在类中使用过多基本类型。
- 某些字段可能并不需要`getter()`和`setter()`。

# 第5章 继承

- 继承：
  - 基于已有的类创建新的类。
  - 继承已存在的类就是复用这些类的方法。
  - 可以新增一些字段和方法。

- 有关反射的不仔细了解。

## 5.1 类、超类和子类

- `is - a` 关系是继承的明显特征。

### 5.1.1 定义子类

- **子类比超类要有的功能更多，封装的数据也更多。**
  - 添加更多方法。
  - 增加更多字段
  - **子类继承了超类的的方法和字段。**

```java
public class SubClass extends SuperClass {
    /**
    *added methods and fields
    */
}
```

### 5.1.2 覆盖方法 

- `@override`。
  - 覆盖超类中的同名方法的时候，可能需要调用超类中的这个方法。使用`super`。
  - `super`存在的原因是，尽管子类继承了超类的字段，但是由于超类的字段是`private`的，所以子类也没办法访问，只能通过超类提供的方法来访问。
- `super`只是一个指示编译器调用超类方法的关键字，与`this`不同。

```java
//以下写法会导致死循环
/**
*求经理的工资，基本工资加奖金
*/
public int getSalary() {
    return getSalary() + bonus;//本意是调用超类中的求工资方法，返回基本工资。
}
//正确的写法
public int getSalary() {
    return super.getSalary() + bonus;//Super调用超类中的求工资方法，返回基本工资。
}
```

- **子类可以增加方法，字段或覆盖超类的同名方法，但是不会删除超类的任何字段和方法。**

### 5.1.3 子类构造器

-  使用`super`调用超类构造器。
  - 你要构造一个子类对象，那你首先要构造一个超类对象。一个经理首先是一个员工，然后才是一个经理。
- `super`存在的原因还是，子类无法直接访问超类的`private`字段，所以必须通过先调用超类构造器来初始化这些从超类继承来的字段。
- **子类构造器的第一条语句一定是`super`调用超类构造器。**
  - 子类构造器没有显式调用超类构造器，则默认调用超类的无参数构造器。超类不存在无参数构造器则编译器报错。

```java
/**
*经理类继承了员工类，比员工类多了一个奖金
*/
public Manager(String name , int salary , int month , int year) {
    super(name,salary,month,year);
    bonus = 0;
}
```

- **多态：一个对象变量可以保存扩展自它所属类的任意子类对象。**
- **动态绑定：虚拟机能够知道上述对象变量所引用的对象的实际类型，并能根据实际类型选择正确的方法。**

### 5.1.4 继承层次

- 继承链

### 5.1.5 多态

- 任何超类对象变量出现的地方都可以用子类对象去替换。
- 一个超类类型的对象变量可以引用其任何子类的对象。反之不一定成立。
- 不能将超类的引用赋给子类对象变量。因为子类对象会有更多的字段。

### 5.1.6 理解方法调用

- 看一遍就是了
- **返回类型不是签名的一部分，签名由函数名和参数列表组成。子类覆盖超类同签名方法时允许改变返回类型。**
- **覆盖方法时，子类的方法的可见性不能低于超类方法。如果超类方法是`public`，子类也必须是。**



### 5.1.7 阻止继承：final类和方法

- 希望阻止其他人用这个类来扩展得到子类的时候，使用`final`类。
  - 不允许扩展的类称为`final`类。
  - 定义类的时候使用`final`修饰符即可。

```java
public final class FinalClass extends Object {
    
}
```

- 类中的某个特定方法也可以被声明为`final`。子类不能覆盖被声明为`final`的方法。
  - `final`类中的所有方法自动成为`final`方法。

```java
public final int getSalary() {
    //这个方法不能被经理类中的方法覆盖
}
```

- **`final`类中的字段并不自动成为`final`**。
- 将方法或类声明为`final`是为了确保它们不会在子类中改变语义。`String`类就是`final`的。



### 5.1.8 强制类型转换

- **超类引用赋给子类变量时，必须要强制类型转换才能通过编译器检查。**
- 在进行强制类型转换之前，使用`instanceof`操作符查看是否能成功完成转换

```java
if (Amanager instanceof employee) {
   epmloyee e = (employee) Amanager;
}
```

- 使用子类特有的方法时才可能需要强制类型转换。

### 5.1.9 抽象类

- 如果自下而上的在继承层次结构中上移，位于上层的类更具有一般性，可能更加抽象。

- 抽象程度更高的方法，使用`abstract`关键字，这样不需要提供实现的方法。
  - 比如对`person`类，有两个子类`employee`和`student`。有一个方法`getDescription()`返回对人的描述。
  - 这个方法在子类中各自实现不同，而在`person`类中就不好去具体实现，我们把它声明为`abstract`就好。

- **包含一个或多个`abstract`方法的类本身必须被声明为`abstract`**
  - 抽象类还可以包含字段和有具体实现的方法。

```java
public abstract class Person {
    private String name;
    public Person(String name) {
        this.name = name;
    }
    public abstract String getDescription();//分号，不需要具体实现
    public String getName() {
        return name;
    }
}
```

- 抽象方法充当着占位方法的角色，它们在子类中具体实现。
- 扩展抽象类的两种选择：
  - 在子类中部分实现抽象类中的抽象方法，保留部分或全部抽象方法未具体实现。此时子类也必须是抽象类。
  - 定义全部方法，此时子类不需要被声明为抽象类。

- **即使不含抽象方法，也可以将类声明为抽象类。**
- **抽象类不能实例化，如果一个类被声明为`abstract`，那么不能`new`一个这个类的对象。但是可以创建一个具体子类的对象。**
  - 可以创建一个抽象类的对象变量，但是它只能引用非抽象子类的对象。

```java
//Wrong,Person 为抽象类
Person p = new Person();
//可以
Person p = new Student();
```

### 5.1.10 受保护访问

- 有时候可能希望超类的某个字段，子类可以直接访问，但是被标记为`private`的字段是无法访问的。
  - 此时就用`protected`。
  - 超类中被声明为`protected`的字段是可以被子类访问的。
  - **保护字段只能由同一个包中的类访问（这里没有说同一个包中的子类）**
    - 如果一个子类不属于本包，那么它的对象可以访问对象自己的受保护字段，但是不能访问其他超类对象的受保护字段。
    - 对`protected`方法也是同样的。
  
- 总结一下访问修饰符
  - `private`：仅对本类可见。
  - `public`：对外部完全可见。
  - `protected`：对本包以及所有子类可见。
  - 没有访问修饰符：对本包可见。

## 5.2 Object：所有类的超类

- `Object`类是所有类的超类。Java中每个类都扩展了`Object`。
  - 如果没有明确指出超类，`Object`就被认为是这个类的超类。

### 5.2.1 Object类型的变量

- `Object`类型的对象变量可以引用任何类型的对象。
  - 只能作为用于各种值的泛型容器。要想对其中的内容做具体操作，需要清楚对象的原始类型，并进行强制类型转换。
  - 只有基本类型不是对象。
  - 所有的数组类型都扩展了`Object`类。

### 5.2.2 equals()方法

- `Object`类中实现的`equals()`方法比较的是两个对象的引用是否相等。
- 在子类中定义`equals()`方法时，首先调用超类的`equals()`。
  - 不同属于一个超类肯定不会相等。

### 5.2.3 相等测试与继承

- 关于如何写好`equals()`方法。

### 5.2.4 hashCode方法

### 5.2.5 toString方法

## 5.3 泛型数组列表

### 5.3.1

### 5.3.2

### 5.3.3 

## 5.4 对象包装器与自动装箱

- 需要将基本类型转换为对象时使用。
  - 所有的基本类型都有一个与之对应的类，这些类称作包装器。
  - 包装器类是不可变的，且是`final`的。
- 关于自动装箱和自动拆箱。
  - 编译器负责的工作。
- 比较两个包装器对象是否相等要用`equals()`。

```java
Integer i = Integer.valueOf(3);//装箱
int p = i.intValue(i);//拆箱
```

## 5.5 参数数量可变的方法

- 变参方法。
  - 定义实参个数可变的方法：只要在一个形参的"类型"与"参数名"之间加上三个连续的"."（即"..."，英文里的句中省略号），就可以让它和不确定个实参相匹配。
  - 用`...`。表明可以接受任意数量的对象。
  - 如果接收到的参数类型不同，用`Object...`来接收。
    - `Object...`相当于一个`Object`数组。

- 可以为参数指定任意类型，基本类型也可。

```java
// 变参实例，计算任意个整数中的最大值
public int findMax(int... values) {
    int max = values[1];
    for(int i : values) {
        if (max < i) {
            max = i;
        }
    }
    return max;
}
```

## 5.6 枚举类

- 不看

## 5.7 反射

- 不看

## 5.8 继承的设计技巧

# 第6章 接口 lambda 表达式与内部类



## 6.1 接口

### 6.1.1 接口的概念

- **接口不是类，而是对希望符合这个接口的类的一组需求**。

- `Comparable`接口

```java
public interface Comparable<T> {
    int CompareTo(T other);
}
```

- 接口中的所有方法都是`public`方法。在接口中声明方法时不必提供关键字`public`。
  - **在类中实现时需要显式声明public，不然编译器默认是包访问权限。**
- **接口还可以定义常量。**
- **接口没有实例字段。**
- **接口可以提供方法的具体实现，但是一般不会提供具体实现。**
  - **这些方法不能引用实例字段，因为接口没有。**

- **提供实例字段和方法具体实现的工作应该由实现这个接口的类来完成。**

- 让类实现一个接口：
  - 声明`implements`。
  - **实现接口中定义的所有方法。**

### 6.1.2 接口的属性

- 不能实例化一个接口，换句话说不能`new`一个接口。
- 但是可以声明一个接口类型的对象变量。
  - **接口变量必须引用实现了这个接口的对象。**
  - 可以使用`instanceof`检查一个对象是否实现了某个接口。

- 接口也可以`extends`。
- **接口中可以包含常量**
  - 接口中的字段总是自动的`public static final`。
  - 有些接口中甚至只定义了常量。实现这些接口的类自动继承这些常量。
- 一个类可以实现多个接口，但是只能有一个超类（不支持多重继承）。

```java
public class employee implements Cloneable, Comparable
```

### 6.1.3 接口与抽象类

### 6.1.4 静态和私有方法

### 6.1.5 默认方法

- 给接口的方法提供一个默认实现
  - `default`。
  - 默认方法可以调用接口中的其他方法
  - 默认方法可以保证源代码兼容。细节看书。

### 6.1.6 解决默认方法冲突

- 超类优先
  - 接口默认方法和超类默认方法冲突，超类优先。
- 接口冲突：
  - 编译器报错。
  - 解决的方法是在实现的类中覆盖掉冲突的方法。

### 6.1.7 接口与回调

### 6.1.8 Comparator 接口

- 比较器接口，当你希望使用非`Comparable`中的标准来定义两个对象的大小时使用。
  - 这个方法在比较器对象上调用，而不是在`Comparable`对象本身上调用。

```java
public interface Comparator<T> {
    int compare(T first, T second);
}
public class StringLengthComparator implements Comparator<String> {
    public int compare(String first , String second) {
        return first.length() - second.length();
    }
    public static void main(String[] args) {
        Comparator<String> cmp = new StringLengthComparator<>();
        cmp.compare("ABCD" , "AAAAA");//在比较器上调用
        "ABCD".compareTo("AAAAA");//在Comparable本身上调用
    }
}
```

### 6.1.9 对象克隆

## 6.2 lambda表达式

### 6.2.1 为什么引入lambda表达式

- lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。

### 6.2.2 lambda表达式的语法

- lambda表达式就是代码块以及必须传入代码的变量规范。

```java
//第一个lambda表达式
(String first , String second) -> {
    first.lenght() - second.length();
}
```

- lambda表达式的一种形式：参数，箭头，以及一个表达式。
  - 如果代码要完成的计算一个表达式不够，就可以像写方法一样写一个代码块。
  - 可以包含`return`语句。

```java
(String first , String second) -> {
    if (first.length() > second.length())
        return 1;
    else if (first.length() < second.length())
        return -1;
    return 0;
}
```

- 即使lambda表达式没有参数，也需要空括号，就像没有参数的方法。

```java
() -> {
    return 1;
}
```

- 如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。

```java
Comparator<String> cp = (first, second) ->first.length() - second.length();
//可以反推到first必定是String
```

- 如果方法只有一个参数，而且这个参数的类型可以推导得出，甚至可以省略圆括号。

```java
//
ActionListener ls = event -> System.out.println("");
```

- lambda的返回类型无需指定，因为可以由上下文推导出。
- **如果一个lambda表达式只在某些分支返回一个值，在其他分支不返回值，是不合法的。**

### 6.2.3 函数式接口

- lambda表达式与封装代码的接口是兼容的。
- 对于只有一个抽象方法的接口，需要指针接口的对象时，可以提供一个lambda表达式。这种接口称为函数式接口。
  - 比如`Comparator`接口。就只有一个抽象方法。

```java
//
Arrays.sort(strings ,  (first, second) ->first.length() - second.length())
```

## 6.3 内部类

### 6.3.1 使用内部类访问对象状态

- 内部类对同一个包中其他类隐藏。
- 内部内方法可以访问定义这个类的作用域中的数据，包括原本私有的数据。
  - **一个内部类方法可以访问自身的数据字段，也可以访问创建它的外围类对象的数据字段。**
  - **内部类对象总有一个隐式引用指向创建它的外部类对象。**
- 内部类推荐声明为`private`。毕竟除了外围类，其他类也不需要去创建内部类对象。

### 6.3.2 内部类的特殊语法规则

- 表示外部类引用：`OuterClassName.this`
- 外围类的作用域之外引用内部类：`OuterClass.InnerClass`

### 6.3.3 内部类是否有用、必要、和安全

- 内部类只是一个`编译器现象`，与虚拟机无关。
  - 编译器会把内部类转换为常规类文件，用$分割外部类名与内部类名。`Outer$Inner.class`。
  - 内部类其实拥有更大的访问权限。

### 6.3.4 局部内部类

- **可以在一个方法中局部地定义一个类**
  - 声明局部类时不需要访问修饰符
  - 局部类的作用域被限定在声明这个局部类的块中。
  - 局部类对外界完全隐藏。

### 6.3.5 由外部方法访问变量

- 局部内部类还可以访问方法的局部变量
  - 可以访问外围方法的参数。
  - 局部变量必须是事实最终变量。
  - 实现的机制是在局部变量消失前复制为局部内部类的一个实例字段。

### 6.3.6 匿名内部类

- 不想看。

### 6.3.7 静态内部类

- 有时候使用内部类只是为了把一个类隐藏在另一个类的内部，而并不需要内部类有对外围类对象的引用。
  - 此时可以将内部类声明为`static`。
  - 声明为`static`的类不会生成那个引用。
- 只有内部类可以声明为`static`。
- **与常规内部类不同，静态内部类可以有静态字段和方法**
  - 常规内部类不能有静态方法和字段。
  - 随着类文件的加载所有静态成员都会在内存中获得相应的内存空间完成初始化，内部类可以视为外部类的类成员变量，如果这个内部类为非静态的话就是说他不会随着外部类的加载而得到内存分配，也就是说不会随着外部类的加载完成而完成初始化。如果此时内部类内存在静态成员的话，就会引起编译失败，原因很简单，内部类的静态成员此时也要完成初始化即要获得相应的内存空间，而他依托的非静态内部类又没有获得内存的分配，所以他就无法完成初始化。

## 6.4 服务加载器

## 6.5 代理





# 第7章 异常、断言和日志

- 在发生错误时，程序应该做到以下几点：
  - 向用户通知错误。
  - 保存所有的工作。
  - 允许用户妥善的退出程序。

## 7.1 处理错误

- 如果由于出现错误而使得某些操作没有完成，程序应该：
  - 返回到一种安全状态，并能够让用户执行其他的命令。
  - 允许用户保存所有工作的结果，并以妥善的方式终止程序。
- 异常处理的任务就是将控制权从产生错误的地方转移到能够处理这种情况的错误处理器。

- 需要考虑的异常：
  - 用户输入错误。除了键盘输入错误，还有格式错误巴拉巴拉巴拉。
  - 设备错误。打印机打印到一半没纸了，突然断网了。
  - 物理限制。磁盘满了
  - 代码错误。下标越界，查找不存在的记录，空指针。
- 如果某个方法不能采用正常途径完成它的任务，它会
  - 可以通过另外一个路径退出方法。
  - 不返回任何值，而是抛出一个封装了错误信息的对象。
  - 这个方法会立即退出，也不会从调用这个方法的地方的代码继续执行。
  - 由异常处理机制接手寻找对应的异常处理器。



### 7.1.1 异常分类

- 异常对象都是派生于`Throwable`类的。Java内置的异常类不能满足要求，可以创建自己的异常类。
- 所有异常都由`Throwable`继承而来，但在下一层次又分解为`Error`和`Exception`。
  - `Error`：Java运行时系统的内部错误和资源耗尽错误。你的应用程序不应该抛出这种类型的对象。这种错误出现，除了通知用户，并尽力妥善终止程序以外，几乎无能为力。
  - `Exception`：分解为两个分支。

- `Exception`：分解为`RuntimeException`和其他异常。
  - 由编程错误导致的异常属于`RuntimeException`。
  - 程序本身没问题而由`I/O`错误之类问题导致的属于其他异常。

- 派生于`RuntimeException`的异常：
  - 错误的强制类型转换。
  - 数组访问越界。
  - 访问`null`指针。

- 其他异常包括
  - 试图越过文件结尾继续读取数据。
  - 试图打开不存在的文件。
  - 试图查找一个类而这个类不存在。

- 派生于`Error`类和`RuntimeException`类的所有异常称为`非检查型(unchecked)`异常。所有其他称为检查型异常。
- **编译器将检查你是否为所有检查型异常提供了异常处理器。**

### 7.1.2 声明检查型异常

- 代码需要告知编译器可能会发生什么异常。
- 要在方法首部指明抛出什么异常。

```java
/*
*一个构造器
*/
public FileInputStream(String name) throws FileNotFoundException
```

- 自己编写方法时不必声明这个方法可能抛出的所有异常。以下情况会抛出异常。
  - 调用了一个抛出检查型异常的方法。
  - 检测到一个错误，并用`throw`语句抛出一个检查型异常。
  - 程序出现错误。可能是检查型异常也可能是非检查型异常？
  - Java虚拟机或运行时库出现内部错误。

- 前两种情况必须告知调用这个方法的程序员也可能抛出异常，否则如果没有处理器捕获这个异常，当前执行的线程就会终止。
- 处于公共类中的的方法，通过方法首部的异常规范(`Exception Specification`)声明这个方法可能抛出异常。
  - 一个方法可能抛出多个检查型异常，在方法首部全部列出，用逗号分割。

```java
public class e {
    public void load(String s) throws FileNotFoundException,EOFException
}
```

- **不需要声明Java内部的异常，也即继承自`Error`的异常。因为任何代码都可能抛出这类异常，我们对此异常也无法控制。**
- **不需要声明继承自`RuntimeException`的那些非检查型异常。因为这些错误完全可以在我们的控制之中。**

- **必须声明所有可能的检查型异常，而剩下的非检查型异常，要么我们无法控制(Error)，要么在一开始就应该避免。**
- 如果没有声明所有可能发生的检查型异常，编译器会发出错误消息。
- 还可以捕获异常，这样就不会从这个方法抛出异常，也就没必要用`throws`。

- **如果子类中覆盖了超类中的一个方法，那么子类中的方法声明的检查型异常不能比超类中声明的异常更通用。**
  - 子类方法可以抛出更特殊的异常。
  - 也可以根本不抛出任何异常。
  - 如果超类方法没有抛出任何检查型异常，子类也不能抛出任何检查型异常。

### 7.1.3 如何抛出异常

- 实例：读取文件，文件长度小于承诺长度。

```java
public String readData(Scanner in) throws EOFException
{
    while(...) {
        ......
            if(...) {
                throw new EOFException();
            }
    }
    return ...
}
```

- 如果已有的异常类可以满足要求，那么抛出这个异常很容易
  - 找到一个合适的异常类。
  - 创建一个这个类的对象。
  - 抛出这个对象。
- 一旦方法抛出异常，这个方法就不会返回调用者。不必操心建立一个默认返回值或错误码。

### 7.1.4 创建异常类

- 任何标准异常类都无法描述清楚的问题，创建自己的异常类来解决。
- 定义一个派生于`Exception`的类，或者派生于`Exception`的某个子类，如派生于`IOException`。
- 惯例如下
  - 两个构造器，一个默认无参数构造器，一个包含详细信息的构造器。
  - 超类`Throwable`的`toString`会获取异常对象的详细信息字符串。

```java
class FileFormatException extends IOException {
    public FileFormatException() {
        
    }
    public FileFormatException(String message) {
        super(message);
    }
}
public ReadFIle(Scanner in) throws FileFormatException {
    .......;
    throw new FileFormatException();
}
```

## 7.2 捕获异常

### 7.2.1 捕获异常

- 如果抛出一个异常，而没有在任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括这个异常的类型和一个堆栈轨迹。
- 捕获异常需要设置，`try/catch`语句块。

```java
try {
    code....
}
catch (ExceptionType e) {
    code..
}
```

- 如果`try`语句块中的任何代码抛出了`catch`子句中指定的一个异常类。那么

  - 程序将跳过`try`语句块的其他代码。
  - 程序将执行`catch`语句中的处理器代码。

- 如果`try`语句块没有抛出任何异常，程序将跳过`catch`语句。

- **如果方法中的任何代码抛出了`catch`子句中没有声明的异常类型，那么这个方法就会立即退出。**

  ```java
  /**
  *一个例子，读取文件
  *read()可能会抛出IO异常
  */
  public void read(String filenname) {
      try {
          var in = new FileInputStream(filename);
          int b;
          while((b = in.read()) != -1) {
              .....;
          }
      }
      catch (IOException e) {
          e.printStackTrace();
      }
  }
  ```

- 如果选择什么也不做，不去捕获这个异常，而是将异常传递给调用者，那就必须声明这个方法可能会抛出一个`IOException`。

```java
/**
*read()可能会抛出IO异常
*将抛出的异常继续传递下去，传递给调用者。
*/
public void read(String filenname) throws IOException
{

        var in = new FileInputStream(filename);
        int b;
        while((b = in.read()) != -1) {
            .....;
        }
}
```

- 如果调用了一个抛出检查型异常的方法，就必须处理这个异常，或者选择继续传递这个异常。
  - 捕获你知道如何处理的异常，继续传播那些你不知道如何处理的异常。
  - 想传播一个异常，必须在方法首部添加`throws`说明符，提醒调用者这个方法可能抛出一个异常。
  - 查看API文档得知API可能抛出的异常。然后再决定是直接处理还是继续传递。

- **如果编写的方法覆盖了超类的一个方法，而这个超类方法没有抛出异常，你就必须捕获你的方法代码中出现的每一个检查型异常。**
- 不允许在子类方法的`throws`说明符中出现超类方法未列出的异常。



### 7.2.2 捕获多个异常

- 一个`try`语句块可以捕获多个异常类型，并对不同类型的异常做不同处理。要为每个异常类型使用一个单独的`catch`子句。

```java
try {
    .......
}
catch (FileNotFoundException f) {
    .....;
}
catch (UnkonwnHostException u) {
    .....;
}
catch (....) {
    .....;
}
```

- 异常对象可能包含有关异常性质的信息，尝试使用`e.getMessage()`
- `e.getClass.getName()`得到异常的实际类型。
- Java7后同一个`catch`可以捕获多个异常类型。
  - 假如处理两个不同异常的动作是一样的，那么可以合并`catch`语句。
  - 只有当捕获的异常类型彼此之间不存在子类关系时可以使用。
  - 捕获多个异常时，异常变量`f`隐含为`final`。

```java
try {
    .......
}
catch (FileNotFoundException f | UnkonwnHostException u) {
    .....;
}

```

### 7.2.3 再次抛出异常与异常链
