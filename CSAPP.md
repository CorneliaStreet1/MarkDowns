

# 深入理解计算机系统

- 寒假看书参照的是上海交大的ICS课程主页的安排
- 以及北邮计算机系统基础课程的安排

# 第1章 计算机系统漫游

- 计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。

以HelloWorld为例。

```c
#include<stdio.h>
int main(void) {
    printf("Hello World.\n");
    return 0;
}
```



## 1.1 信息就是位+上下文

- 程序的生命周期从源文件开始的，这个源文件实际上是由值0和1组成的位序列。
  - 8位一字节。每个字节表示程序中的某些文本字符。

- `HelloWorld.c`

<img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220120125356367.png" alt="image-20220120125356367" style="zoom: 50%;" />

- **系统中所有信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送数据，都是由一串比特表示的。**
- **区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如同一个字节在不同的上下文可能表示整数，浮点数，字符串，机器指令**

## 1.2 程序被其他程序翻译成不同的格式

- **为了在系统上运行C程序，每条C语句都必须被其他程序转化为一系列的低级`机器语言`指令。然后这些指令按照一种称为`可执行目标程序`的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行 目标文件。**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201201312458.png" alt="image-20220120131240111" style="zoom: 50%;" />

- **预处理阶段**。`预处理器`根据以`#`字开头的命令，修改原始的C程序。
- **编译阶段**。`编译器`将文本文件`hello.i`翻译成汇编语言程序。
  - 汇编语言以文本格式描述了低级机器语言指令。
  - **汇编语言为不同高级语言的不同编译器提供了通用的输出语言。**
- **汇编阶段**。`汇编器`将汇编语言文件翻译成机器语言指令，把这些指令打包成二进制`可重定位目标文件`。、
- `链接阶段`。`链接器`将单独预编译好的库函数的``.o文件(`可重定位目标文件`，如`printf.o`)以某种方式合并到此前得到的目标文件中。
  - 得到可执行目标文件。可以被加载到内存中，由系统执行。

## 1.3 了解编译系统如何工作是大有益处的

## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201201339650.png" alt="image-20220120133957306" style="zoom:33%;" />

- 总线。贯穿整个系统的一组电子管道。**总线携带信息并负责在各个部件间传递**。
  - 被设计成传**送定长的字节块**，称作`字`(word)。
  - **字中的字节数(即`字长`)是一个基本的系统参数，各个系统中都不尽相同。**
  - 大多数机器要么32位字长，要么64位字长。

- I/O设备。系统与外部世界的联系通道。
  - 作为用户输入：键盘、鼠标。
  - 作为用户输出：屏幕。
  - 用于长期存放数据及程序：磁盘。
  - 每个I/O设备都通过控制器或适配器与I/O总线相连。
  - 适配器和控制器的区别：
    - 控制器是I/O设备本身或系统的主印制电路板上的芯片组。
    - 适配器是一块插在主板插槽上的卡。
- 主存。临时存储设备，在处理器执行程序时用来存放程序和程序处理的数据。
  - 物理上来说主存由一组动态随机存取存储器(DRAM)芯片组成。
  - 逻辑上来说，主存就是一个线性的字节数组，每个字节有其唯一的地址，地址从0开始。
- 处理器。中央处理单元，解释存储在主存中指令的引擎。
  - 算术逻辑单元(ALU)：计算新的数据和地址值。
  - 加载：从内存复制一个字节或一个字到寄存器，覆盖寄存器原有的内容。
  - 存储：从寄存器复制内容到内存某个位置。
  - 操作：把两个寄存器的内容复制到ALU，ALU对这两个数据做运算，结果写入一个寄存器。
  - 跳转：从指令本身抽取一个字，写入程序计数器中。



### 1.4.2 运行Hello程序

## 1.5 高速缓存至关重要

- 解决CPU读取寄存器和读取内存的巨大的速度差异而存在。
- 高速缓存存储器。`cache`。存放处理器近期可能会用到的信息。
- L1、L2甚至L3级高速缓存。

## 1.6 存储设备形成层次结构

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201201634563.png" alt="image-20220120163419214" style="zoom:50%;" />

## 1.7 操作系统管理硬件

- 操作系统两个基本功能
  - 防止硬件被失控的应用程序滥用。
  - 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201201639343.png" alt="image-20220120163900092" style="zoom: 33%;" />

### 1.7.1 进程

- 进程是操作系统对一个正在运行的程序的抽象。
  - 一个系统可以同时运行多个进程，而每个进程则处于自己独占硬件的假象中。
- 并发运行：一个进程的指令和另一个进程的指令交错执行。
- 操作系统实现交错执行的机制称为上下文切换。
- 操作系统保存和跟踪进程运行所需要的所有状态信息，这些信息就是上下文。
  - 程序计数器当前值，寄存器文件当前值，当前主存的内容等。
  - 任意时刻单处理器都只能执行一个进程的代码。
- 操作系统决定把控制权从当前进程转移到新进程时发生上下文切换
  - 上下文切换：保存当前进程的上下文，恢复新进程的上下文。
  - 控制权转移到新进程后新进程就会从它上次停止的地方开始。
  - 其实控制权转移就是设置程序计数器为新进程上下文保存的值。
- 进程转换由内核管理。
  - 操作系统代码常驻主存的部分。
  - 内核不是一个独立的进程，它是系统管理全部进程所用的代码和数据的集合。

<img src="C:/Users/jiangyiqing/AppData/Roaming/Typora/typora-user-images/image-20220120190208282.png" alt="image-20220120190208282" style="zoom:33%;" />





### 1.7.2 线程

- 一般认为一个进程只有一个单一的控制流，但一个进程实际上可以由多个线程组成。
  - 每个线程都运行在进程的上下文中。
  - 线程共享同样的代码和全局数据。
  - 线程比进程更容易共享数据，且一般更高效。

### 1.7.3 虚拟内存

- `虚拟内存`是一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。
- 每个进程看到的内存都是一致的，称为`虚拟地址空间`。
- Linux进程的虚拟地址空间：地址往上递增的。
  - 地址空间最上面的区域，地址最大的那一块，保留给操作系统中的代码和数据。**所有进程都如此**。
  - 每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。

- 程序代码和数据。
  - **在进程一开始时就被指定了大小。**
  - 所有进程的代码都是从同一固定地址开始的，紧接着是和C全局变量相对应的数据位置。
  - 代码和数据区是直接按照可执行目标文件的内容初始化的。

- 堆。运行时堆。调用内存分配函数时可以在运行时动态地扩展和收缩。

- 共享库。存放像C标准库和数学库这样的共享库的代码和数据的区域。
- 栈。位于用户虚拟地址空间的顶部。
  - 编译器用它来实现函数调用。调用函数时扩展，从函数返回时收缩。
  - 可以在程序运行期间扩展和收缩。
- 内核虚拟内存。为内核保留，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数，必须通过内核来调用。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201201912286.png" alt="image-20220120191210993" style="zoom:33%;" />

### 1.7.4 文件

- 文件就是字节序列，仅此而已。
- 所有的输入输出设备都可以看成文件。
- 系统中所有的输入输出都是通过Unix I/O读写文件实现的。

## 1.8 系统之间利用网络通信

- 从一个单独的系统的视角来看，网络也是它的一种*I/O*设备。
  - 系统从主存复制一串字节流到网络适配器，并经过网络到达另外一台机器。
  - 系统读取从其他机器发来的数据，并把数据复制到主存。

![image-20220121132929644](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201211329896.png)

## 1.9 重要主题

### 1.9.1 Amdahl定律

- 当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。
- 要想显著地加速整个系统，必须提升全系统中相当大的部分的速度。



### 1.9.2 并发和并行

- 并发(concurrency)：指一个同时具有多个活动的系统。
- 并行(parallelism)：指用并发来使一个系统运行得更快。
  - 并行可以在计算机系统的多个抽象层次上运用。

#### 1.线程级并发

- 使用线程可以在一个进程中执行多个控制流。
- 传统意义上的并发执行是通过计算机在正在执行的不同的进程之间快速切换模拟出来的。

- 多核处理器：将多个CPU集成到一块芯片上。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201211347769.png" alt="image-20220121134701377" style="zoom:50%;" />

- 超线程：允许一个CPU执行多个控制流。

#### 2. 指令级并行

- 现代处理器可以同时执行多条指令的属性称为指令级并行。

#### 3. 单指令多数据并行

### 1.9.3 计算机系统中抽象的重要性

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201211356272.png" alt="image-20220121135653865" style="zoom: 50%;" />

- 虚拟机。

# 第一部分 程序结构和执行

## 第2章 信息的表示和处理



- 浮点数不满足结合律，因为浮点数的表示是不精确的。
- 而整型由于范围有限，导致乘积溢出，正值变负值。

![屏幕截图 2021-10-02 221755](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-02%20221755.png)



| C Data Type          | Typical 32-bit | Typical 64-bit |
| -------------------- | -------------- | -------------- |
| **char**             | 1              | 1              |
| **short**            | 2              | 2              |
| **int**              | 4              | 4              |
| **long**             | 4              | 8              |
| **float**            | 4              | 4              |
| **double**           | 8              | 8              |
| **char ***（pointer) | 4              | 8              |
|                      | “ILP32”        | “LP64”         |

## 2.1 信息存储

- 大多数计算机使用8位的块，称作字节，作为最小的可寻址的内存单位。
  - 机器级程序把内存视为一个非常大的字节数组，称为虚拟内存。
  - 内存的每个字节都有一个唯一的数字标识，称作地址。地址的集合称作虚拟地址空间。



### 2.1.1 十六进制

### 2.1.2 字数据大小

- 每台计算机都有一个字长，指明指针数据的标称大小。
  - 虚拟地址以字长编码，所以字长决定了虚拟地址的最大值。
  - 32位字长限制虚拟地址空间为4GB。
  - 64位字长则到达16EB。
- 大多数64位机器可以运行32位机器编译的程序。
  - 32位和64位程序区别在于该程序是如何编译的，而不是其运行的机器类型。

- C标准没有明确规定`Char`是有符号数还是无符号数。

### 2.1.3 寻址和字节顺序

- 多字节对象被存储为连续的字节序列，**对象的地址为所使用字节中最小的地址。**
- `大端法`：最高有效字节在前面。
- `小端法`：最低有效字节在前面。
- **大端法和人习惯的阅读顺序是一致的。**

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201211520877.png" alt="image-20220121152006548" style="zoom: 50%;" />



### 2.1.4 表示字符串

### 2.1.5 表示代码

- 不同类型的机器使用不同的且不兼容的指令和编码方式。

### 2.1.6 布尔代数简介

![屏幕截图 2021-10-03 132243](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-03%20132243.png)

### 2.1.7 C语言中的位级运算

这个是位级别的运算，不是C中的逻辑运算

**Operations &,  |,  ~,  ^ Available in C**

- 将参数看作位向量
- 适用于C中的任何“整型”，包括char
- 参数按位运算
- 注意与C的逻辑运算&&、|| 、!区分，这个是逻辑运算，上面的是位向量运算
- 确定一个位级表达式的结果的最好方法是将其他进制转换为二进制并执行二进制运算，然后再转换回十六进制

### 2.1.8 C语言中的逻辑运算

### 2.1.9  C语言中的移位运算

#### Left Shift: 	x << y

- x左移y位，丢弃最高的y位（也就是最左侧的y位），并在右端补上y个0
- 移位量y应该是一个0到w-1之间的值，w为操作数x的宽度
- 移位运算是从左向右结合的，也就是说x << y << z等价于(x << y) << z

3 << 2

首先把3转换为二进制数字**00**00 0000 0000 0000 0000 0000 0000 0011，然后把该数字**高位(最左侧)**的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12。

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。

#### Right Shift: 	x >> y

- x右移y位
- 机器支持两种形式的右移：逻辑右移和算术右移

11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 10**11**，然后把低位的最后两个数字**11**移出，因为该数字是正数，所以在高位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。转换为十进制是2。

右移一位相当于除以2，右移n位相当于除以2的n次方。

#### 逻辑右移

逻辑右移在左端补y个0，丢弃操作数低位（最右侧）的y位，与左移恰好相反

#### 算术右移

- 算术右移在左端补y个最高有效位的值，丢弃操作数最右侧的y位
- 对有符号整数的运算很有用
- 最高位为0补0，为1补1

[01100011] 算术右移4位====》[00000110]，最高位为0

[10010101]算术右移4位====》[11111001]，最高位为1

- 几乎所有的编译器/机器都对有符号树使用算术右移，许多程序员也如此假设
- 对于无符号数，右移必须是逻辑右移

#### Undefined Behavior

- Shift amount < 0 or ≥ word size

- 对于宽度为w的数据类型移动k（k >= w）位，许多机器计算位移量为k对w的余数

- 不过对于C来说这是未定义的行为，所以要保证位移量大于零小于宽度w

#### 运算优先级问题

在C语言中，加减法的优先级是高于移位运算符的

1 << 2 + 3 << 4 等效于1 << (2+3) << 4，所以在拿捏不准的时候，加上括号 

## 2.2 整数表示

### 2.2.1 整数数据类型

- 负数的范围比正数大一

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201211617955.png" alt="image-20220121161714610" style="zoom:33%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201211618064.png" alt="image-20220121161802750" style="zoom:33%;" />

### 2.2.2 无符号数的编码

- BInary to Unsigned==》B2U，宽度为w作为下标

- 对于宽度为w的无符号数，它的范围为0到2^w - 1 

- 介于这个范围内的每个数都有唯一的编码

### 2.2.3 补码(two‘ s -complement)

B2T ===》Binary to two ’ s complement，跨度w作为T的下标

- 在补码中将字的最高有效位定义为负权，最高有效位也称为符号位，值为 - 2 ^(w-1)

- 符号位为1时表示的是负数，为零时表示的是正值

- 补码的范围：正数最大为 2 ^ (w -1) -1 ，负数最小为 - 2^(w - 1)，正数比负数少一个

- 分别对应符号位为0，其他位为1，以及符号位为1，其他位为0

- 在表示的范围内补码编码也具有唯一性

- -1表示为全1串

### 2.2.4 有符号数和无符号数之间的转换

强制类型转换的结果保持位值不变，只是改变解释这些位的方式。

对于处理**相同字长**的有符号数和无符号数的相互转换，一般规则是:

- 数值可能会改变，但位模式不变

```c
//举例,下列转换过程中位值没变，而解释位的方式改变了
short v = -12345//-12345 == [1100111111000111];，有符号数，补码最高位为符号位
unsigned uv = (unsigned)v;//uv == 532191 == [1100111111000111]，无符号数，最高位不是符号位
```

有符号数（补码）到无符号数的转换:非负数不变而负数变成了大的正数

- 如果要转换的有符号数是正数或0，那么转换后的无符号数与有符号数相等
- 待转换的有符号数为负数，且其二进制为w位，其对应的无符号数等于有符号数加上2^w

无符号数到有符号数(补码)的转换：

- 待转换的无符号数小于有符号数能表示的最大正数时，其对应的有符号数不变
- 待转换的无符号数大于有符号数能表示的最大正数时，其对应的有符号数等于无符号数减去2^w

### 2.2.6 C语言中的有符号数与无符号数

**当执行一个运算时，如果它的一个运算数是有符号数而另外一个是无符号数，那么C语言会隐式地将有符号数强制转换为无符号数，并且假设两个数都是非负的，来执行这个运算**

- 在标准算术运算中可能差异不大
- 在   <  和  >  这样的运算符中，会出现意料之外的结果

```c
//举例，假设在32位机器上
//比较有符号的-1和无符号的0：-1 < 	0U
//由于第二个参数0是无符号的，所以-1被隐式转换为无符号数
//而-1的32位补码对应的无符号数是（2^32 - 1）U ，远大于0U
//因此表达式等价于4294967295U < 0U
//表达式结果为false，与预期的true完全不符合
```

### 2.2.6 扩展一个数字的位表示

一种常见的运算是在不同字长的整数之间进行转换，同时又保持数值不变

- 从较小数据类型转换为较大数据类型是可能的

- 要将无符号数转换为一个更大的数据类型，只需要在表示的开头添加0，称为零扩展

- short转换为unsigned，先将short转换为int，再转换为unsigned

- 将补码（有符号数）扩展为一个更大的数据类型，如下图，正数补零，负数补1

  ![屏幕截图 2021-10-04 131404](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-04%20131404.png)

### 2.2.7 截断数字

假设我们不用额外的位来扩展一个数值，而是想用更少的位来表示同一个数值

- 当我们想将w位的数截断为k位，保留的是权较小的k位
- 对于补码来说，还要将最高位转换为符号位

```c
int x = 53191;//将32位的int强制转换为16位的short，这个16位的表示就是-12345的补码
short sx = (short)x;//-12345
int y = sx;//-12345
```

## 2.4 浮点数

浮点数表示对形如 x *  2^y 的数编码（这一点类似十进制的科学计数法，x的绝对值一般是小于2的）。对执行极大数字以及非常接近于0的数的以及作为实数运算的近似值的计算非常有用。

 

```
IEEE：读作I-triple-E，电器和电子工程师协会。浮点数的标准由其指定
```

### 2.4.1 二进制小数

- 类比十进制小数，二进制小数的每位的权，以小数点为分割线，左边各位的权为2的非负幂，小数点右边的数位的权为2的负幂。
- 同样类比十进制小数，二进制小数的小数点向左移动一位，相当于这个数除以2，向右移动一位则相当于这个数乘以2。
- 形如`(0.11111.....)`的**二进制小数**表示的是恰好小于1的数，实际上是`(2^n -1) / (2 ^ n)`。一般用`1.0 - ε`来表示这样的数
- 于十进制不能精确表示1 /3（3进制可以精确表示） 和 5 / 7这样的数，二进制小数也只能精确表示能被写成`x * 2^y`的数，其他值只能近似表示
- 1/5可以用十进制的0.2精确表示，而不能用二进制来精确表示，只能近似表示，且二进制表示的长度越长，值的精度越高

### 2.4.2 IEEE浮点表示

前一节所提到的二进制小数表示法为定点表示法，但这样的表示法不能很有效的表示非常大的数字，如 5 * 2 ^100，是二进制的5(101)后面跟100个0。double类型没有这么多位。

IEEE浮点标准：`V = (-1) ^s * M * 2 ^ E`来表示一个数：

- 符号s（sign）决定这个数是整数（s = 0）还是负数（s = 1），对数值0的符号位解释作为特殊情况处理。
- 尾数（significand）M是一个二进制小数，其范围为1~2 - ε 或 0 ~ 1 - ε。
- 阶码（exponent）E的作用是对浮点数加权，权重为2的E次幂（E可能是负数）。 
- 一个单独的符号位直接编码符号s。
- 二进制k位的阶码（exp)字段编码阶码E。
- 二进制n位小数(frac)字段编码尾数M，编码出来的值也依赖于阶码字段的值是否为0。
- 由下图可以计算出float和double的（理论）上限值，都是符号位取0，其他位取1时最大
- 同样可以计算出最小值，符号位取1，其他位取1即可



![](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/IEEE_Float.jpg)



根据阶码的值，或者说阶码的二进制形式，被编码的值可以分成三种情况：

- 最普遍的情况，规格化的值。**exp的位模式不全为0，也不全为1**（float为255，double为2047）时都属于这种情况。这种情况下阶码被解释为以偏置形式表示的有符号数，也就是说阶码E的值实际上为E = e - Bias，e为阶码二进制形式对应的无符号数值，bias的值为2^(k -1) -1 ，k为阶码的位数，对float来说bias为127，double的bias则为1023。因此单精度浮点数的阶码范围为-126~127，double的阶码范围为-1022 ~ 1023，对float来说阶码为11111110时取阶码最大127，阶码为00000001时取最小阶码-126。而对于小数字段，小数点在小数字段f的最高有效位的左侧。尾数则定义为1加上小数字段的f。**也就是尾数M的实际上的值是二进制的**`1.f`这种方式也被称为隐含的以1开头（implied leading 1）的表示。因为我们总是可以通过调整阶码E来将尾数M调整为以1开头的二进制小数。所以位于开头的这个固定的1也就没必要显式的表示出来。
- 情况2，非规格化的值。exp的位模式为全0，E = 1 - Bias，**不是E = 0 - Bias**，而尾数M的值为M = f，也就是小数字段的值，**不包含隐含的开头的1**。非规格化数有两个用途，首先是提供了一种表示数值0的方法，因为规格化数我们必须使`M >= 1`，所以规格化数无法表示数值0。`+0.0`的浮点数表示的位模式是全零，符号位为零表明这是正的，阶码位为零表明这是一个非规格化的值，小数位为0使得M = f = 0。而当符号位为1，而其他位全为0时，我们得到的是浮点数的`-0.0`。正负的0.0在某些方面不同。非规格化数的另外一个功能是表示那些非常接近于0的数（因为阶码可以到-126/-1022，而小数部分由没有隐含0，尾数也小于1）。可能的数值分布均匀地接近0，具有逐渐溢出属性。
- 情况3，特殊值，当阶码全为1时。当小数域全为0而阶码全为1时，得到的值为无穷，符号位为0则为正无穷，符号位为1则为负无穷。当小数域不为0而阶码全为1，结果称为NaN(Not a Number)。

![Formats_Float](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Formats_Float.jpg)

### 2.4.4 舍入

因为表示方法限制了浮点数的精度和范围，所以浮点运算只能近似地表示实数运算。因此对于一个值x，我们希望可以用一种系统的方法，来找到最接近x的匹配值X，X是可以用浮点数表示出来的值。这就是舍入运算的意义。例如考虑对1.5的舍入问题，是把它舍入为1还是2。IEEE浮点格式定义了4种不同的舍入方式，默认的是找到最接近的匹配，而其他三种用于计算上界和下界。

- 向偶数舍入，也称为向最接近的值舍入，是默认的方式。1.4舍入为1，而1.6舍入为2，因为他们是最接近的值。
- 对于介于两个可表示的值正中间的小数，如1.5，向偶数舍入采用向上或者向下舍入，使得舍入的结果最低有效数字是偶数，因此1.5和2.5都舍入为2
- 向偶数舍入的方法也可应用于不想舍入到整数的情况，只简单地考虑最低有效位是奇数还是偶数，对于二进制小数来说，最低有效位的值为0视作偶数

![Rounding_Float](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Rounding_Float.jpg)

### 2.4.5 浮点运算

IEEE标准中指定浮点运算行为方法的一个优势在于，它可以独立于任何具体的硬件或软件实现。因此我们可以检查它的抽象数学属性，而不必考虑它实际上是如何实现的。

- 整数（包括无符号和补码）加法形成了阿贝尔群，实数上的加法也形成了阿贝尔群
- 但必须考虑舍入对这些属性的影响。
- 考虑舍入后的运算是可交换的，但是不是可结合的，例如`(3.14 + 1e10) - 1e10 = 0.0` 而`3.14 + (1e10 - 1e10) = 3.14`，前者因为舍入，3.14会丢失。
- 作为阿贝尔群，大多数值在浮点加法下都有逆元，x + -x = 0，而对于无穷和NaN来说例外。正无穷加负无穷得到NaN，任意x＋NaN得到NaN。
- 浮点加法不具有结合性，但是浮点加法满足单调属性，即任意a > b以及c，a + c > b + c，除了NaN。无符号或补码加法不具有单调属性（如a > 0 ，而a + a 可能由于溢出小于0） 。
- 由于舍入失去精度，发生溢出等问题，浮点加法不具有可结合性，3.14的例子，对于浮点乘法在加法上的分配律，也不满足。例如在单精度浮点下1e20  * (1e20 - 1e20) = 0，而1e20 * 1e20 -1e20 * 1e20 = NaN，因为溢出了。
- 但是浮点乘法满足若a >= b且c >= 0 ,则ac >= bc ，若a >= b且c <= 0 ,则ac <= bc ，并且只要不出现NaN，就有a * a >= 0，而无符号数或补码乘法没有（补码a > 0 ，由于溢出 a * a < 0）。

### 2.4.6 C语言中的浮点数

![Floats_In_C](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Floats_In_C.jpg)

# 第3章 程序的机器级表示

## 3.2程序编码

```c
gcc -Og -o p p1.c p2.c
//-Og告诉编译器生成符合原始C代码整体结构的机器级代码
```

**gcc调用一系列程序将源代码转为可执行代码的过程：**以上述命令为例

- 1.C预处理器扩展源代码，插入所有用`#include`命令指定的文件，并扩展所有用`#define`命令指定的宏
- 2.`编译器`产生多个源文件的汇编代码，名字分别为`p1.s`和`p2.s`。
- 3.`汇编器`将汇编代码转换成二进制`目标代码`文件`p1.o`和`p2.o`。
- 4.`链接器`将两个目标代码文件与实现库函数(如printf)的代码合并，并产生最终的可执行代码文件p。
- 目标代码是机器代码的一种形式，包含所有指令的二进制表示，但还没有填入全局值的地址。
- 可执行代码是机器代码的第二种形式，也就是处理器执行的代码格式

### 3.2.1机器级代码

对机器级编程即为重要的两种抽象：

- 1.由指令集架构(ISA，Instruction Set Architecture)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响
- 2.机器级程序使用的内存地址是虚拟地址，提供的内存模型像一个非常大的字节数组。

大多数ISA将程序的行为描述为好像每条指令都是按顺序执行的，一条指令结束后下一条再开始，但实际上处理器的硬件远比描述的复杂精细，它们并发的执行许多指令，并采取一定手段使得整体行为与ISA指定的顺序执行的行为完全一致。

**一些处理器状态：**

- 程序计数器，`PC`，在x86-64中用%rip表示，给出将要执行的下一条指令在内存中的地址。
- 整数`寄存器文件`，包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保存临时数据，例如过程中的参数和局部变量，以及函数返回值。

```c
寄存器文件（register file）又称寄存器堆，是CPU中多个寄存器组成的阵列，通常由快速的静态随机读写存储器（SRAM）实现。这种RAM具有专门的读端口与写端口，可以多路并发访问不同的寄存器。
```

- 条件码寄存器（状态寄存器）保存着最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化，如if或while。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。

虽然C语言提供的模型使得我们可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。C语言中的聚合数据类型如数组和结构，在机器代码中用一组连续的字节来表示。

即使对标量数据类型，汇编代码也不区分有符号和无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。

**程序的内存包含：**

- 程序的可执行机器代码
- 操作系统需要的一些信息，用来管理过程调用和返回的运行时栈
- 用户分配(比如malloc分配的)的内存块

程序用虚拟地址寻址，在任意给定时刻，**只有有限的一部分虚拟地址被认为是合法的，x86-64的虚拟地址是由64位的字来表示的，在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的内存是64TB范围内的一个字节。**操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

### 3.2.2代码示例

```c
//mstore.c
long mult2(long ,long);
void multstore(long x,long y,long* dest) {
    long t = mult2(x,y);
    *dest = t;
}
```

 在命令行使用`-S`选项，能看到编译器产生的汇编代码

```c
gcc -Og -S mstore.c
```

上述命令会使gcc运行编译器产生一个汇编文件`mstore.s`，但不做进一步工作（一般情况下gcc会继续调用汇编器产生目标代码文件）。

汇编代码文件如下：

```
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq 	%rax, (%rbx)
	popq	%rbx
	ret
```

每一行缩进的行都对应于一条机器指令。这段代码中已**除去了所有关于局部变量的名字或数据类型的信息。**

使用`-c`命令行选项，gcc会编译并汇编该代码

```
gcc -Og -c mstore.c
```

上述命令生成一个名为mstore.o的二进制目标代码文件。

- 机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

要查看机器代码文件的内容，使用反汇编器。

- 反汇编器根据机器代码产生类似汇编代码的格式。
- Linux中`objdump -d`充当了这个角色。

```c
objdump -d mstore.o
```

结果如下：

![objdump](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/objdump.jpg)

对应的目标文件中的序列是：

```c
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```

左边是上一行的十六进制字节值，一个数字一个字节，被分成若干组，每组都是一条指令，右边是等价的汇编语言。

关于机器代码及其反汇编表示的特性：

- x86-64的指令长度从1字节到15字节不等。常用的指令以及操作数较少的指令所需字节数少，不太常用的或操作数较多的指令所需字节数较多
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码为机器指令。如只有指令pushq %rbx是以字节值53开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与gcc生成汇编代码使用的有细微差别。在示例中反汇编器省略了许多指令结尾的`'q'`。这些后缀是大小指示符，大多数情况下可以省略，反汇编器还给`ret`和`call`指令添加了后缀`‘q’`，同样的省略也没问题。

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个`main`函数。

```c
//main.c
#include<stdio.h>
void mulstore(long , long , long*);
int main(void) {
    long d;
    mulstore(2,3,&d);
    printf("2 * 3 --> %ld\n",d);
    return 0;
}
long mult2(long a,long b) {
    long s = a * b;
    return s;
}
```

然后使用如下命令行生成可执行文件prog：

```
gcc -Og -o prog main.c mstore.c
```

文件prog不仅包含了两个源文件的代码，还包含了用来启动和终止程序的代码，以及用来和操作系统交互的代码。

同样可以反汇编prog：

```c
objdump -d prog
```

![main](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/main.jpg)

### 3.2.3

![3.2.3_1](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/3.2.3_1.jpg)

- 以`'.'`开头的行都是指导汇编器和链接器工作的伪指令。忽略即可。



![](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/3.3.3_2.jpg)

## 3.3数据格式

- 由于是从16位体系结构扩展成32位的，Intel用术语`“字（word)”`表示16位数据类型。
- 因此32位数据称为`双字(double words)`，64位数为`四字（quad words)`。
- 标准int存储为双字，指针存储为8字节的4字，表格中用char*代指指针。

| C声明       | Intel数据类型       | 汇编代码后缀 | 大小（字节） |
| ----------- | ------------------- | ------------ | ------------ |
| char        | 字节（8位为一字节） | b            | 1            |
| short       | 字（16位为1字）     | w            | 2            |
| int         | 双字                | l            | 4            |
| long        | 四字                | q            | 8            |
| char*(指针) | 四字                | q            | 8            |
| float       | 单精度              | s            | 4            |
| double      | 双精度              | l            | 8            |

- 大多数gcc生成的汇编代码指令都有一个字符后缀，表明操作数的大小
- 例如数据传送指令`mov`有4个变种：`movb(传送字节)`、`movw(传送字)`、`movl(传送双字)`、`movq(传送4字)`。
- 后缀`l`表示双字(long word)
- 汇编代码也使用后缀`l`来表示4字节整数和8字节双精度浮点数，但是不会产生歧义，因为浮点数使用另一组完全不同的指令和寄存器

## 3.4访问信息

一个x86-64的CPU包含一组16个存储64位值的`通用目的寄存器`，这些寄存器用来存储整数数据和指针。

![registers](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/registers.jpg)

**指令可以对这16个寄存器的低位字节中存放的不同字节大小的数据进行操作：**

- 字节级操作可以访问最低的字节
- 16位操作可以访问最低的两个字节
- 32位操作可以访问最低的四个字节
- 64位操作则可以访问整个寄存器

当指令以寄存器作为目标时，对于生成小于8字节数据的指令，寄存器中剩下的字节会怎样有如下两条规则：

- 生成1字节和2字节数字的指令会保持剩下的字节不变
- 生成4字节数字的指令会把高位的4个字节置为0

### 3.4.1操作数指示符

大多数指令都有一个或多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此各种不同的操作数的可能性被分为三种类型。

- 第一种，立即数(immediate)，用来表示常数值，在ATT格式的汇编代码中立即数的书写方式是`‘$’`后面跟一个标准C表示法的整数，如$-577或$0x1F。不同指令允许的立即数的范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
- 第二种，寄存器。它表示某个寄存器的内容，16个寄存器的低位1(8位)/2(16位)/4(32位)/8(64位)字节中的一个作为操作数。
- 第三种，内存引用。它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。
- 寻址模式：

![寻址模式](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F.jpg)

### 3.4.2数据传送指令

最简单的数据传送指令，MOV类，把数据从源位置复制到目的位置。MOV类的四条指令执行的操作相同，只是操作的数据大小不同。

| 指令                  | 效果     | 描述                    |
| --------------------- | -------- | ----------------------- |
| MOV              S，D | S ---》D | 传送                    |
| movb                  |          | 传送字节                |
| movw                  |          | 传送字（2字节）         |
| movl                  |          | 传送双字（长字，4字节） |
| movq                  |          | 传送四字（8字节）       |
| movabsq      I，R     | I ---》R | 传送绝对的4字           |

- 源操作数指定的值是一个立即数，存储在寄存器中或内存中
- 目的操作数指定一个位置，要么是一个寄存器要么是一个内存位置
- x86-64的一条限制：**传送指令的两个操作数不能都指向内存位置：因为一条指令做不到。**
- 将一个值从一个内存位置复制到另外一个内存位置需要两条指令：第一条指令将源值加载入寄存器中，第二条将寄存器中的值写入目的位置
- 这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（b、w、l、q）指定的大小匹配
- 大多数情况下MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。
- 唯一与上述例外的是，`movl`指令以寄存器为目的时，会把寄存器的高位四字节设置为0。
- 造成例外的是x86-64的惯例——**任何为寄存器生成32位值的指令都会把该寄存器的高位4字节设置为0**
- 传送绝对4字的指令是用于处理64位立即数数据的，常规的`movq`指令**只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置**。`movabsq`能以任意64位立即数值作为源操作数，**并且只能以寄存器作为目的**。

![数据传送源和目的的组合](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%BA%90%E5%92%8C%E7%9B%AE%E7%9A%84%E7%9A%84%E7%BB%84%E5%90%88.jpg)

第二类和第三类，MOVZ和MOVS指令类，在将较小的源值复制到较大的目的时使用。**所有的这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器**。MOVZ类中的指令把目的中剩余的字节填充为0，MOVS类中的指令通过符号扩展填充，把源的最高位进行复制。**每条指令名字的最后两个字符都是大小指示符，第一个字符指定源的大小，第二个指明目的的大小**。

![MOVZ&MOVS](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/MOVZ%2526MOVS.jpg)

### 3.4.3数据传输示例

![数据传输shili](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93shili.jpg)

- 间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。
- 像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存快得多。

### 3.4.4压入和弹出栈数据

- 在x86-64中，程序栈存放在内存中的某个区域。弹出的值永远是最近被压入而且仍在栈中的元素。
- 栈向下增长，栈顶元素的地址是所有栈元素地址中最低的。（惯例上栈是倒过来画的，栈顶在图的底部）
- 栈指针`%rsp`保存着栈顶元素的地址
- 将一个4字(64位，8字节)数据压入栈，首先要将栈指针的值减8，然后再将数据写入新的栈顶地址
- 将8字节数据弹出栈，则先将8字节的值复制到目标位置（先从栈顶位置读取数据），然后栈指针的值加8
- 指令的操作数都只有一个：压入栈时的数据源（从某地压入）和弹出栈时的目的（弹出到某地）。

![压入和弹出栈数据](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE.jpg)

- 下图是一个压栈和弹出栈的实例，其中寄存器`%rdx`用来保存被弹出栈的数据，`%rax`则用来保存被压入栈的数据
- 按照惯例栈顶在图的底部，并且栈顶的地址随着压栈是逐渐减小的。
- 多出来的上面的文字不太重要，叙述的是与压栈等价的指令。
- 在弹出栈后0x123仍然会保持在内存位置0x100，直到被覆盖（比如别的数据入栈把它覆盖掉）。

![压栈弹出栈实例](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%8E%8B%E6%A0%88%E5%BC%B9%E5%87%BA%E6%A0%88%E5%AE%9E%E4%BE%8B.jpg)

- 因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存访问方法访问栈内的任意位置。

## 3.5算术和逻辑操作

- 大多数操作都被分成了指令类，这些指令类有各种不同大小的操作数
- 这些操作被分为四组：加载有效地址、一元操作、二元操作、移位。

![算术和逻辑操作](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.jpg)

### 3.5.1加载有效地址

- lea，load effective address
- `leaq`实际上是`movq`的变种，它的指令形式是从内存读取数据到寄存器。
- 但实际上它并没有引用内存，而是将有效地址写入寄存器。
- 还可以简洁的描述普通的算术操作
- 能执行加法和有限形式的乘法。
- 目的操作数必须是一个寄存器。

![leaq](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/leaq.jpg)

### 3.5.2一元操作和二元操作

- 一元操作只有一个操作数，这个操作数既是源又是目的。
- 这个操作数可以是一个寄存器，也可以是一个内存位置
- 二元操作有两个运算符，其中第二个操作数既是源又是目的
- 源操作数是第一个，目的操作数是第二个
- 如 `sub %rax,%rdx`，从寄存器`%rdx`减去`%rax`的值，再把减法得到的值放回`%rdx`。
- 第一个操作数可以是立即数，寄存器，内存位置
- 第二个操作数可以是寄存器或内存位置。
- 当第二个操作数为内存地址时，处理器必须从内存读出值，进行操作，再把结果写回内存。

### 3.5.3移位操作

- 先给出移位量，第二项再给出要移位的数
- 可以进行算术右移和逻辑右移
- 移位量可以是一个立即数，或者放在**单字节寄存器**`%cl`中。
- 只允许以单字节寄存器作为操作数。理论上来说一个字节的移位量可以到达255。但实际不需要这么多，毕竟最长的数据也才64位。
- **x86-64中，移位操作对w位长的数据值进行操作，移位量由%cl寄存器的低m位决定，其中2^m = w。高位会被忽略。**

```c
/**举个例子说明*/
当%cl的值为0xFF(11111111)
对于salb，对8位的操作数移位，最多移7(也就是111，低三位)位
这样也解释了为什么由%cl寄存器的前低m位决定，因为这样最多移位的位数(2^m - 1,也即w - 1)恰好比操作数的位数(w)少一位。
```

- 左移指令有两个名字：`SAL`和`SHL`，二者效果相同，都是左移，右边填上0。
- 右移指令，`SAR`执行算术右移(填充符号位)，`SHR`执行逻辑右移(填充0)

- SAL(shift arithmetic left) 算术左移，SHL(shift logical left) 逻辑左移
- SAR(shift arithmetic right) 算术右移

### 3.5.4讨论

- 大多数算术和逻辑指令，即可用于无符号运算，也可用于补码运算。
- 只有右移操作需要区分有符号数和无符号数。
- 通常编译器产生的代码中会用一个寄存器先后存放多个程序值，还会在寄存器间传送值。

### 3.5.5特殊的算术操作



- 两个64位的数相乘的乘积需要128位来表示
- x86-64指令集对128位提供的支持有限
- 16字节的数据称为8字(oct Word，8个字，128位，字是2字节)
- 一对寄存器组成一个128位8字。
- `imulq`有两种不同的形式，一种是之前图`3-10`给出的两个操作数的指令形式。从两个64位操作数产生一个64位的乘积
- 对于上述形式的来说，当将乘积截取到低64位时，无符号和补码的结果是一样的。

![128位运算](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/128%E4%BD%8D%E8%BF%90%E7%AE%97.jpg)

- `imulq`的另外一种形式是“单操作数"乘法指令形式，`mulq`也是单操作数指令。
- `mulq`和`imulq`**在做128位结果的乘法时都要求乘法的一个参数必须放在寄存器**`%rax`**中**，另一个作为指令的源操作数给出。
- 最终两个64位数的乘积存放在寄存器`%rdx`(高64位)和寄存器`%rax`(低64位)中。
- 编译器可以通过计算操作数的数目来确定`imulq`究竟是哪一种形式，是普通的乘法还是128位的。
- 除法和取模运算都由单操作数除法指令来提供。
- 有符号除法`idivl`将寄存器`%rax`(低64位)和寄存器`%rdx`(高64位)中的128位作为被除数，除数则作为指令的操作数给出。
- 除法运算结果的商保存在寄存器`%rax`，余数则保存在寄存器`%rdx`中。
- 对于大多数64位的除法来说，除数也常常是64位的值。这个值存放在`%rax`中，`%rdx`则全部用其符号位填充(补码运算），无符号运算则全部填充0。在`%rdx`中填充符号位或者0的操作由指令`clto`完成。
- `clto`指令不需要操作数，它隐式读出`%rax`的符号位并将符号位复制到`%rdx`的所有位。

## 3.6控制

目前为止我们只考虑了直线代码的行为，也就是指令一条接着一条顺序地执行。而C语言中诸如条件语句，循环语句和分支语句，要求有条件地执行，根据数据测试的结果来决定执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变程序控制流或者数据流。

与数据相关的控制流是实现有条件行为的更一般和常见的方法。通常C语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序顺序执行。用`jump`指令可以改变一组机器代码指令的执行顺序，`jump`指令指定控制应该被传递到程序的某个其他部分。编译器必须产生构建在这种低级机制的基础之上的指令序列来实现C语言的控制结构。

### 3.6.1条件码

- 除了整数寄存器，CPU还维护着**一组**单个位的`条件码寄存器`，它们描述了最近的算术或逻辑操作的属性。个人也叫它状态寄存器。
- 可以检测这些寄存器来执行条件分支指令。
- 最常用的条件码：
- CF： Carry Flag，进位标志。最近的操作使得最高位产生了进位。可用来检查无符号操作的溢出。
- ZF： Zero Flag，零标志。最近的操作得出的结果为0。
- SF： Sign Flag，符号标志。最近操作得到的结果为负数。
- OF： Overflow Flag，溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

![Condition Flag](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Condition%20Flag.jpg)

- `leaq`不改变任何条件码，因为它是用于地址计算的。
- 除`leaq`之外，图3-10中列出的所有指令都会设置条件码。（加一、减一、按位运算、四则运算、移位、取补取负）
- 对于逻辑操作，进位标志和溢出标志会被置为0。
- 对于移位操作，进位标志将会设置为最后一个被移出的位，而溢出标志设置为0。（什么叫最后一个被移出的位。。）
- `INC`和`DEC`指令会设置溢出和零标志，但不会改变进位标志。
- 除了上述提到的指令以外，还有两类指令会设置条件码。它们只设置条件码而不改变任何其他寄存器。
- 除了只设置条件码而更新目的寄存器，`CMP`指令与`SUB`指令的行为是一样的。
- `TEST`指令与`AND`指令行为一样，除了它们只设置条件码而不改变目标寄存器。**注意一下Test的典型用法，用来测试是正负数。**

![TEST_CMP](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/TEST_CMP.jpg)

### 3.6.2访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

- 根据条件码的某种组合，将一个字节设置为0或者1
- 条件跳转到程序的某个其他的部分
- 有条件地传送数据

对于第一种情况，实现这一类操作的指令叫`SET`指令：

![SET](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/SET.jpg)

- 这一整类`SET`指令之间的区别就在于它们考虑的条件码的组合是什么。
- 指令名字的不同后缀表明了它们所考虑的条件码的组合。
- e：equal、ne：not equal、s：signed？g：greater、ge：greater or equal 、l：less、le：less or equal
- a：above、ae：above or equal、b：below、be：below or equal
- sete：set when equal ，相等时设置，setb：set when below，低于时设置
- 不同后缀表示的不是操作数的大小，而是不同的条件组合。
- **一条`SET`指令的目的操作数是低位单字节寄存器元素之一（图3-2），或者是一个字节的内存位置，指令会将这个字节设置为0或1，为了得到一个32位或64位的结构，我们必须对高位清零**
- 举个比较long a 和long b大小的例子：

![example_CMP](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/example_CMP.jpg)

- 注意第二行汇编代码，比较的时候是从右往左比
- 关于`movzbl`指令参考`图3-5`，MOVZ类是零扩展的数据传送
- 某些底层机器指令可能有多个名字，称为同义名，例如greater 与not less or equal逻辑等价（setg == setnotle）。
- 编译器和反汇编器会随意决定使用哪个名字。
- 虽然所有的算术和逻辑操作都会设置条件码，但是各个`SET`命令的描述都适用的情况是：执行比较指令，根据t = a - b设置条件码。
- 还有一部分因为部分符号原因看不懂 待补：

![待补全部分](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%BE%85%E8%A1%A5%E5%85%A8%E9%83%A8%E5%88%86.jpg)

### 3.6.3跳转指令

正常执行情况下指令按照它们出现的顺序一条条地执行。跳转`jump`指令会导致执行切换到程序中一个全新的位置。

- 在汇编代码中，这些跳转的目的地通常会用一个标号(`label`)指明。

![jump_example](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/jump_example.jpg)

- Null pointer dereference：空指针解引用，`jump .L1`指令使得这条指令被跳过了。
- 在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标(目的指令的地址)编码为跳转指令的一部分。

![jump instruction set](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/jump%20instruction%20set.jpg)

- `jmp`是无条件跳转，它可以是**直接跳转**，也可以是**间接跳转**
- 直接跳转：跳转目标作为指令的一部分编码的
- 间接跳转：跳转目标是从寄存器或内存位置中读出的。
- 汇编语言中，直接跳转给出一个标号（label）作为跳转目标，如`".L1"`。
- 间接跳转的写法是`'*'`后面跟一个操作数指示符。
- `jmp *%rax`以寄存器中的值作为跳转目标，`jmp *(%rax)`以寄存器`%rax`中的值作为地址，从内存中读出跳转目标。
- 表中其他跳转指令都是有条件的——它们根据条件码的某种组合，决定是跳转，还是继续执行代码序列中的下一条指令
- 跳转指令同样有同义名，与`SET`集类似。
- **条件跳转只能是直接跳转，也就是说条件跳转必须直接给出一个label**

### 3.6.4跳转指令的编码

虽然我们不关系机器代码的格式细节，但理解跳转指令的目标如何编码，对理解程序的链接非常重要。同样对理解反汇编器的输出很重要。

- 在汇编代码中，跳转目标用符号标号书写。汇编器以及后来的链接器会产生跳转目标的适当编码。
- 跳转指令有几种不同的编码，但最常用的都是PC相对的（PC-relative）。
- PC相对：将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码（所以PC应该是程序计数器而不是个人电脑）
- PC的值就是下一条将要执行的指令的地址，而紧跟在跳转指令后面那条指令的地址，就是PC保存的地址。
- 第二种编码方法是给出“绝对”地址，用4个字节直接指定目标。（为什么不是64位？）
- 汇编器和链接器会选择适当的跳转目的编码。
- 一个PC相对寻址的例子：

![PCEncodingexample](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/PCEncodingexample.jpg)

```c
/*个人关于反汇编文件的解析*/
//最左边的数字是行号
//次左边的0 3 5等是偏移量，同样也是每一行汇编出来的指令的地址
//原目标代码.o文件对应这个汇编命令序列的代码是：
//48 89 f8;eb 03;48 d1 f8; 48 85 c0; 7f f8;f3 c3，分号分段，十六进制，补码
```

- 反汇编器以16进制给出所有的数字
- 相对PC编码时，目标指令的地址等于PC的值加上编码（编码也就是差）。
- 字节序列都是十六进制的补码，单个数字相当于二进制4位，一个数刚好8位（一个字节），也就是一个字节。
- 执行到第2行的无条件跳转指令时，`eb 03`，(0x)03为目标指令的编码，相对跳转指令的下一条指令，也即PC目前的值，为第三行的地址0x05，二者相加结果为0x08，恰好为跳转目标的地址。
- 同样的分析第5行的有条件跳转，跳转目标的编码为补码的0xf8(十进制-8)，相对第5行的下一条指令的地址为0x0d(十进制13)，二者相加恰好为十进制的5，也是16进制的0x05，恰好为跳转目标的地址。
- 当执行PC相对寻址时，程序计数器的值是跳转指令的下一条指令的地址，而不是跳转指令本身的地址。与早期实现有关。 

![链接后的反汇编](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E9%93%BE%E6%8E%A5%E5%90%8E%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96.jpg)

### 3.6.5用条件控制来实现条件分支

将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

- 下列程序增加了两个用来计数的变量，分别记录两种分支情况出现的次数
- goto版本模拟的是汇编的条件分支

![条件分支](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF.jpg)

- 懒得写了，看图就好，关于如何利用跳转指令实现条件分支

![跳转指令实现条件分支](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF.jpg)

### 3.6.6用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，条件不满足时则走另外一条路径，这种机制在现代处理器上可能会非常低效。

- 替代策略是使用数据的条件转移。计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。只有在一些受限制的情况下有效。但是如果可行就可以用一条简单的条件传送指令来实现它。
- 条件传送指令更符合现代处理器的性能特性。
- 一个示例程序，b）是汇编代码的模拟

![条件传送实现条件分支](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%9D%A1%E4%BB%B6%E4%BC%A0%E9%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF.jpg)

- 先都计算了rval = y -x 和eval = x - y，再测试跳转条件，再确定返回哪个。

- 关于分支预测，由于现在知识有限，以后待补

### 3.6.7循环

C语言提供的循环语句在汇编中都没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。

- gcc和其他汇编器产生的循环代码主要基于两种基本的循环模式。

- 1.`do-while`循环

```c
/*通用形式如下：*/
do
    body-statement
    while(test-expr);//body-statement至少会执行一次
/*可以被翻译成如下的条件和goto语句*/
loop:
	body-statement
	t = test-expr;
	if(t)
        goto loop;
```

- 同样举个例子，用循环求阶乘，goto版本模拟汇编版本的行为。

![dowhile](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/dowhile.jpg)

- `%rax`用来存放返回值，所以很容易确定result存在`%rax`中。
- 逆向过程反汇编出来的汇编代码，需要确定哪个寄存器对应哪个程序值。

- 关于对汇编代码使用逆向工程：

 ![逆向工程](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B.jpg)

- 2.`while`循环
- 有很多种方法将while循环翻译成机器代码，gcc使用其中两种。这两种方法循环结构相同，实现初始测试的方法不同。
- 第一种：跳转到中间
- 第二种：guarded-do

```c
/*while通用形式如下：*/
while(test - expre) 
    bodyStatement;
/*与do-while不同，在第一次执行bodyStatement之前会先对test-expr求值*/
/*第一种翻译方法：跳转到中间（jump to middle）,先执行一个无条件跳转到循环结尾处的测试以实现初始的测试*/
goto test;
loop:
	body-statement;
test:
	t = test-expr;
if(t){
    goto loop;
}
```

```c
/*第二种：guarded-do，首先使用条件分支，如果初始条件不成立就跳过循环，把代码变成do-while循环*/
/*使用较高的优化等级编译时gcc会采取这种策略*/
//模板:
t = test-expre;
if(!t){
    goto done;
}
do:
	body-statement;
	while(t);
done:
/*机器级*/
t = test-expr;
if(!t) {
    goto done;
}
loop:
	body-statement;
	t = test-expr;
	if(t) {
        goto loop;
    }
done:
```

 3.for循环

- gcc为for循环产生的代码是while循环的两种翻译之一，取决于优化等级。

```c
/*通用形式*/
for (init-expr; test - expr; update-expr){
    body-statement;
}
//for循环的行为与如下while循环代码的行为一样：
init-expr;
while(test -expr) {
    body-statement;
    update-expr;
}
```

- 跳转到中间策略：

```c
init-expr;
goto test;
loop:
	body-statement;
	update-statement;
test:
	t = test-expr;
	if(t)
        goto test;
```

- guarded-do策略：

```c
init-expr;
t = test-expr;
if(!t) 
    goto done;
loop:
	body-statement;
	update-statement;
	t = test-expr;
	if(t)
        goto loop;
done:
```

- 练习题3-29还对涉及continue的循环做了些叙述：

![](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111061919104.jpg)

### 3.6.8Switch语句

- Switch(开关语句)语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时有用。
- 使用跳转表(jump-table)数据结构来使得实现更高效。
- 跳转表是一个数组，表项`i`是一个代码段的地址，这个代码段实现当开关索引值为`i`时程序应该采取的动作。
- 程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。
- 和使用一组很长的`if-else`语句相比，使用跳转表的优点在于执行Switch语句的时间与开关情况的数量无关。
- gcc根据开关情况的数量和开关值的系数程度来翻译开关语句。
- 当开关数量比较多(4个以上)且值的范围跨度较小时，就会使用跳转表。
- 一个Switch语句例子：

![微信图片_20211106194255](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111061943418.jpg)

- 关于例子的一些特征：
- 情况标号(case label)跨过一个不连续的区域（没有105和101）
- 有些情况有多个标号（104和106）
- 有些情况落入其他情况之中（102和103），因为对应该情况的代码段没有break语句结尾。
- `&&`为扩展的C语言运算符，创建一个指向代码位置的指针，称为代码指针。
- 图`3-22b`对应的汇编代码：使用了gcc提供的对跳转表的支持，这是对C的扩展。

![微信图片_20211106194929](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111061949467.jpg)

## 3.7过程

- 过程是软件中一种很重要的抽象，提供了一种封装代码的方式：一组指定的参数加可选的返回值实现某些功能。
- 设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。
- 要提供对过程的机器级支持，必须要处理许多不同的属性。
- 假设过程P调用过程Q，过程Q执行完毕后又返回到过程P，这些动作包含下面的数个机制。
  - 传递控制。在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器的值设置为P中`调用Q的那条指令`后面的那条指令的地址。
  - 传递数据。P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。
  - 分配和释放内存。在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。
- x86-64的过程实现包括一组特殊的指令和一些对机器资源（寄存器，内存等）使用的约定规则：最低要求策略。
  - 最低要求策略：只实现上述机制中过程所必需的那些。

接下来一步步描述过程的实现，先描述控制的传递，再描述数据传递，最后是内存管理。

### 3.7.1运行时栈

- C语言过程调用机制的一个关键特性是使用了`运行时栈`。利用栈数据结构后进先出的内存管理原则。
- 在过程P调用Q的例子中，Q在进行时，P及所有向上追溯到P的调用链中的过程，都被暂时挂起。
- Q运行时只需要为局部变量分配空间，或者设置到另外一个过程的调用。
- 当Q返回时，任何它所分配的局部存储空间都可以被释放。
- 因此程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。
- P调用Q时，控制和数据信息添加到栈尾。P返回时，这些信息会被释放掉。
- x86-64栈的栈顶指针向低地址方向增长，而栈顶指针`%rsp`指向栈顶元素，因此可以用`pushq`和`popq`指令将数据存入栈中或者从栈中取出。
- 将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似的可以通过增加栈指针来释放空间。
- **当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。**这个部分称为过程的栈帧(stack fram)。
- 运行时栈的通用结构：

![微信图片_20211106211342](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111062114774.jpg)

- 当前正在执行的过程的帧总是在栈顶
- 过程P调用过程Q时会把返回地址压入栈中，指明当Q返回时，要从P的哪个位置继续执行。这个返回地址看做是P栈帧的一部分。
- Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。
- 栈帧空间中，可以**保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。**
- 大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的栈帧(3.10.5)。
- P通过寄存器最多可以给Q传递6个整数值（指针和整数），如果Q需要更多参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。
- 为了提高时间和空间效率，x86-64过程只分配自己所需要的栈帧。
- 对于参数不超过6个的过程，所有的参数都可以通过寄存器来传递，图3-25某些栈帧其实是可以省略的（用寄存器替代掉就好）。
- 实际上有许多函数甚至根本不需要栈帧。当所有局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时可以这样处理。

### 3.7.2转移控制

- 将控制由P转移到Q只需要简单的将程序计数器设置为Q的代码的起始位置。
- 而从Q中返回时，处理器必须记录好它需要继续执行的P的代码位置。
  - x86-64中，这个信息用指令`call Q`调用过程Q来记录。
  - `call Q`指令会把返回地址A压入栈中，并将程序计数器设置为Q的起始地址。
  - 返回地址是紧跟在调用Q的指令后面的那条指令的地址。
  - 对应指令`ret`从栈中弹出返回地址A，并把程序计数器设置为A。

![微信图片_20211106214107](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111062141668.jpg)

- 关于`call`指令：
  - `call`指令可以有一个目标，即指明被调用过程起始的指令地址。
  - 同跳转一样，调用可以是直接的，也可以是间接的（所以上表call有两种形式）。
  - 汇编代码中直接调用的目标是一个label，间接调用则是`*`后面跟操作数指示符

一个关于`call`和`ret`的例子，懒得写。

![微信图片_20211106215040](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111062151706.jpg)

```c
//还有一个更详细的例子还没看，先往下一节去了
```

### 3.7.3数据传送

当调用一个过程时，不仅需要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64中大部分过程间的数据传送是通过寄存器实现的。x86-64中，可以通过寄存器最多传递6个整型（整数、指针）参数。寄存器使用的名字取决于要传送的数据类型的大小。

![微信图片_20211108110213](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111081102000.jpg)

- 函数如果有超过6个参数，超出6个的部分就要通过栈来传递。
- 假设过程P调用过程Q，过程中有n > 6个参数。则P的代码分配的栈帧必须要能容纳7到n号参数。如`图3-25`，参数`7-n`放入栈中，7号位于栈顶。
- 通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位后就可以执行`call`指令将控制转移到Q。
- Q如果需要调用某个超过6个参数的函数，也需要类似的过程。

### 3.7.4栈上的局部存储

目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中。常见情况：

- 寄存器不足以存放所有的本地数据。
- 对一个局部变量使用取地址运算符`&`,因此必须能够为它产生一个地址。
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。
- 过程通过减小栈指针在栈上分配空间，分配的结果标号为栈帧中`3-25`局部变量部分。
- 一个例子：没有涉及6个以上参数

![微信图片_20211108151458](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111081515372.jpg)

- 关于`caller`的汇编代码的注释：
  - 这里一个long应该按8字节算
  - 第2行：开始把栈指针减去16字节，实际上就是给栈多分配了16字节的空间（刚好存两个long型所需空间）。
  - 第3和4行分别保存534和1057，其中1057在距离栈顶8字节的地方，而534此时恰好处于栈顶。
  - 以S表示栈顶指针的值，第5行计算1057（arg2）的地址，为S + 8，作为`swap_add`第二个参数存在寄存器中。
  - 第6行把534（arg1）的地址S存入寄存器`%rdi`中，`%rsp`中保存的是栈顶指针的值。
  - 第7行调用swap_add()，略过。
  - 第8行从`%rsp`对应的内存处（也就是栈顶）取出第一个参数534，放入`%rdx`。
  - 第9和10略
  - 第11行，增大栈指针16字节，即释放掉栈帧（一开始保存的两个long型整数被丢弃了）。
- 运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。
- 一个涉及6个以上参数的例子：此时必须在栈上分配空间存储参数。

![微信图片_20211108154619](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111081546152.jpg)

![微信图片_20211108155311](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111081553040.jpg)

### 3.7.5寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，但我们仍然必须确保当一个过程调用另一个过程时，被调用者不会覆盖掉调用者稍后会使用的寄存器值。因此x86-64采用了一组统一的寄存器使用惯例，所有的过程都必须遵循。

- 寄存器`%rbx`，`%rbp`，`%r12`~`%r15`被划分为`被调用者保存`寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在P调用Q的前一刻和Q返回到P时是相同的。
- 这种保证有两种方法
  - 根本不去改变它
  - 把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。
  - 压入寄存器的值会在栈帧中创建标号为被`保存的寄存器`的一部分，如图`3-25`

- 所有其他寄存器，除了栈指针`%rsp`,都分类为`调用者保存`寄存器。
  - 任何函数都可以修改它们。
  - 调用者保存：因为被调用者可以随意修改这类寄存器中的值，所以保存好这个数据是调用者P的职责。

为什么不能把所有的局部值都存储在被调用者保存寄存器中？

### 3.7.6递归过程

寄存器和栈的惯例使得x86-64过程可以递归地调用它们自身。每个过程调用在栈中都有它们自己的私有空间，因而多个未完成调用的局部变量不会相互影响。

- 一个递归求阶乘的例子：

![微信图片_20211108191823](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111081918940.jpg)

- 

## 3.8数组分配和访问

### 3.8.1基本原则

```c
//对于数据类型T和整数N，声明一个数组
T A[N];
```

- 声明有两个效果：
  - 在内存中分配 L * N字节的连续区域，L是数据类型T的大小。
  - 引入了标识符A，可以用A来作为指向数组开头的指针，这个指针的值为Xa。
  - 可以用 0 到 N-1的索引来访问该数组元素。
  - 数组元素`i`会被存放在地址为`Xa + L * i`的位置

```c
//B 和 D都是指针数组，单个数组单元都是8字节
char * B[5];
double * D[10];
```

- x86-64的内存引用指令可以用来简化数组访问。例子如下
- 伸缩因子1 2 4 8 覆盖了所有基本简单数据类型的大小。

![微信图片_20211108210303](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111082103959.jpg)

### 3.8.2指针运算

没啥好说的啊。。都是C Primer Plus 提过的。。

- 注意一下两个指针求差，结果是两个地址之差除以该数据类型大小就好。

![微信图片_20211108211433](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111082114442.jpg)

### 3.8.3嵌套的数组

- 数组在内存中按照行优先排列，意味着二维数组第0行的所有元素可以写成 `A[0]`
- 关于访问多维数组
- 其他的截个图吧，没啥好说的。

![微信图片_20211108212040](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111082120124.jpg)

### 3.8.4定长数组

C语言编译器能够优化定长多维数组上的操作代码。

最先看到的居然是一个编程建议：

- 当程序要用一个常数作为数组的维度或缓冲区的大小时，最好通过`#define`将常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。如果需要修改这个常数，只需要修改`#define`处的值
- 一个编译器优化求矩阵A的 i 行和B的 j 列乘积的代码的例子：

![微信图片_20211108214652](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111082147987.jpg)

### 3.8.5变长数组

不想看了。。

## 3.9异质数据结构

### 3.9.1结构

- 结构的所有组成部分都存放在内存中一段连续的区域内
- 指向结构的指针是结构第一个字节的地址。
- 编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。以偏移作为内存引用指令中的位移从而产生对结构元素的引用。
- 结构中的数组也是嵌套在结构中的。

### 3.9.2联合

- 联合允许以多种类型来引用一个对象，与结构不同，联合用不同的字段引用相同的内存块，由下图的偏移量表可以看出。
- 还可以观察到一个联合的总大小等于它最大字段的大小。

![image-20211201185339621](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112011853812.png)

- 当我们事先知道某两个字段的使用是互斥的时候，将两个字段声明为联合的一部分而不是结构的一部分，可以减小空间使用量。
- 联合还可用来访问不同数据类型的位模式：

![image-20211201190239503](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112011902802.png)

### 3.9.3数据对齐

许多计算机系统对`基本数据类型的合法地址`做出了一些限制，要求某种类型对象的地址必须是某个值K(2 4 8)的倍数。

- **这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。**例子可以看书上。
- 无论数据是否对齐，x86-64硬件都能正确工作。不过还是建议对齐数据以提高内存系统的性能。
- 对齐原则是任何K字节的基本对象的地址必须是K的倍数。

| K    | 类型                          |
| ---- | ----------------------------- |
| 1    | char                          |
| 2    | short                         |
| 4    | int，float                    |
| 8    | long，double，char*(指代指针) |

- 确保每种数据类型都满足其对齐限制，即可保证实施对齐。
- **对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。**
- 结构本身也对它的起始地址有一些对齐要求。
  - 必须保证指向S1的指针`p`都满足4字节对齐，这样才能保证p -> i和p -> j(地址p + 8)都满足它们的4字节对齐要求。
- 一个例子：

![image-20211201192840315](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112011928562.png)

- 编译器可能会在结构的末尾增加一些填充，这样使得结构数组中的每个元素都会满足它的对齐要求。
- 栗子：是个单个结构体末尾增加填充嗷！

![image-20211201193716329](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112011937525.png)

### 3.10 在机器级程序中将控制与数据结合起来

- 首先看看数据和控制如何交互
- 指针
- GDB
- 缓冲区溢出
- 机器级程序如何实现函数要求的栈空间大小在每次执行时都可能不同的情况

### 3.10.1理解指针

- 指针类型并不是机器代码中的一部分，它们是C语言提供的一种抽象，帮助程序员避免寻址错误
- &运算符的机器代码实现常常使用`leaq`。
- 数组引用与指针间接引用有一样的效果。，a[3]和*(a + 3)等价
- **将指针从一种类型强制转换为另外一种类型，只改变它的类型而不改变它的值，强制类型转换的另外一个效果是改变指针运算的伸缩，或者说，改变它的伸缩系数**
- 强制转换的优先级高于加减法
- 指针也可以指向函数。函数指针的值是该函数机器代码表示中第一条指令的地址。

![image-20211201200922013](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112012009199.png)

- 关于函数指针的一些说明：

![image-20211201201121226](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112012011553.png)

### 3.10.2gdb

![image-20211201202312557](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112012023757.png)

### 3.10.3内存越界引用和缓冲区溢出

由于C对数组引用不进行边界检查，而且局部变量和状态信息（如保存的寄存器值和返回地址）都放在栈中，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态试图重新加载寄存器或执行ret时，就会出现错误。

- 缓冲区溢出：
  - 分配给函数的缓冲区内存不够，导致写入越界。
  - 例子如下：

![image-20211201210817007](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112012108252.png)

![image-20211201210826363](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112012108650.png)



- 利用缓冲区溢出来攻击：
  - 输入给程序一段字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码。
  - 或者用指向攻击代码的指针覆盖返回地址。执行ret指令的效果就是跳转到攻击代码。
  - 攻击形式1：攻击代码使用系统调用启动shell，给攻击者通过一组操作系统函数。
  - 攻击形式2：攻击代码执行未授权任务，修复此前被破坏的栈，第二次执行`ret`，伪装成正常返回到调用者。

### 3.10.4对抗缓冲区溢出攻击

- 栈随机化：
  - 为了在系统中插入攻击代码，攻击者既要插入攻击代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的地址。
  - 栈随机化的思想使得栈位置在程序每次运行时都有变化。因此即使许多机器运行同样的代码，它们的栈地址都是不同的，避免了`安全单一化`。
  - 实现方法：程序开始时，在栈上分配一段0-n字节的随机大小的空间。程序不使用这段空间，但是这段空间会导致程序每次执行时后续的栈位置发生了变化。
  - n必须足够大以获得足够多的栈地址变化空间，但是又要足够小以保证不浪费程序太多空间。

![image-20211201214622113](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112012146317.png)

![image-20211201215113036](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112012151380.png)

- 栈破坏检测
  - 栈保护者机制：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值（也称为哨兵值）。金丝雀值在程序每次运行时随机产生，因此攻击者没有简单的办法来得知。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者是该函数调用的某个函数改变了，如果金丝雀值改变，程序异常终止。
  - 示意图：

![image-20211202204241666](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112022042133.png)

- 限制可执行代码区域
  - 方法1：限制内存中哪些区域能够存放可执行代码。典型程序中只有保存编译器产生的代码的那部分内存才需要是可执行的，而其他部分会被限制为只允许读和写。

### 3.10.5支持变长栈帧（填坑）

介绍如何实现类似`malloc()`是如何实现的。变长数组是如何实现的。

# 第4章 处理器体系结构





# 

- 一个处理器支持的指令和指令的字节级编码称为它的指令集架构`ISA`。

## 4.1 Y86-64指令集体系结构

- 定义一个指令集架构包括定义各种状态单元，指令集和它们的编码、一组编程规范和异常事件处理。

### 4.1.1 程序员可见的状态

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201221437069.png" alt="image-20220122143749680" style="zoom: 33%;" />

- 状态码：表明程序运行的总体状态。指示是正常运行还是出现异常。

### 4.1.2 Y86-64指令

- 只包含8字节整数，在这里称8字节为字。
- 源：立即数，内存，寄存器。
- 目的：内存和寄存器。**不允许内存到内存和立即数到内存的传送。**
  - 寄存器===》寄存器。
  - 寄存器==》内存。
  - 内存==》寄存器。
  - 立即数==》寄存器。

- 条件传送指令：`cmovXX`。只有条件码满足所需约束才更新目的寄存器的值。
- `halt`：停止指令的执行，在Y86-64中会导致处理器停止并将状态码设置为HLT。
- 寄存器指示符字节：`rA`和`rB`，位于编号为1的字节。指定一个或两个寄存器。
  - **没有寄存器操作数的指令就没有寄存器指示符字节**。
  - **只有一个寄存器操作数的指令将另一个指示符设置为`0xF`。** 
- 后续剩余的字节是附加的常数，可能是立即数，可能是地址。采用绝对寻址。
- `fn`是第零个字节的低四位，功能代码。
- **对整数做操作的指令，都只支持两个寄存器作为操作数**。**唯一支持**立即数作为其中一个操作数的指令貌似只有`irmovq`。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201221451735.png" alt="image-20220122145107354" style="zoom:50%;" />

### 4.1.3 指令编码

- **指令的编码都采用16进制形式书写。**每条指令最少一字节最多十字节。
- 每条指令的第一个字节表明指令的类型。这个字节分为两部分。
  - 高四位是代码部分，0~0xB。
  - 低四位是功能部分。功能值只在一组指令都含有相同的代码部分时有用。
    - 比如整数操作都有一样的代码，区分具体的功能就靠功能部分。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201221510648.png" alt="image-20220122151051342" style="zoom:50%;" />



- 关于15个寄存器的编号。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201221516121.png" alt="image-20220122151626696" style="zoom: 50%;" />

- 指令按照反汇编格式书写时，**整数对应的字节**以相反的顺序出现，也就是小端法编码。
- 一个由汇编语言给出指令编码的例子。这里**整数部分**按照小端法书写。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201221534487.png" alt="image-20220122153435139" style="zoom: 50%;" />

- 指令集的一个重要性质是字节编码序列必须有唯一的解释。
  - 任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的编码序列。
  - 需要知道一个指令编码的起始位置才可以准确解读。

### 4.1.4 Y86-64异常

- 对程序状态码的取值。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202201221553006.png" alt="image-20220122155305532" style="zoom: 50%;" />

### 4.1.5 Y86-64程序

### 4.1.6 一些Y86-64指令的详情

- 关于出栈和入栈指令的详情。
- **仅仅针对的是`pushq %rsp` 和 `popq %rsp`指令。**
  - 在这种情况之下就需要考虑，被压入栈内存的值是`%rsp`的原始值还是减8之后的值。
  - 出栈同样有类似的歧义需要考虑，是将`%rsp`置为从栈内存中弹出的值，还是将`%rsp`置为加了增量之后的栈指针的值。
  - 原因是`%rsp`保存的是栈指针的值，而这两条指令除了会将`%rsp`的值压入栈内存以外，还会修改`%rsp`的值。
    - 于是就有一个先后顺序的问题，是先修改寄存器的值再压栈，还是先压栈再修改寄存器的值。出栈则有类似的问题。
- 经手工编写汇编代码得出，对于`%rsp`作为压栈操作数的情况下，先压栈再修改寄存器的值。
- 对于`%rsp`作为弹出栈的操作数的情况下，将`%rsp`的值置为从栈内存弹出的值，而不是加了增量之后的栈指针的值。
  - 当然，需要另取一个寄存器保存栈指针的值，不能让它丢失。

# 第二部分 在系统上运行程序

# 第7章链接

链接是将各种代码和数据片段收集并组合为一个单一文件的过程。这个文件可被加载到内存并执行。

- 链接可以执行于：
  - 编译时。也即源代码被翻译成机器代码时。
  - 加载时。也即程序被加载器(`loader`)加载到内存并执行时。
  - 运行时。也即由应用程序来执行。
  - 早期的计算机中链接手动执行。现代操作系统由链接器(`linker`)来自动执行。

- 链接器的作用：链接的好处，使得分离编译(`separate compilation`)成为可能。
  - 不需要将一个大型的应用程序组织为一个巨大的源文件，而可以把它分解为更小的模块。
  - 更小的模块便于管理，可以独立修改和编译这些模块。
  - 当改变这些模块中的某一个时，只需要对这个模块重新编译，并重新链接应用，而不需要重新编译所有文件。

- 为什么需要学习链接相关的内容

  <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211224205836597.png" alt="image-20211224205836597" style="zoom: 50%;" />

## 7.1 编译器驱动程序

大多数`编译系统`提供`编译器驱动程序(compiler driver)`：预处理器、编译器、汇编器、链接器。

- 示例程序：懒得写 配个图。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211224210640831.png" alt="image-20211224210640831" style="zoom: 33%;" />

- 编译器驱动程序将示例程序从ASCII源码文件翻译成可执行目标文件的具体过程：
  - 第一步C预处理器(`cpp`)将`main.c`和`sum.c`翻译成**ASCII码的**中间文件`main.i`和`sum.i`。
  - 第二步C编译器(`ccl`)将`main.i`和`sum.i`翻译成**ASCII**汇编语言文件`main.s`和`sum.s`。
  - 第三步C汇编器(`as`)将`main.s`和`sum.s`翻译成可重定位目标文件(`relocatable object file`)`main.o`和`sum.o`。
  - 第四步C链接器(`ld`)将`main.o`和`sum.o`**以及一些必要的系统目标文件**组合起来，创建一个可执行目标文件(`executable object file`)。
  - `shell`调用`操作系统中`一个叫`加载器(loader)`的函数，将可执行文件中的代码和数据复制到内存，**然后将控制权转移到这个程序的开头**

## 7.2 静态链接

像`LinuxLD`这样的`静态链接器`(`static linker`)以一组可重定位目标文件(`.o`文件)和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

- 输入的可重定位目标文件由各种不同的代码和数据节(section)组成。每一节都是一个连续的字节序列。
  - 指令在一节中，初始化了的全局变量在另一节中，未初始化的其他变量又在另一节中。

- 链接器在构造可执行文件的过程中的两个主要任务：
  - 符号解析(symbol resolution)。目标文件定义和引用*符号*，每个*符号*对应于一个函数、一个全局变量或一个静态变量。
    - 符号解析的目的是将每一个符号引用和一个符号定义关联起来。
  - 重定位(relocation)。编译器和汇编器生成的各个模块的代码和数据节，**字节都是从地址零开始的**。
    - 链接器通过把每个符号定义与一个内存位置关联起来，来重定位这些节，然后修改**所有**对这些符号的引用，使他们指向和符号定义关联的那个内存位置。**链接器使用汇编器产生的重定位条目(relocation entry)的详细指令，不加甄别的执行重定位。**

- 关于目标文件的一些基本事实：
  - 目标文件纯粹是字节块的集合。
  - 字节块可以是程序代码。
  - 可以是程序数据。
  - 可以是引导链接器和加载器的数据结构。
- 链接器将这些字节块链接起来，确定被连接块的`运行时位置`，并修改代码和数据块中的各种位置。编译器和汇编器完成了大部分工作。

## 7.3 目标文件

- 目标文件的三种形式：
  - 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建可执行目标文件。
  - 可执行目标文件。包含二进制代码和数据，其形式可被直接复制到内存并执行。
  - 共享目标文件。特殊类型的可重定位目标文，可以在加载或者运行时被动态地加载进内存并链接。
  - 编译器和汇编器生成可重定位目标文件，链接器生成可执行目标文件。

- 一个目标模块(object module)是一个字节序列。一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块。
  - 术语可互换。
- 目标文件按照特定的目标文件格式来组织，各个系统的格式都不相同。
  - Unix：a.out
  - Windows：可移植可执行格式(Portable Executable,PE)格式
  - macOS：Mach-O
  - X86-64Linux和Unix：可移植可链接格式(Executable and Linkable Format,ELF)

## 7.4 可重定位目标文件

- 典型的`ELF`可重定位目标文件的格式
  - ELF头(ELF Header)：以16字节序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。剩下的部分包含ELF头的大小、目标文件类型(共享的、可重定位、可执行)、机器类型(如x86-64)、节头部表(section header table)的文件偏移、节头部表中条目的大小和数量。
  - 不同节的位置和大小由节头部表描述，目标文件中每个节都有一个固定大小的条目(entry)。
- ELF头（包含它）和节头部表之间的部分每一部分都是节。典型的构成如下（ELF头标号为0，`.text`节标号为1，以此类推）
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225144511281.png" alt="image-20211225144511281" style="zoom: 33%;" />
  - `.text`：已编译程序的机器代码。
  - `.rodata`：ReadONLYData，比如`Printf()`的格式串和`Switch`语句的跳转表。
  - `.data`：**已初始化**的**全局和静态**C变量。局部C变量在运行时被保存在栈中，不出现在`.data`和`.bss`节中。
  - `.bss`：**未初始化的全局和静态**C变量，以及**所有被初始化为0的全局和静态变量**。在目标文件中这个节不占实际的空间，只是一个占位符。目标文件中未初始化的变量不需要占据任何实际的磁盘空间，运行时在内存中分配这些变量，初始值为0。
  - `.symtab`：存放在程序中定义和引用的函数和全局变量的信息。和编译器中的符号表不同，`.symtab`不包含局部变量的条目。
  - `.rel.text`：一个`.txet`节中位置的列表。当链接器链接各个文件时需要修改这些位置。一般而言任何调用外部函数和引用全局变量的指令都需要修改。调用本地函数的指令则不需要修改。可执行目标文件中并不需要重定位信息，但是可以人为指定包含。
  - `.rel.data`：被模块引用或定义的所有全局变量的重定位信息。
  - `debug`：一个调试符号表，包含程序中定义的局部变量和类型定义、程序中定义和引用的全局变量，以及原始的C源代码文件。编译时添加`-g`选项才会得到。
  - `.line`：原始C代码行号和`.text`节中机器指令之间的映射。编译时添加`-g`选项才会得到这张表。
  - `.strtab`：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225101759642.png" alt="image-20211225101759642" style="zoom: 80%;" />

## 7.5 符号和符号表

- 每个可重定位目标模块m都有一个符号表。包含m定义和引用的符号的信息，分为三类：

  - 由模块m定义并能被其他模块引用的*全局*符号。全局链接器符号对应于**非静态的**C函数和全局变量。
  - 由其他模块定义并被模块m引用的*全局*符号。称为外部符号，对应在其他模块定义的**非静态**C函数和**非静态**全局变量。
  - 只被模块m定义和引用的*局部*符号。对应于带`static`属性的C函数和`static`全局变量。这些符号能在模块m的内部任何位置可见，但不能被其他模块引用。
- `.symtab`中不包含非静态的本地变量，这些符号在运行时在栈中被管理。
- 定义带有`static`的本地变量不在栈中管理，编译器在`.data`或`.bss`中为每个定义分配空间。懒得写了 看图。
- <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225110449624.png" alt="image-20211225110449624" style="zoom: 50%;" />
- 符号表由**汇编器**构造，使用编译器输出到汇编语言的`.s`文件中的符号。`.symtab`节包含ELF符号表。这张符号表包含一个数组，数组由一种结构体作为每个单元：懒得写代码，配图自己看结构体长啥样。
  - ![image-20211225142601586](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225142601586.png)

- `name`：字符串表中的字符偏移。
- `value`：符号的地址。对于可重定位模块来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说value是绝对运行时地址。
- `size`：目标以字节为单位的大小。
- `type`：符号的类型，要么是函数，要么是数据。
- `binding`：这个符号是本地的还是全局的
- 符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目。
- `section`：到节头部表的索引。每个符号都被分配到目标文件的某个节。
- 三个特殊的伪节(pseudo section)，在节头部表中没有条目
  - ABS：不该被重定位的符号。
  - UNDEF：未定义的符号，也即在本模块引用而在其他地方定义的符号。
  - COMMON：还未被分配位置的未初始化的数据目标。`value`给出对齐要求，`size`给出最小大小。
  - 可执行目标文件中没有伪节，只有可重定位目标文件有。


- 如何区分`COMMON`和`.bss`：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225145549547.png" alt="image-20211225145549547" style="zoom: 50%;" />

- 实例程序的目标文件的查看的例子，使用的是`GNU READELF`，懒得写了。`Ndx`应该就是index吧。

  - 注意一下`sum`的`Ndx`是UNDEF。这是来自外部的引用。不过VIS是啥。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225150157117.png" alt="image-20211225150157117" style="zoom:50%;" />

  - ![image-20211225150211081](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225150211081.png)

- [About Static Function In C](https://www.geeksforgeeks.org/what-are-static-functions-in-c/)
  - *Unlike global functions in C, access to static functions is restricted to the file where they are declared. Therefore, when we want to restrict access to functions, we make them static. Another reason for making functions static can be reuse of the same function name in other files.*
- [About Static Variable In C](https://www.geeksforgeeks.org/static-variables-in-c/)
- [About Memory Layouts In C](https://www.geeksforgeeks.org/memory-layout-of-c-program/)
- [About Static Global Variables In C Stack Overflow](https://stackoverflow.com/questions/1856599/when-to-use-static-keyword-before-global-variables) 

## 7.6 符号解析

- 链接器解析符号引用的方法：将每个引用与**输入给链接器的**可重定位目标文件的符号表中的某个确定的符号定义关联起来。
  - 引用和定义在同一模块的局部符号解析起来简单。编译器只允许每个模块中每个局部符号有一个定义。
  - 静态局部变量会有本地链接器符号，编译器确保它们拥有唯一的名字。
- 对全局符号的引用解析：符号：函数名或变量
  - 编译器遇到不在当前模块定义的符号时，假定该符号已在其他某个模块定义，生成一个链接器符号表条目，并把它交给链接器处理。
    - 如果链接器在它的任何输入模块中都找不到这个被引用的符号的定义，就输出一条狗都不读的错误信息并终止。
    - 举个例子，课本上的。可以编译但无法链接。
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225151859129.png" alt="image-20211225151859129" style="zoom: 33%;" />

### 7.6.1 链接器如何解析多重定义的全局符号

- 大前提：链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的(只对定义该符号的模块内可见)，有些是全局的(对所有模块可见)。我们要解决的问题是：多个模块定义同名的全局符号，如何处理。
- 叙述Linux编译系统采用的方法
- 首先引入强符号和弱符号的定义：汇编器把符号的强弱信息隐含地编码在可重定位目标文件的符号表里
  - `强符号`：函数和已经初始化过的全局变量为强符号。
  - `弱符号`：未初始化的全局变量是弱符号。
- 根据强弱符号的定义，Linux链接器按照如下规则处理多重定义的符号名
  - 规则1：不允许有多个同名的强符号。这种情况下链接器会生成错误信息。
  - 规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。这种情况下链接器会安静的选择强符号，不会表明自己检测到多个定义。
  - 规则3：如果有多个弱符号同名，那么从这些弱符号中任选一个。这种情况下链接器同样很安静。
  - 所以规则2和3会造成一些不易察觉的运行时错误，尤其是多重定义下每个定义的类型不同。举一个例子，这个例子同一个符号被定义成int和double。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225161800968.png" alt="image-20211225161800968" style="zoom: 50%;" />



<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225161855447.png" alt="image-20211225161855447" style="zoom: 50%;" />

- 关于，伪节`COMMON`为什么会存在:
  - <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225163256541.png" alt="image-20211225163256541" style="zoom: 50%;" />

### 7.6.2 与静态库链接

- 目前的情况：我们都假设链接器得到一组可重定位目标文件，把它们链接起来，形成一个可执行目标文件。

- 编译系统还提供一种机制：将所有相关的目标模块打包成一个单独的文件，称为静态库(`static library`)，它可以作为链接器的输入。

  - 当链接器构造可执行文件输出时，**它只复制静态库里被应用程序引用的目标模块**

- 相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。链接时链接器只复制被程序引用的目标模块。

- Linux系统中静态库以存档(`archive`)的特殊文件格式存放在磁盘中。

  - 存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件后缀为`.a`。

- 一个把自定义的源代码打包成静态库并投入使用的例子

  - 注意一下`gcc`的命令行选项还有AR工具。

  <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225175655316.png" alt="image-20211225175655316" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225175722361.png" alt="image-20211225175722361" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225175738452.png" alt="image-20211225175738452" style="zoom:50%;" />

### 7.6.3 链接器如何使用静态库来解析引用

- 大前提：使用命令行来进行链接。存档是由很多可重定位目标文件成员构成。
- 在符号解析阶段，链接器从左向右扫描命令行参数，同时维护三个集合，初始时这三个集合全为空。
  - 集合E为可重定位目标文件的集合，这个集合里的文件稍后合成可执行文件。
  - 集合U为未解析(未定义但是引用了)的符号的集合。
  - 集合D为在前面输入文件中已经定义的符号的集合。
- 扫描的过程中，遇到一个文件F，链接器判断F是可重定位目标文件还是存档文件，如果是前者链接器就将F放入集合E，同时修改集合D和U来反映F中的符号定义和引用（添加一个F可能导致旧符号的定义补全，同时出现新的未定义符号）。然后继续下一个输入文件。
- 如果遇到的文件F是存档文件，那么链接器尝试匹配U中未解析的符号和由存档文件成员定义的符号，如果发现存档文件中的某个可重定位目标文件成员m匹配了U中某个未解析的符号，那么链接器就将m加入集合E中，并修改集合U和D来反映。对存档文件中的所有成员都进行目标文件都进行这个过程，直到U和D不再发生变化。此时存档文件中未被添加进集合E的成员都会被丢弃不用。链接器继续处理下一个输入文件。
- 当链接器完成对所有输入的文件的扫描和相应处理之后，它会检查U是否为空，如果不为空（也就是仍然有符号找不到定义），那么链接器报错并终止。否则链接器合并集合E中的文件，构建输出的可执行文件。

**这种算法会导致一个问题**

- 因为命令行上的库文件和可重定位目标文件的顺序非常重要。
- **如果定义一个符号的库出现在引用这个符号的目标文件之前，那么遇到这个库的时候，由于集合U中没有相应的符号，这个库就会被丢弃，待到后来相应的目标文件被处理的时候，引用就不能被解析，链接会失败。**
- 关于库的一般准则是将库放在命令行参数的最末尾。
- 如果各个库直接是独立的，也就是库与库之间不存在符号的相互引用，那么库的输入顺序没有要求。
- **如果库与库之间存在符号的相互引用，那么要保证引用符号的库出现在定义这个符号的库的前面（至少有一个定义了被引用符号的库出现在引用符号的库之后）。**

- 一个比较特殊的例子，某个库需要在命令行上重复出现多次：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225185420555.png" alt="image-20211225185420555" style="zoom:50%;" />

## 7.7 重定位

- 大前提：链接器完成了符号解析，现在每一个符号引用都找到了它对应的符号定义。
- 并且链接器也知道了它输入的所有目标模块中的代码节和数据节大小。可以开始重定位了。
- 重定位：合并输入模块，并为每个符号分配运行时地址。两个步骤：
  - 重定位节和符号定义。
    - 链接器合并所有相同类型的节得到一个新的聚合节，如将所有模块的`.data`节合并成输出可执行文件的`.data`节。
    - 链接器将运行时内存地址赋给新的聚合节、赋给输入模块定义的每个节、赋给输入模块定义的每个符号。
    - 这一步完成后程序中的每条指令和全局变量都有唯一的运行时内存地址了。
  - 重定位节中的符号引用
    - 链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。
    - 依赖于一种数据结构——重定位条目(relocation entry)。

### 7.7.1 重定位条目

- 大前提：当汇编器生成一个目标模块时，它**并不知道**数据和代码最终会放在内存中的什么位置。
- 它**也不知道**这个模块引用的任何外部定义的函数或全局变量的位置。
- 汇编器遇到对最终位置未知的目标引用时，就生成一个*重定位条目*，告诉链接器后续合并文件生成可执行文件的时候如何修改这个引用。
- 代码的重定位条目放在`.rel.text`中，已初始化的数据的重定位条目放在`.rel.data`中。
- 重定位条目是一个结构体：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225194349428.png" alt="image-20211225194349428" style="zoom:50%;" />

- **两种最基本的重定位类型**，`type`的作用就是指明是哪一种。
  - 重定位PC相对地址的引用
  - 重定位绝对地址的引用。
  - 注意一下小型代码模型是什么，其他的看图。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225194754773.png" alt="image-20211225194754773" style="zoom: 50%;" />

### 7.7.2 重定位符号引用

- 大前提：

  - 每个节s是一个字节数组。
  - 每个重定位条目r是一个`Elf64_Rela`结构(图7-9定义的)。
  - 算法运行前链接器已为每个节和每个符号分配了运行时地址。分别用`ADDR(s)`和`ADDR(r.symbol)`表示。

  <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225201712741.png" alt="image-20211225201712741" style="zoom:33%;" />

```c
foreach section s {
    foreach relocation entry r {
        refptr = s + r.offset;//待重定位的引用的指针
        /*PC相对地址引用的重定位*/
        if(r.type == R_X86_64_PC32) {
            refaddr = ADDR(s) + r.offset;//ref 的运行时地址
            refptr = (Unsigned)(ADDR(r.symbol) + r.addend - refaddr); 
        }
        /*绝对地址重定位*/
        if(r.type == R_X86_64_32) {
            *refptr = (Unsigned)(ADDR(r.symbol) + r.addend);
        }
    }
}
```

- 具体细节实在他妈的看不懂啊啊啊啊啊啊啊啊啊啊啊啊啊啊不想看了



## 7.8 可执行目标文件

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/image-20211225205625008.png" alt="image-20211225205625008" style="zoom:50%;" />

## 7.9 加载可执行目标文件

- 通过调用加载器(`loader`)来运行一个可执行文件，加载器将可执行文件中的代码和数据从硬盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个过程叫加载。
- 还有一堆懒得写笔记了

## 7.10 动态链接共享库

- 静态库存在的问题：
  - 静态库也是需要维护和更新的，所以如果需要使用最新版本的库，需要想办法找到最新版本的库然后显式地将程序和更新了的库重新链接。
  - 有一些库函数，比如输入和输出函数，几乎所有的程序都会用到，于是每个进程都需要复制一遍这些代码，浪费内存。
- 共享库(shared library)致力于解决静态库的缺陷。
  - 共享库是一个目标模块，可以在运行或加载时加载到任意内存地址，并和处于内存中的程序链接起来。
  - 这个过程称作动态链接(dynamic linking)，由动态链接器(dynamic linker)来执行。
  - 共享库也称作共享目标(shared project)。Linux中为`.so`后缀，巨硬的操作系统中的`DLL`文件就是动态链接库。
- 任何给定的文件系统，一个库只有一个`.so`文件，所有引用该库的可执行目标文件共享这个文件中的代码和数据。
- 共享库中的内容在共享的时候不会像静态库那样复制和嵌入到引用它们的可执行文件中去。
- 在内存中，共享库的`.text`节的一个副本可以被不同的正在运行的进程共享。

# 第8章 异常控制流

从给处理器加电开始，到给它断电为止，程序计数器假设一个值的序列：`a0，a1，a3.....，an`，每个`ak`是某个相应指令Ik的地址，每次从`ak`到`ak+1`的过渡称为控制转移。这样的控制转移序列叫做处理器的控制流。

- 最简单的控制流是一个平滑的序列，任意两条指令在内存中都是相邻的。
- 平滑流的突变（也就是要执行的指令和它的下一条指令不相邻）通常是由跳转、调用、返回之类的指令造成。

但系统也要能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。

现代系统通过使控制流发生突变来对这些情况做出反应。这些突变称为异常控制流（Exceptional Control Flow，ECF）。

- ECF是操作系统实现I/O、进程和虚拟内存的基本机制。
- 应用程序通过使用一个叫陷阱（trap）或者系统调用的ECF形式，向操作系统请求服务。
- ECF是计算机系统中实现并发的基本机制。
- throw in java catch in java try in java 如何实现的？ECF
- 异常位于硬件和操作系统交界的部分。
- 进程和信号位于应用和操作系统的交界之处。
- 非本地跳转是ECF的一种应用层形式。

## 8.1异常

- 异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。具体细节随系统不同而有所不同，基本思想相同。
- 异常就是控制流中的突变，用来响应处理器状态中的某些变化。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112022140649.png" alt="image-20211202214028509" style="zoom: 67%;" />

- 处理器中，状态被编码为不同的位和信号。状态的变化称为事件。事件可能和当前指令的执行直接相关，但也可能毫无关系。

- 任何情况下，处理器检测到事件发生时，就会通过名为异常表（exception table）的跳转表进行一个间接过程调用，跳转到异常处理程序（exception handler）。异常处理程序是专门设计用来处理这类事件的操作系统子程序。

- 异常处理程序处理完后，根据引起异常的事件类型，有三种情况：

  <img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112022152988.png" alt="image-20211202215252863" style="zoom:80%;" />

### 8.1.1 异常处理

处理异常需要硬件软件结合，软硬件各有分工。

- 系统中每一种可能的异常都有唯一的一个非负整数异常号（exceptional number）。
  - 一部分由处理器的设计者分配：如被零除、缺页、内存访问违例、断点、算术运算溢出。
  - 其他号码由操作系统内核设计者分配：如系统调用、来自外部的I/O设备的信号。
- 系统启动时操作系统分配和初始化异常表，表目`k`包含异常`k的处理程序的地址`。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112022222396.png" alt="image-20211202222210225" style="zoom:50%;" />

- 处理器检测到一个事件，并且确定了相应的异常号k，随后处理器触发异常，通过异常表的表目K转到相应的处理程序。
- 异常表的起始地址放在一个特殊的`异常表基址寄存器`中

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112022226263.png" alt="image-20211202222622151" style="zoom:50%;" />



<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112022249267.png" alt="image-20211202224945009" style="zoom: 50%;" />



### 8.1.2异常的类型

- 异常分为四类：中断、陷阱、故障、终止。



# 第三部分 程序间的交互和通信

# Chapter 10 系统级 I/O

## 10.1 Unix I/O

- 一个Linux文件就是一个m字节的序列，所有的*I/O*设备都被模型化为文件，所有的输入输出都被当做对相应文件的读和写。
  - 打开文件：内核来打开所需文件（或者访问一个I/O设备），返回一个非负整数，称作文件描述符，描述符是对被打开的文件的标记。内核记录被打开的文件的信息，应用程序只需记住描述符。
  - `Linux shell`创建每个进程都会固定打开三个文件：标准输入(FD = 0)、标准输出(FD = 1)，标准错误(FD = 2)。可分别用`STD_FILENO`、`STDOUT_FILENO`、`STDERR_FILENO`来代替显式的文件描述符值。
  - `文件位置k`：初始为0，是从文件开头起始的字节偏移量。可通过`seek`显式设置k的值。
  - 读写文件：读操作是从文件复制`n>0`个字节到内存，从当前文件位置`k`开始，然后将k增加到`k+n`。给定大小为M字节的文件，当`k`大于等于`M`时，执行读操作会触发`EOF`，应用程序可以检测到这个条件(How?)。**文件结尾处并没有明确的“EOF符号”**。写操作则是从内存复制`n>0`个字节到一个文件，然后更新文件位置k的值。
  - 关闭文件：应用完成对文件的访问后，通知内核关闭这个文件。内核负责释放文件打开时创建的数据结构，并将文件描述符放回可用的描述符池中。无论一个进程因为何种原因终止，内核都会关闭所有打开的文件并释放它们的内存资源。

## 10.2 文件

每个Linux文件都有一个类型表明它在系统中的角色。

- 普通文件（regular file）：包含任意数据。通常区分文本文件(text file)和二进制文件(binary file)，文本文件只包含`ASCII`或`Unicode`字符的文件。二进制文件就是所有其他的文件。**对内核而已二进制文件和文本文件没有区别。**Linux文本文件包含了一个文本行(text line)序列，每一行都是一个字符序列，以新行符`\n`结束。新行符与ASCII换行符(LF)都为`0x0a`。
- 目录(directory)：包含一组链接(link)的文件。每个链接都将一个文件名(file name)映射到一个文件，**这个文件可能是另外一个目录**。每个目录都至少含有的两个条目：`.和..`，前者是到该目录自身的链接，后者是到该目录的上级父目录(parent directory)。
- 套接字(socket)：用来与另一个进程进行跨网络通信的文件。
- 不在本书讨论范围的文件：命名通道(named pipe)、符号链接(symbolic link)、以及字符和块设备(character and block device)。
- 文件的目录层次结构：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131016764.png" alt="image-20211213101645540" style="zoom: 50%;" />



- 路径名：绝对路径和相对路径

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131019814.png" alt="image-20211213101950539" style="zoom: 50%;" />

## 10.3 打开和关闭文件

进程调用`open()`来打开一个已存在的文件或创建一个新文件。

```c
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
int open(char * filename , int flags , mode_t mode);//成功则返回文件描述符，失败则返回-1
int fd = open("foo.txt" , O_RDONLY , 0);//以只读方式打开一个已存在文件。
```

- 返回的文件描述符是当前进程中没有打开的可用的最小文件描述符

- flags参数指明进程打算如何访问这个文件：flag参数同样可以是多个flag的或，为写入提供额外的指示。

  - O_RDONLY：只读

  - O_WRONLY：只写

  - O_RDWR：可读可写。

  - O_CREAT：若文件不存在就创建一个截断的(truncated)空文件。

  - O_TRUNC：如果文件已存在，就截断它。

  - O_APPEND：在每次写操作前设置文件位置K到文件结尾处。也就是在原有文件的后面添加新的内容。

  - ```c
    //打开已存在文件并在后面添加内容
    int fd = open("foo.txt" , O_WRONLY|O_APPEND , 0);
    ```

- mode参数指定新文件的访问权限位。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131049364.png" alt="image-20211213104929160" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131049554.png" alt="image-20211213104937335" style="zoom: 50%;" />

- 进程调用`close()`关闭打开的文件

```c
#inlcude<unistd.h>
int close(int fd);//关闭成功返回0，失败返回-1
```

## 10.4 读和写文件

应用程序调用`read()`和`write()`来执行输入输出

```c
#include<unistd.h>//unix std
ssize_t read(int fd , void * buf , size_t n);//成功的返回读取的字节数，EOF则为0，失败返回-1
ssize_t write(int fd , const void * buf , size_t n);//成功返回写的字节数，出错返回-1
```

- `read()`从`fd`对应的当前文件位置复制最多`n`个字节到内存位置`buf`。
- `write()`从内存位置`buf`复制最多`n`个字节到`fd`对应的当前文件位置。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131109836.png" alt="image-20211213110942479" style="zoom: 50%;" />

- 不足值：`read()`和`write()`传送的字节比参数`n`要小。不表示出错。
  - 读磁盘文件只会遇到EOF。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131116457.png" alt="image-20211213111609094" style="zoom: 50%;" />

## 10.5 用RIO包健壮地读写（待补捏）

## 10.6  读取文件元数据

调用`stat()`和`fstat()`读取文件元数据。

```c
#include<unistd.h>
#include<sys/stat.h>
int stat(const char* filename , struct stat* buf);//成功返回0，出错则返回-1
int fstat(int fd ,struct stat* buf);//成功返回0，出错返回-1
//stat借助文件路径打开
//fstat借助文件描述符打开
```

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131529199.png" alt="image-20211213152923968" style="zoom: 67%;" />

- `st_mode`编码了文件访问许可位(图10-2)和文件类型。使用宏定义了如下类型：
  - S_ISREG(m)。是普通文件?
  - S_ISDIR(m)。是目录？
  - S_ISSOCK(m)。是套接字？
  - 一个demo，关于如何使用上述三个东西:

```c
#include "csapp.h"
int main(int argc , char **argv) {
    struct stat stat;
    char *type , *readok;
    //使用stat来读取文件的元数据
    Stat(argv[1] , &stat);
    if ( S_ISREG(stat.st_mode) ) {
        type = "regular";
    }
    else if ( S_ISDIR(stat.st_mode) ) {
        type = "directory";
    }
    else
        type = "socket";
    if ( (stat.st_mode & S_IRUSR) )//访问读权限
        readok = "yes";
    else
        readok = "no";
    printf(".....");
    exit(0);
}
```

## 10.7 读取目录内容

- 流是对条目有序列表的抽象，在这里指目录项的列表。

```c
//使用这个系列的函数读取目录内容
#include<sys/types.h>
#include<dirent.h>
DIR* opendir(const char * name);//成功返回指针，失败返回NULL
//以路径名为参数，返回指向目录流的指针
```

```c
#include<dirent.h>//directory entry
struct dirent * readdir(DIR* dirpointer)//成功则返回指向下一个目录项的指针；没有更多目录项或出错则返回NULL
```

- 关于`struct dirent`
  - 这个是对所有版本的Linux来说标准的。有的Linux版本结构中还会有其他的结构成员。
  - 读取目录项出错的时候`readdir()`会返回NULL并设置`errno`。
  - 唯一区分是没有更多目录项还是出错，是检查自调用`readdir()`以来`errno`是否被修改过。

```c
struct dirent {
    ino_t d_ino;/*inode number，文件位置*/
    char  d_name[256];/*FileName*/
}
```

- 用来关闭流并释放所有资源

```c
#include<dirent.h>
int closedir(DIR * dirpointer);//成功返回0，失败返回-1。
```

-  demo:

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131640811.png" alt="image-20211213164055642" style="zoom: 50%;" />

## 10.8 共享文件

内核用三个相关的数据结构来表示打开的文件：

- 文件描述符表(descriptor table)。每一个进程都有它独立的文件描述符表，它的表项是由该进程打开的文件描述符来索引的。每个打开的文件描述符表项指向文件表中的一个表项。
- 文件表(file table)。打开的文件的集合由一张文件表来表示，所有的进程共享这张表。每个文件表的表项由：当前的文件位置、引用计数（即当前指向该表项的文件描述符个数），以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应文件表表项引用计数的值，当引用计数值变为零时，内核从文件表中删除这个文件表表项（v-node表应该也会删掉？）。
- v-node表(v-node table)。所有的进程共享这张`v-node`表。每个表项包含的是stat结构中的大多数信息。可以说是元数据的表?
- 典型情况：没有共享文件：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131712979.png" alt="image-20211213171253687" style="zoom:50%;" />



- 共享文件的情况：
  - 每个文件描述符都有它自己的当前文件位置，所以用不同文件描述符对同一个文件操作可以从文件的不同位置获取数据。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131719215.png" alt="image-20211213171905952" style="zoom:50%;" />

- 父子进程直接共享文件：
  - 子进程有父进程的文件描述符表，在内核删除相应的文件表表项之前必须父子进程都删掉对应的文件描述符。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131730942.png" alt="image-20211213173006765" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131730860.png" alt="image-20211213173035665" style="zoom:50%;" />

## 10.9 I/O重定向

I/O重定向如何工作？一种方式是使用`dup2()`函数。

```c
#include<unistd.h>
int dup2(int oldfd , int newfd );//成功则返回非负的描述符，失败返回-1。
```

- `dup2()`函数复制描述符表表项`oldfd`到描述符表表项`newfd`，覆盖文件描述符表表项`newfd`以前的内容。如果`newfd`此前对应的文件被打开，那么会先关闭那个文件，再覆盖。看图吧。
  - 注意一下文件表表项和v-node表项都被删除了。

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131801857.png" alt="image-20211213180135553" style="zoom: 50%;" />

## 10.10 标准I/O

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131808891.png" alt="image-20211213180852527" style="zoom:50%;" />

## 10.11  综合：我该使用哪些I/O函数？部分待补捏

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131828167.png" alt="image-20211213182813967" style="zoom: 50%;" />

- 关于使用I/O函数的基本原则：

<img src="https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202112131842715.png" alt="image-20211213184205312" style="zoom:50%;" />

- 还有一些其他基本限制目前看不太懂捏
