# OverView

```
浮点数不满足结合律
而整型由于范围有限，导致乘积溢出，正值变负值
```

![屏幕截图 2021-10-02 221755](D:\MarkDowns\Pictures Of Markdown\操作系统基础\屏幕截图 2021-10-02 221755.png)

# Part1

## Example Data Representations

| C Data Type | Typical 32-bit | Typical 64-bit |
| ----------- | -------------- | -------------- |
| **char**    | 1              | 1              |
| **short**   | 2              | 2              |
| **int**     | 4              | 4              |
| **long**    | 4              | 8              |
| **float**   | 4              | 4              |
| **double**  | 8              | 8              |
| pointer     | 4              | 8              |
|             | “ILP32”        | “LP64”         |

## Boolean Algebra

![屏幕截图 2021-10-03 132243](D:\MarkDowns\Pictures Of Markdown\操作系统基础\屏幕截图 2021-10-03 132243.png)

### Bit-Level Operations in C

这个是位级别的运算，不是C中的逻辑运算

**Operations &,  |,  ~,  ^ Available in C**

- 将参数看作位向量
- 适用于C中的任何“整型”，包括char
- 参数按位运算
- 注意与C的逻辑运算&&、|| 、!区分，这个是逻辑运算，上面的是位向量运算
- 确定一个位级表达式的结果的最好方法是将其他进制转换为二进制并执行二进制运算，然后再转换回十六进制

## Shift Operations 移位运算

### Left Shift: 	x << y

- x左移y位，丢弃最高的y位（也就是最左侧的y位），并在右端补上y个0
- 移位量y应该是一个0到w-1之间的值，w为操作数x的宽度
- 移位运算是从左向右结合的，也就是说x << y << z等价于(x << y) << z

3 << 2

首先把3转换为二进制数字**00**00 0000 0000 0000 0000 0000 0000 0011，然后把该数字**高位(最左侧)**的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12。

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。

### Right Shift: 	x >> y

- x右移y位
- 机器支持两种形式的右移：逻辑右移和算术右移

11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 10**11**，然后把低位的最后两个数字**11**移出，因为该数字是正数，所以在高位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。转换为十进制是2。

右移一位相当于除以2，右移n位相当于除以2的n次方。

#### 逻辑右移

逻辑右移在左端补y个0，丢弃操作数低位（最右侧）的y位，与左移恰好相反

#### 算术右移

- 算术右移在左端补y个最高有效位的值，丢弃操作数最右侧的y位
- 对有符号整数的运算很有用
- 最高位为0补0，为1补1

[01100011] 算术右移4位====》[00000110]，最高位为0

[10010101]算术右移4位====》[11111001]，最高位为1

- 几乎所有的编译器/机器都对有符号树使用算术右移，许多程序员也如此假设
- 对于无符号数，右移必须是逻辑右移

### Undefined Behavior

- Shift amount < 0 or ≥ word size

- 对于宽度为w的数据类型移动k（k >= w）位，许多机器计算位移量为k对w的余数

- 不过对于C来说这是未定义的行为，所以要保证位移量大于零小于宽度w

### 运算优先级问题

在C语言中，加减法的优先级是高于移位运算符的

1 << 2 + 3 << 4 等效于1 << (2+3) << 4，所以在拿捏不准的时候，加上括号 

## Integers

负数的范围比正数大一

### 无符号数的编码

- BInary to Unsigned==》B2U，宽度为w作为下标

- 对于宽度为w的无符号数，它的范围为0到2^w - 1 

- 介于这个范围内的每个数都有唯一的编码

### 补码(two‘ s -complement)

B2T ===》Binary to two ’ s complement，跨度w作为T的下标

- 在补码中将字的最高有效位定义为负权，最高有效位也称为符号位，值为 - 2 ^(w-1)

- 符号位为1时表示的是负数，为零时表示的是正值

- 补码的范围：正数最大为 2 ^ (w -1) -1 ，负数最小为 - 2^(w - 1)，正数比负数少一个

- 分别对应符号位为0，其他位为1，以及符号位为1，其他位为0

- 在表示的范围内补码编码也具有唯一性

- -1表示为全1串

### 有符号数和无符号数之间的转换

强制类型转换的结果保持位值不变，只是改变解释这些位的方式。

对于处理**相同字长**的有符号数和无符号数的相互转换，一般规则是:

- 数值可能会改变，但位模式不变

```c
//举例,下列转换过程中位值没变，而解释位的方式改变了
short v = -12345//-12345 == [1100111111000111];，有符号数，补码最高位为符号位
unsigned uv = (unsigned)v;//uv == 532191 == [1100111111000111]，无符号数，最高位不是符号位
```

有符号数（补码）到无符号数的转换:非负数不变而负数变成了大的正数

- 如果要转换的有符号数是正数或0，那么转换后的无符号数与有符号数相等
- 待转换的有符号数为负数，且其二进制为w位，其对应的无符号数等于有符号数加上2^w

无符号数到有符号数(补码)的转换：

- 待转换的无符号数小于有符号数能表示的最大正数时，其对应的有符号数不变
- 待转换的无符号数大于有符号数能表示的最大正数时，其对应的有符号数等于无符号数减去2^w

**当执行一个运算时，如果它的一个运算数是有符号数而另外一个是无符号数，那么C语言会隐式地将有符号数强制转换为无符号数，并且假设两个数都是非负的，来执行这个运算**

- 在标准算术运算中可能差异不大
- 在   <  和  >  这样的运算符中，会出现意料之外的结果

```c
//举例，假设在32位机器上
//比较有符号的-1和无符号的0：-1 < 	0U
//由于第二个参数0是无符号的，所以-1被隐式转换为无符号数
//而-1的32位补码对应的无符号数是（2^32 - 1）U ，远大于0U
//因此表达式等价于4294967295U < 0U
//表达式结果为false，与预期的true完全不符合
```

### 扩展一个数字的位表示

一种常见的运算是在不同字长的整数之间进行转换，同时又保持数值不变

- 从较小数据类型转换为较大数据类型是可能的

- 要将无符号数转换为一个更大的数据类型，只需要在表示的开头添加0，称为零扩展

- short转换为unsigned，先将short转换为int，再转换为unsigned

- 将补码（有符号数）扩展为一个更大的数据类型，如下图，正数补零，负数补1

  ![屏幕截图 2021-10-04 131404](D:\MarkDowns\Pictures Of Markdown\操作系统基础\屏幕截图 2021-10-04 131404.png)

### 截断数字

假设我们不用额外的位来扩展一个数值，而是想用更少的位来表示同一个数值

- 当我们想将w位的数截断为k位，保留的是权较小的k位
- 对于补码来说，还要将最高位转换为符号位

```c
int x = 53191;//将32位的int强制转换为16位的short，这个16位的表示就是-12345的补码
short sx = (short)x;//-12345
int y = sx;//-12345
```

# Part2

## 浮点数

浮点数表示对形如 x *  2^y 的数编码（这一点类似十进制的科学计数法，x的绝对值一般是小于2的）。对执行极大数字以及非常接近于0的数的以及作为实数运算的近似值的计算非常有用。

 

```
IEEE：读作I-triple-E，电器和电子工程师协会。浮点数的标准由其指定
```

### 二进制小数

- 类比十进制小数，二进制小数的每位的权，以小数点为分割线，左边各位的权为2的非负幂，小数点右边的数位的权为2的负幂。
- 同样类比十进制小数，二进制小数的小数点向左移动一位，相当于这个数除以2，向右移动一位则相当于这个数乘以2。
- 形如`(0.11111.....)`的**二进制小数**表示的是恰好小于1的数，实际上是`(2^n -1) / (2 ^ n)`。一般用`1.0 - ε`来表示这样的数
- 于十进制不能精确表示1 /3（3进制可以精确表示） 和 5 / 7这样的数，二进制小数也只能精确表示能被写成`x * 2^y`的数，其他值只能近似表示
- 1/5可以用十进制的0.2精确表示，而不能用二进制来精确表示，只能近似表示，且二进制表示的长度越长，值的精度越高

### IEEE浮点表示

前一节所提到的二进制小数表示法为定点表示法，但这样的表示法不能很有效的表示非常大的数字，如 5 * 2 ^100，是二进制的5(101)后面跟100个0。double类型没有这么多位。

IEEE浮点标准：`V = (-1) ^s * M * 2 ^ E`来表示一个数：

- 符号s（sign）决定这个数是整数（s = 0）还是负数（s = 1），对数值0的符号位解释作为特殊情况处理。
- 尾数（significand）M是一个二进制小数，其范围为1~2 - ε 或 0 ~ 1 - ε。
- 阶码（exponent）E的作用是对浮点数加权，权重为2的E次幂（E可能是负数）。 
- 一个单独的符号位直接编码符号s。
- 二进制k位的阶码（exp)字段编码阶码E。
- 二进制n位小数(frac)字段编码尾数M，编码出来的值也依赖于阶码字段的值是否为0。
- 由下图可以计算出float和double的（理论）上限值，都是符号位取0，其他位取1时最大
- 同样可以计算出最小值，符号位取1，其他位取1即可



![](D:\MarkDowns\Pictures Of Markdown\操作系统基础\IEEE_Float.jpg)



根据阶码的值，或者说阶码的二进制形式，被编码的值可以分成三种情况：

- 最普遍的情况，规格化的值。**exp的位模式不全为0，也不全为1**（float为255，double为2047）时都属于这种情况。这种情况下阶码被解释为以偏置形式表示的有符号数，也就是说阶码E的值实际上为E = e - Bias，e为阶码二进制形式对应的无符号数值，bias的值为2^(k -1) -1 ，k为阶码的位数，对float来说bias为127，double的bias则为1023。因此单精度浮点数的阶码范围为-126~127，double的阶码范围为-1022 ~ 1023，对float来说阶码为11111110时取阶码最大127，阶码为00000001时取最小阶码-126。而对于小数字段，小数点在小数字段f的最高有效位的左侧。尾数则定义为1加上小数字段的f。**也就是尾数M的实际上的值是二进制的**`1.f`这种方式也被称为隐含的以1开头（implied leading 1）的表示。因为我们总是可以通过调整阶码E来将尾数M调整为以1开头的二进制小数。所以位于开头的这个固定的1也就没必要显式的表示出来。
- 情况2，非规格化的值。exp的位模式为全0，E = 1 - Bias，**不是E = 0 - Bias**，而尾数M的值为M = f，也就是小数字段的值，**不包含隐含的开头的1**。非规格化数有两个用途，首先是提供了一种表示数值0的方法，因为规格化数我们必须使`M >= 1`，所以规格化数无法表示数值0。`+0.0`的浮点数表示的位模式是全零，符号位为零表明这是正的，阶码位为零表明这是一个非规格化的值，小数位为0使得M = f = 0。而当符号位为1，而其他位全为0时，我们得到的是浮点数的`-0.0`。正负的0.0在某些方面不同。非规格化数的另外一个功能是表示那些非常接近于0的数（因为阶码可以到-126/-1022，而小数部分由没有隐含0，尾数也小于1）。可能的数值分布均匀地接近0，具有逐渐溢出属性。
- 情况3，特殊值，当阶码全为1时。当小数域全为0而阶码全为1时，得到的值为无穷，符号位为0则为正无穷，符号位为1则为负无穷。当小数域不为0而阶码全为1，结果称为NaN(Not a Number)。

![Formats_Float](D:\MarkDowns\Pictures Of Markdown\操作系统基础\Formats_Float.jpg)

### 舍入

因为表示方法限制了浮点数的精度和范围，所以浮点运算只能近似地表示实数运算。因此对于一个值x，我们希望可以用一种系统的方法，来找到最接近x的匹配值X，X是可以用浮点数表示出来的值。这就是舍入运算的意义。例如考虑对1.5的舍入问题，是把它舍入为1还是2。IEEE浮点格式定义了4种不同的舍入方式，默认的是找到最接近的匹配，而其他三种用于计算上界和下界。

- 向偶数舍入，也称为向最接近的值舍入，是默认的方式。1.4舍入为1，而1.6舍入为2，因为他们是最接近的值。
- 对于介于两个可表示的值正中间的小数，如1.5，向偶数舍入采用向上或者向下舍入，使得舍入的结果最低有效数字是偶数，因此1.5和2.5都舍入为2
- 向偶数舍入的方法也可应用于不想舍入到整数的情况，只简单地考虑最低有效位是奇数还是偶数，对于二进制小数来说，最低有效位的值为0视作偶数

![Rounding_Float](D:\MarkDowns\Pictures Of Markdown\操作系统基础\Rounding_Float.jpg)

### 浮点运算

IEEE标准中指定浮点运算行为方法的一个优势在于，它可以独立于任何具体的硬件或软件实现。因此我们可以检查它的抽象数学属性，而不必考虑它实际上是如何实现的。

- 整数（包括无符号和补码）加法形成了阿贝尔群，实数上的加法也形成了阿贝尔群
- 但必须考虑舍入对这些属性的影响。
- 考虑舍入后的运算是可交换的，但是不是可结合的，例如`(3.14 + 1e10) - 1e10 = 0.0` 而`3.14 + (1e10 - 1e10) = 3.14`，前者因为舍入，3.14会丢失。
- 作为阿贝尔群，大多数值在浮点加法下都有逆元，x + -x = 0，而对于无穷和NaN来说例外。正无穷加负无穷得到NaN，任意x＋NaN得到NaN。
- 浮点加法不具有结合性，但是浮点加法满足单调属性，即任意a > b以及c，a + c > b + c，除了NaN。无符号或补码加法不具有单调属性（如a > 0 ，而a + a 可能由于溢出小于0） 。
- 由于舍入失去精度，发生溢出等问题，浮点加法不具有可结合性，3.14的例子，对于浮点乘法在加法上的分配律，也不满足。例如在单精度浮点下1e20  * (1e20 - 1e20) = 0，而1e20 * 1e20 -1e20 * 1e20 = NaN，因为溢出了。
- 但是浮点乘法满足若a >= b且c >= 0 ,则ac >= bc ，若a >= b且c <= 0 ,则ac <= bc ，并且只要不出现NaN，就有a * a >= 0，而无符号数或补码乘法没有（补码a > 0 ，由于溢出 a * a < 0）。

### C语言中的浮点数

![Floats_In_C](D:\MarkDowns\Pictures Of Markdown\操作系统基础\Floats_In_C.jpg)

