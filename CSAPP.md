# OverView

```
浮点数不满足结合律
而整型由于范围有限，导致乘积溢出，正值变负值
```

![屏幕截图 2021-10-02 221755](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-02%20221755.png)

# Part1

## Example Data Representations

| C Data Type | Typical 32-bit | Typical 64-bit |
| ----------- | -------------- | -------------- |
| **char**    | 1              | 1              |
| **short**   | 2              | 2              |
| **int**     | 4              | 4              |
| **long**    | 4              | 8              |
| **float**   | 4              | 4              |
| **double**  | 8              | 8              |
| pointer     | 4              | 8              |
|             | “ILP32”        | “LP64”         |

## Boolean Algebra

![屏幕截图 2021-10-03 132243](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-03%20132243.png)

### Bit-Level Operations in C

这个是位级别的运算，不是C中的逻辑运算

**Operations &,  |,  ~,  ^ Available in C**

- 将参数看作位向量
- 适用于C中的任何“整型”，包括char
- 参数按位运算
- 注意与C的逻辑运算&&、|| 、!区分，这个是逻辑运算，上面的是位向量运算
- 确定一个位级表达式的结果的最好方法是将其他进制转换为二进制并执行二进制运算，然后再转换回十六进制

## Shift Operations 移位运算

### Left Shift: 	x << y

- x左移y位，丢弃最高的y位（也就是最左侧的y位），并在右端补上y个0
- 移位量y应该是一个0到w-1之间的值，w为操作数x的宽度
- 移位运算是从左向右结合的，也就是说x << y << z等价于(x << y) << z

3 << 2

首先把3转换为二进制数字**00**00 0000 0000 0000 0000 0000 0000 0011，然后把该数字**高位(最左侧)**的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，则转换为十进制是12。

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。

### Right Shift: 	x >> y

- x右移y位
- 机器支持两种形式的右移：逻辑右移和算术右移

11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 10**11**，然后把低位的最后两个数字**11**移出，因为该数字是正数，所以在高位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。转换为十进制是2。

右移一位相当于除以2，右移n位相当于除以2的n次方。

#### 逻辑右移

逻辑右移在左端补y个0，丢弃操作数低位（最右侧）的y位，与左移恰好相反

#### 算术右移

- 算术右移在左端补y个最高有效位的值，丢弃操作数最右侧的y位
- 对有符号整数的运算很有用
- 最高位为0补0，为1补1

[01100011] 算术右移4位====》[00000110]，最高位为0

[10010101]算术右移4位====》[11111001]，最高位为1

- 几乎所有的编译器/机器都对有符号树使用算术右移，许多程序员也如此假设
- 对于无符号数，右移必须是逻辑右移

### Undefined Behavior

- Shift amount < 0 or ≥ word size

- 对于宽度为w的数据类型移动k（k >= w）位，许多机器计算位移量为k对w的余数

- 不过对于C来说这是未定义的行为，所以要保证位移量大于零小于宽度w

### 运算优先级问题

在C语言中，加减法的优先级是高于移位运算符的

1 << 2 + 3 << 4 等效于1 << (2+3) << 4，所以在拿捏不准的时候，加上括号 

## Integers

负数的范围比正数大一

### 无符号数的编码

- BInary to Unsigned==》B2U，宽度为w作为下标

- 对于宽度为w的无符号数，它的范围为0到2^w - 1 

- 介于这个范围内的每个数都有唯一的编码

### 补码(two‘ s -complement)

B2T ===》Binary to two ’ s complement，跨度w作为T的下标

- 在补码中将字的最高有效位定义为负权，最高有效位也称为符号位，值为 - 2 ^(w-1)

- 符号位为1时表示的是负数，为零时表示的是正值

- 补码的范围：正数最大为 2 ^ (w -1) -1 ，负数最小为 - 2^(w - 1)，正数比负数少一个

- 分别对应符号位为0，其他位为1，以及符号位为1，其他位为0

- 在表示的范围内补码编码也具有唯一性

- -1表示为全1串

### 有符号数和无符号数之间的转换

强制类型转换的结果保持位值不变，只是改变解释这些位的方式。

对于处理**相同字长**的有符号数和无符号数的相互转换，一般规则是:

- 数值可能会改变，但位模式不变

```c
//举例,下列转换过程中位值没变，而解释位的方式改变了
short v = -12345//-12345 == [1100111111000111];，有符号数，补码最高位为符号位
unsigned uv = (unsigned)v;//uv == 532191 == [1100111111000111]，无符号数，最高位不是符号位
```

有符号数（补码）到无符号数的转换:非负数不变而负数变成了大的正数

- 如果要转换的有符号数是正数或0，那么转换后的无符号数与有符号数相等
- 待转换的有符号数为负数，且其二进制为w位，其对应的无符号数等于有符号数加上2^w

无符号数到有符号数(补码)的转换：

- 待转换的无符号数小于有符号数能表示的最大正数时，其对应的有符号数不变
- 待转换的无符号数大于有符号数能表示的最大正数时，其对应的有符号数等于无符号数减去2^w

**当执行一个运算时，如果它的一个运算数是有符号数而另外一个是无符号数，那么C语言会隐式地将有符号数强制转换为无符号数，并且假设两个数都是非负的，来执行这个运算**

- 在标准算术运算中可能差异不大
- 在   <  和  >  这样的运算符中，会出现意料之外的结果

```c
//举例，假设在32位机器上
//比较有符号的-1和无符号的0：-1 < 	0U
//由于第二个参数0是无符号的，所以-1被隐式转换为无符号数
//而-1的32位补码对应的无符号数是（2^32 - 1）U ，远大于0U
//因此表达式等价于4294967295U < 0U
//表达式结果为false，与预期的true完全不符合
```

### 扩展一个数字的位表示

一种常见的运算是在不同字长的整数之间进行转换，同时又保持数值不变

- 从较小数据类型转换为较大数据类型是可能的

- 要将无符号数转换为一个更大的数据类型，只需要在表示的开头添加0，称为零扩展

- short转换为unsigned，先将short转换为int，再转换为unsigned

- 将补码（有符号数）扩展为一个更大的数据类型，如下图，正数补零，负数补1

  ![屏幕截图 2021-10-04 131404](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-10-04%20131404.png)

### 截断数字

假设我们不用额外的位来扩展一个数值，而是想用更少的位来表示同一个数值

- 当我们想将w位的数截断为k位，保留的是权较小的k位
- 对于补码来说，还要将最高位转换为符号位

```c
int x = 53191;//将32位的int强制转换为16位的short，这个16位的表示就是-12345的补码
short sx = (short)x;//-12345
int y = sx;//-12345
```

## 浮点数

浮点数表示对形如 x *  2^y 的数编码（这一点类似十进制的科学计数法，x的绝对值一般是小于2的）。对执行极大数字以及非常接近于0的数的以及作为实数运算的近似值的计算非常有用。

 

```
IEEE：读作I-triple-E，电器和电子工程师协会。浮点数的标准由其指定
```

### 二进制小数

- 类比十进制小数，二进制小数的每位的权，以小数点为分割线，左边各位的权为2的非负幂，小数点右边的数位的权为2的负幂。
- 同样类比十进制小数，二进制小数的小数点向左移动一位，相当于这个数除以2，向右移动一位则相当于这个数乘以2。
- 形如`(0.11111.....)`的**二进制小数**表示的是恰好小于1的数，实际上是`(2^n -1) / (2 ^ n)`。一般用`1.0 - ε`来表示这样的数
- 于十进制不能精确表示1 /3（3进制可以精确表示） 和 5 / 7这样的数，二进制小数也只能精确表示能被写成`x * 2^y`的数，其他值只能近似表示
- 1/5可以用十进制的0.2精确表示，而不能用二进制来精确表示，只能近似表示，且二进制表示的长度越长，值的精度越高

### IEEE浮点表示

前一节所提到的二进制小数表示法为定点表示法，但这样的表示法不能很有效的表示非常大的数字，如 5 * 2 ^100，是二进制的5(101)后面跟100个0。double类型没有这么多位。

IEEE浮点标准：`V = (-1) ^s * M * 2 ^ E`来表示一个数：

- 符号s（sign）决定这个数是整数（s = 0）还是负数（s = 1），对数值0的符号位解释作为特殊情况处理。
- 尾数（significand）M是一个二进制小数，其范围为1~2 - ε 或 0 ~ 1 - ε。
- 阶码（exponent）E的作用是对浮点数加权，权重为2的E次幂（E可能是负数）。 
- 一个单独的符号位直接编码符号s。
- 二进制k位的阶码（exp)字段编码阶码E。
- 二进制n位小数(frac)字段编码尾数M，编码出来的值也依赖于阶码字段的值是否为0。
- 由下图可以计算出float和double的（理论）上限值，都是符号位取0，其他位取1时最大
- 同样可以计算出最小值，符号位取1，其他位取1即可



![](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/IEEE_Float.jpg)



根据阶码的值，或者说阶码的二进制形式，被编码的值可以分成三种情况：

- 最普遍的情况，规格化的值。**exp的位模式不全为0，也不全为1**（float为255，double为2047）时都属于这种情况。这种情况下阶码被解释为以偏置形式表示的有符号数，也就是说阶码E的值实际上为E = e - Bias，e为阶码二进制形式对应的无符号数值，bias的值为2^(k -1) -1 ，k为阶码的位数，对float来说bias为127，double的bias则为1023。因此单精度浮点数的阶码范围为-126~127，double的阶码范围为-1022 ~ 1023，对float来说阶码为11111110时取阶码最大127，阶码为00000001时取最小阶码-126。而对于小数字段，小数点在小数字段f的最高有效位的左侧。尾数则定义为1加上小数字段的f。**也就是尾数M的实际上的值是二进制的**`1.f`这种方式也被称为隐含的以1开头（implied leading 1）的表示。因为我们总是可以通过调整阶码E来将尾数M调整为以1开头的二进制小数。所以位于开头的这个固定的1也就没必要显式的表示出来。
- 情况2，非规格化的值。exp的位模式为全0，E = 1 - Bias，**不是E = 0 - Bias**，而尾数M的值为M = f，也就是小数字段的值，**不包含隐含的开头的1**。非规格化数有两个用途，首先是提供了一种表示数值0的方法，因为规格化数我们必须使`M >= 1`，所以规格化数无法表示数值0。`+0.0`的浮点数表示的位模式是全零，符号位为零表明这是正的，阶码位为零表明这是一个非规格化的值，小数位为0使得M = f = 0。而当符号位为1，而其他位全为0时，我们得到的是浮点数的`-0.0`。正负的0.0在某些方面不同。非规格化数的另外一个功能是表示那些非常接近于0的数（因为阶码可以到-126/-1022，而小数部分由没有隐含0，尾数也小于1）。可能的数值分布均匀地接近0，具有逐渐溢出属性。
- 情况3，特殊值，当阶码全为1时。当小数域全为0而阶码全为1时，得到的值为无穷，符号位为0则为正无穷，符号位为1则为负无穷。当小数域不为0而阶码全为1，结果称为NaN(Not a Number)。

![Formats_Float](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Formats_Float.jpg)

### 舍入

因为表示方法限制了浮点数的精度和范围，所以浮点运算只能近似地表示实数运算。因此对于一个值x，我们希望可以用一种系统的方法，来找到最接近x的匹配值X，X是可以用浮点数表示出来的值。这就是舍入运算的意义。例如考虑对1.5的舍入问题，是把它舍入为1还是2。IEEE浮点格式定义了4种不同的舍入方式，默认的是找到最接近的匹配，而其他三种用于计算上界和下界。

- 向偶数舍入，也称为向最接近的值舍入，是默认的方式。1.4舍入为1，而1.6舍入为2，因为他们是最接近的值。
- 对于介于两个可表示的值正中间的小数，如1.5，向偶数舍入采用向上或者向下舍入，使得舍入的结果最低有效数字是偶数，因此1.5和2.5都舍入为2
- 向偶数舍入的方法也可应用于不想舍入到整数的情况，只简单地考虑最低有效位是奇数还是偶数，对于二进制小数来说，最低有效位的值为0视作偶数

![Rounding_Float](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Rounding_Float.jpg)

### 浮点运算

IEEE标准中指定浮点运算行为方法的一个优势在于，它可以独立于任何具体的硬件或软件实现。因此我们可以检查它的抽象数学属性，而不必考虑它实际上是如何实现的。

- 整数（包括无符号和补码）加法形成了阿贝尔群，实数上的加法也形成了阿贝尔群
- 但必须考虑舍入对这些属性的影响。
- 考虑舍入后的运算是可交换的，但是不是可结合的，例如`(3.14 + 1e10) - 1e10 = 0.0` 而`3.14 + (1e10 - 1e10) = 3.14`，前者因为舍入，3.14会丢失。
- 作为阿贝尔群，大多数值在浮点加法下都有逆元，x + -x = 0，而对于无穷和NaN来说例外。正无穷加负无穷得到NaN，任意x＋NaN得到NaN。
- 浮点加法不具有结合性，但是浮点加法满足单调属性，即任意a > b以及c，a + c > b + c，除了NaN。无符号或补码加法不具有单调属性（如a > 0 ，而a + a 可能由于溢出小于0） 。
- 由于舍入失去精度，发生溢出等问题，浮点加法不具有可结合性，3.14的例子，对于浮点乘法在加法上的分配律，也不满足。例如在单精度浮点下1e20  * (1e20 - 1e20) = 0，而1e20 * 1e20 -1e20 * 1e20 = NaN，因为溢出了。
- 但是浮点乘法满足若a >= b且c >= 0 ,则ac >= bc ，若a >= b且c <= 0 ,则ac <= bc ，并且只要不出现NaN，就有a * a >= 0，而无符号数或补码乘法没有（补码a > 0 ，由于溢出 a * a < 0）。

### C语言中的浮点数

![Floats_In_C](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Floats_In_C.jpg)

# 程序的机器级表示

## 3.2程序编码

```c
gcc -Og -o p p1.c p2.c
//-Og告诉编译器生成符合原始C代码整体结构的机器级代码
```

**gcc调用一系列程序将源代码转为可执行代码的过程：**以上述命令为例

- 1.C预处理器扩展源代码，插入所有用`#include`命令指定的文件，并扩展所有用`#define`命令指定的宏
- 2.`编译器`产生多个源文件的汇编代码，名字分别为`p1.s`和`p2.s`。
- 3.`汇编器`将汇编代码转换成二进制`目标代码`文件`p1.o`和`p2.o`。
- 4.`链接器`将两个目标代码文件与实现库函数(如printf)的代码合并，并产生最终的可执行代码文件p。
- 目标代码是机器代码的一种形式，包含所有指令的二进制表示，但还没有填入全局值的地址。
- 可执行代码是机器代码的第二种形式，也就是处理器执行的代码格式

### 3.2.1机器级代码

对机器级编程即为重要的两种抽象：

- 1.由指令集架构(ISA，Instruction Set Architecture)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响
- 2.机器级程序使用的内存地址是虚拟地址，提供的内存模型像一个非常大的字节数组。

大多数ISA将程序的行为描述为好像每条指令都是按顺序执行的，一条指令结束后下一条再开始，但实际上处理器的硬件远比描述的复杂精细，它们并发的执行许多指令，并采取一定手段使得整体行为与ISA指定的顺序执行的行为完全一致。

**一些处理器状态：**

- 程序计数器，`PC`，在x86-64中用%rip表示，给出将要执行的下一条指令在内存中的地址。
- 整数`寄存器文件`，包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保存临时数据，例如过程中的参数和局部变量，以及函数返回值。

```c
寄存器文件（register file）又称寄存器堆，是CPU中多个寄存器组成的阵列，通常由快速的静态随机读写存储器（SRAM）实现。这种RAM具有专门的读端口与写端口，可以多路并发访问不同的寄存器。
```

- 条件码寄存器（状态寄存器）保存着最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化，如if或while。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。

虽然C语言提供的模型使得我们可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。C语言中的聚合数据类型如数组和结构，在机器代码中用一组连续的字节来表示。

即使对标量数据类型，汇编代码也不区分有符号和无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。

**程序的内存包含：**

- 程序的可执行机器代码
- 操作系统需要的一些信息，用来管理过程调用和返回的运行时栈
- 用户分配(比如malloc分配的)的内存块

程序用虚拟地址寻址，在任意给定时刻，**只有有限的一部分虚拟地址被认为是合法的，x86-64的虚拟地址是由64位的字来表示的，在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的内存是64TB范围内的一个字节。**操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

### 3.2.2代码示例

```c
//mstore.c
long mult2(long ,long);
void multstore(long x,long y,long* dest) {
    long t = mult2(x,y);
    *dest = t;
}
```

 在命令行使用`-S`选项，能看到编译器产生的汇编代码

```c
gcc -Og -S mstore.c
```

上述命令会使gcc运行编译器产生一个汇编文件`mstore.s`，但不做进一步工作（一般情况下gcc会继续调用汇编器产生目标代码文件）。

汇编代码文件如下：

```
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq 	%rax, (%rbx)
	popq	%rbx
	ret
```

每一行缩进的行都对应于一条机器指令。这段代码中已**除去了所有关于局部变量的名字或数据类型的信息。**

使用`-c`命令行选项，gcc会编译并汇编该代码

```
gcc -Og -c mstore.c
```

上述命令生成一个名为mstore.o的二进制目标代码文件。

- 机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

要查看机器代码文件的内容，使用反汇编器。

- 反汇编器根据机器代码产生类似汇编代码的格式。
- Linux中`objdump -d`充当了这个角色。

```c
objdump -d mstore.o
```

结果如下：

![objdump](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/objdump.jpg)

对应的目标文件中的序列是：

```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```

左边是上一行的十六进制字节值，一个数字一个字节，被分成若干组，每组都是一条指令，右边是等价的汇编语言。

关于机器代码及其反汇编表示的特性：

- x86-64的指令长度从1字节到15字节不等。常用的指令以及操作数较少的指令所需字节数少，不太常用的或操作数较多的指令所需字节数较多
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码为机器指令。如只有指令pushq %rbx是以字节值53开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与gcc生成汇编代码使用的有细微差别。在示例中反汇编器省略了许多指令结尾的`'q'`。这些后缀是大小指示符，大多数情况下可以省略，反汇编器还给`ret`和`call`指令添加了后缀`‘q’`，同样的省略也没问题。

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个`main`函数。

```c
//main.c
#include<stdio.h>
void mulstore(long , long , long*);
int main(void) {
    long d;
    mulstore(2,3,&d);
    printf("2 * 3 --> %ld\n",d);
    return 0;
}
long mult2(long a,long b) {
    long s = a * b;
    return s;
}
```

然后使用如下命令行生成可执行文件prog：

```
gcc -Og -o prog main.c mstore.c
```

文件prog不仅包含了两个源文件的代码，还包含了用来启动和终止程序的代码，以及用来和操作系统交互的代码。

同样可以反汇编prog：

```
objdump -d prog
```

![main](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/main.jpg)

### 3.2.3

![3.2.3_1](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/3.2.3_1.jpg)

- 以`'.'`开头的行都是指导汇编器和链接器工作的伪指令。忽略即可。



![](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/3.3.3_2.jpg)

## 3.3数据格式

- 由于是从16位体系结构扩展成32位的，Intel用术语`“字（word)”`表示16位数据类型。
- 因此32位数据称为`双字(double words)`，64位数为`四字（quad words)`。
- 标准int存储为双字，指针存储为8字节的4字，表格中用char*代指指针。

| C声明       | Intel数据类型       | 汇编代码后缀 | 大小（字节） |
| ----------- | ------------------- | ------------ | ------------ |
| char        | 字节（8位为一字节） | b            | 1            |
| short       | 字（16位为1字）     | w            | 2            |
| int         | 双字                | l            | 4            |
| long        | 四字                | q            | 8            |
| char*(指针) | 四字                | q            | 8            |
| float       | 单精度              | s            | 4            |
| double      | 双精度              | l            | 8            |

- 大多数gcc生成的汇编代码指令都有一个字符后缀，表明操作数的大小
- 例如数据传送指令`mov`有4个变种：`movb(传送字节)`、`movw(传送字)`、`movl(传送双字)`、`movq(传送4字)`。
- 后缀`l`表示双字(long word)
- 汇编代码也使用后缀`l`来表示4字节整数和8字节双精度浮点数，但是不会产生歧义，因为浮点数使用另一组完全不同的指令和寄存器

## 3.4访问信息

一个x86-64的CPU包含一组16个存储64位值的`通用目的寄存器`，这些寄存器用来存储整数数据和指针。

![registers](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/registers.jpg)

**指令可以对这16个寄存器的低位字节中存放的不同字节大小的数据进行操作：**

- 字节级操作可以访问最低的字节
- 16位操作可以访问最低的两个字节
- 32位操作可以访问最低的四个字节
- 64位操作则可以访问整个寄存器

当指令以寄存器作为目标时，对于生成小于8字节数据的指令，寄存器中剩下的字节会怎样有如下两条规则：

- 生成1字节和2字节数字的指令会保持剩下的字节不变
- 生成4字节数字的指令会把高位的4个字节置为0

### 3.4.1操作数指示符

大多数指令都有一个或多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此各种不同的操作数的可能性被分为三种类型。

- 第一种，立即数(immediate)，用来表示常数值，在ATT格式的汇编代码中立即数的书写方式是`‘$’`后面跟一个标准C表示法的整数，如$-577或$0x1F。不同指令允许的立即数的范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
- 第二种，寄存器。它表示某个寄存器的内容，16个寄存器的低位1(8位)/2(16位)/4(32位)/8(64位)字节中的一个作为操作数。
- 第三种，内存引用。它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。
- 寻址模式：

![寻址模式](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F.jpg)

### 3.4.2数据传送指令

最简单的数据传送指令，MOV类，把数据从源位置复制到目的位置。MOV类的四条指令执行的操作相同，只是操作的数据大小不同。

| 指令                  | 效果     | 描述                    |
| --------------------- | -------- | ----------------------- |
| MOV              S，D | S ---》D | 传送                    |
| movb                  |          | 传送字节                |
| movw                  |          | 传送字（2字节）         |
| movl                  |          | 传送双字（长字，4字节） |
| movq                  |          | 传送四字（8字节）       |
| movabsq      I，R     | I ---》R | 传送绝对的4字           |

- 源操作数指定的值是一个立即数，存储在寄存器中或内存中
- 目的操作数指定一个位置，要么是一个寄存器要么是一个内存位置
- x86-64的一条限制：**传送指令的两个操作数不能都指向内存位置**
- 将一个值从一个内存位置复制到另外一个内存位置需要两条指令：第一条指令将源值加载入寄存器中，第二条将寄存器中的值写入目的位置
- 这些指令的寄存器操作数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（b、w、l、q）指定的大小匹配
- 大多数情况下MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。
- 唯一与上述例外的是，`movl`指令以寄存器为目的时，会把寄存器的高位四字节设置为0。
- 造成例外的是x86-64的惯例——任何为寄存器生成32位值的指令都会把该寄存器的高位4字节设置为0
- 传送绝对4字的指令是用于处理64位立即数数据的，常规的`movq`指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。`movabsq`能以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

![数据传送源和目的的组合](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%BA%90%E5%92%8C%E7%9B%AE%E7%9A%84%E7%9A%84%E7%BB%84%E5%90%88.jpg)

第二类和第三类，MOVZ和MOVS指令类，在将较小的源值复制到较大的目的时使用。**所有的这些指令都把寄存器从源（寄存器或内存中）复制到目的寄存器**。MOVZ类中的指令把目的中剩余的字节填充为0，MOVS类中的指令通过符号扩展填充，把源的最高位进行复制。**每条指令名字的最后两个字符都是大小指示符，第一个字符指定源的大小，第二个指明目的的大小**。

![MOVZ&MOVS](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/MOVZ%2526MOVS.jpg)

### 3.4.3数据传输示例

![数据传输shili](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93shili.jpg)

- 间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。
- 像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存快得多。

### 3.4.4压入和弹出栈数据

- 在x86-64中，程序栈存放在内存中的某个区域。弹出的值永远是最近被压入而且仍在栈中的元素。
- 栈向下增长，栈顶元素的地址是所有栈元素地址中最低的。（惯例上栈是倒过来画的，栈顶在图的底部）
- 栈指针`%rsp`保存着栈顶元素的地址
- 将一个4字(64位，8字节)数据压入栈，首先要将栈指针的值减8，然后再将数据写入新的栈顶地址
- 将8字节数据弹出栈，则先将8字节的值复制到目标位置（先从栈顶位置读取数据），然后栈指针的值加8

![压入和弹出栈数据](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE.jpg)

- 下图是一个压栈和弹出栈的实例，其中寄存器`%rdx`用来保存弹出栈的数据，`%rax`则用来保存用于压入栈的数据
- 按照惯例栈顶在图的底部，并且栈顶的地址随着压栈是逐渐减小的

![压栈弹出栈实例](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%8E%8B%E6%A0%88%E5%BC%B9%E5%87%BA%E6%A0%88%E5%AE%9E%E4%BE%8B.jpg)

## 3.5算术和逻辑操作

- 大多数操作都被分成了指令类，这些指令类有各种不同大小的操作数
- 这些操作被分为四组：加载有效地址、一元操作、二元操作、移位。

![算术和逻辑操作](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.jpg)

### 3.5.1加载有效地址

- lea，load effective address
- `leaq`实际上是`movq`的变种，它的指令形式是从内存读取数据到寄存器。
- 但实际上它并没有引用内存，而是将有效地址写入寄存器。
- 还可以简洁的描述普通的算术操作
- 能执行加法和有限形式的乘法。

![leaq](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/leaq.jpg)

### 3.5.2一元操作和二元操作

- 一元操作只有一个操作数，这个操作数既是源又是目的。
- 这个操作数可以是一个寄存器，也可以是一个内存位置
- 二元操作有两个运算符，其中第二个操作数既是源又是目的
- 源操作数是第一个，目的操作数是第二个
- 如 `sub %rax,%rdx`，从寄存器`%rdx`减去`%rax`的值
- 第一个操作数可以是立即数，寄存器，内存位置
- 第二个操作数可以是寄存器或内存位置。
- 当第二个操作数为内存地址时，处理器必须从内存读出值，进行操作，再把结果写回内存。

### 3.5.3移位操作

- 先给出移位量，第二项再给出要移位的数
- 可以进行算术右移和逻辑右移
- 移位量可以是一个立即数，或者放在**单字节寄存器**`%cl`中。
- 只允许以单字节寄存器作为操作数。理论上来说一个字节的移位量可以到达255。但实际不需要这么多，毕竟最长的数据也才64位。
- **x86-64中，移位操作对w位长的数据值进行操作，移位量由%cl寄存器的低m位决定，其中2^m = w。高位会被忽略。**

```c
/**举个例子说明*/
当%cl的值为0xFF(11111111)
对于salb，对8位的操作数移位，最多移7(也就是111，低三位)位
这样也解释了为什么由%cl寄存器的前低m位决定，因为这样最多移位的位数(2^m - 1,也即w - 1)恰好比操作数的位数(w)少一位。
```

- 左移指令有两个名字：`SAL`和`SHL`，二者效果相同，都是左移，右边填上0。
- 右移指令，`SAR`执行算术右移(填充符号位)，`SHR`执行逻辑右移(填充0)

- SAL(shift arithmetic left) 算术左移，SHL(shift logical left) 逻辑左移
- SAR(shift arithmetic right) 算术右移

### 3.5.4讨论

- 大多数算术和逻辑指令，即可用于无符号运算，也可用于补码运算。
- 只有右移操作需要区分有符号数和无符号数。
- 通常编译器产生的代码中会用一个寄存器先后存放多个程序值，还会在寄存器间传送值。

### 3.5.5特殊的算术操作



- 两个64位的数相乘的乘积需要128位来表示
- x86-64指令集对128位提供的支持有限
- 16字节的数据称为8字(oct Word，8个字，128位，字是2字节)
- 一对寄存器组成一个128位8字。
- `imulq`有两种不同的形式，一种是之前图`3-10`给出的两个操作数的指令形式。从两个64位操作数产生一个64位的乘积
- 对于上述形式的来说，当将乘积截取到低64位时，无符号和补码的结果是一样的。

![128位运算](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/128%E4%BD%8D%E8%BF%90%E7%AE%97.jpg)

- `imulq`的另外一种形式是“单操作数"乘法指令形式，`mulq`也是单操作数指令。
- `mulq`和`imulq`**在做128位结果的乘法时都要求乘法的一个参数必须放在寄存器**`%rax`**中**，另一个作为指令的源操作数给出。
- 最终两个64位数的乘积存放在寄存器`%rdx`(高64位)和寄存器`%rax`(低64位)中。
- 编译器可以通过计算操作数的数目来确定`imulq`究竟是哪一种形式，是普通的乘法还是128位的。
- 除法和取模运算都由单操作数除法指令来提供。
- 有符号除法`idivl`将寄存器`%rax`(低64位)和寄存器`%rdx`(高64位)中的128位作为被除数，除数则作为指令的操作数给出。
- 除法运算结果的商保存在寄存器`%rax`，余数则保存在寄存器`%rdx`中。
- 对于大多数64位的除法来说，除数也常常是64位的值。这个值存放在`%rax`中，`%rdx`则全部用其符号位填充(补码运算），无符号运算则全部填充0。在`%rdx`中填充符号位或者0的操作由指令`clto`完成。
- `clto`指令不需要操作数，它隐式读出`%rax`的符号位并将符号位复制到`%rdx`的所有位。

## 3.6控制

目前为止我们只考虑了直线代码的行为，也就是指令一条接着一条顺序地执行。而C语言中诸如条件语句，循环语句和分支语句，要求有条件地执行，根据数据测试的结果来决定执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变程序控制流或者数据流。

与数据相关的控制流是实现有条件行为的更一般和常见的方法。通常C语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序顺序执行。用`jump`指令可以改变一组机器代码指令的执行顺序，`jump`指令指定控制应该被传递到程序的某个其他部分。编译器必须产生构建在这种低级机制的基础之上的指令序列来实现C语言的控制结构。

### 3.6.1条件码

- 除了整数寄存器，CPU还维护着**一组**单个位的`条件码寄存器`，它们描述了最近的算术或逻辑操作的属性。个人也叫它状态寄存器。
- 可以检测这些寄存器来执行条件分支指令。
- 最常用的条件码：
- CF： Carry Flag，进位标志。最近的操作使得最高位产生了进位。可用来检查无符号操作的溢出。
- ZF： Zero Flag，零标志。最近的操作得出的结果为0。
- SF： Sign Flag，符号标志。最近操作得到的结果为负数。
- OF： Overflow Flag，溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

![Condition Flag](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/Condition%20Flag.jpg)

- `leaq`不改变任何条件码，因为它是用于地址计算的。
- 除`leaq`之外，图3-10中列出的所有指令都会设置条件码。（加一、减一、按位运算、四则运算、移位、取补取负）
- 对于逻辑操作，进位标志和溢出标志会被置为0。
- 对于移位操作，进位标志将会设置为最后一个被移出的位，而溢出标志设置为0。（什么叫最后一个被移出的位。。）
- `INC`和`DEC`指令会设置溢出和零标志，但不会改变进位标志。
- 除了上述提到的指令以外，还有两类指令会设置条件码。它们只设置条件码而不改变任何其他寄存器。
- 除了只设置条件码而更新目的寄存器，`CMP`指令与`SUB`指令的行为是一样的。
- `TEST`指令与`AND`指令行为一样，除了它们只设置条件码而不改变目标寄存器。

![TEST_CMP](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/TEST_CMP.jpg)

### 3.6.2访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

- 根据条件码的某种组合，将一个字节设置为0或者1
- 条件跳转到程序的某个其他的部分
- 有条件地传送数据

对于第一种情况，实现这一类操作的指令叫`SET`指令：

![SET](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/SET.jpg)

- 这一整类`SET`指令之间的区别就在于它们考虑的条件码的组合是什么。
- 指令名字的不同后缀表明了它们所考虑的条件码的组合。
- e：equal、ne：not equal、s：signed？g：greater、ge：greater or equal 、l：less、le：less or equal
- a：above、ae：above or equal、b：below、be：below or equal
- sete：set when equal ，相等时设置，setb：set when below，低于时设置
- 不同后缀表示的不是操作数的大小，而是不同的条件组合。
- **一条`SET`指令的目的操作数是低位单字节寄存器元素之一（图3-2），或者是一个字节的内存位置，指令会将这个字节设置为0或1，为了得到一个32位或64位的结构，我们必须对高位清零**
- 举个比较long a 和long b大小的例子：

![example_CMP](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/example_CMP.jpg)

- 注意第二行汇编代码，比较的时候是从右往左比
- 关于`movzbl`指令参考`图3-5`，MOVZ类是零扩展的数据传送
- 某些底层机器指令可能有多个名字，称为同义名，例如greater 与not less or equal逻辑等价（setg == setnotle）。
- 编译器和反汇编器会随意决定使用哪个名字。
- 虽然所有的算术和逻辑操作都会设置条件码，但是各个`SET`命令的描述都适用的情况是：执行比较指令，根据t = a - b设置条件码。
- 还有一部分因为部分符号原因看不懂 待补：

![待补全部分](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E5%BE%85%E8%A1%A5%E5%85%A8%E9%83%A8%E5%88%86.jpg)

### 3.6.3跳转指令

正常执行情况下指令按照它们出现的顺序一条条地执行。跳转`jump`指令会导致执行切换到程序中一个全新的位置。

- 在汇编代码中，这些跳转的目的地通常会用一个标号(`label`)指明。

![jump_example](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/jump_example.jpg)

- Null pointer dereference：空指针解引用，`jump .L1`指令使得这条指令被跳过了。
- 在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标(目的指令的地址)编码为跳转指令的一部分。

![jump instruction set](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/jump%20instruction%20set.jpg)

- `jmp`是无条件跳转，它可以是**直接跳转**，也可以是**间接跳转**
- 直接跳转：跳转目标作为指令的一部分编码的
- 间接跳转：跳转目标是从寄存器或内存位置中读出的。
- 汇编语言中，直接跳转给出一个标号（label）作为跳转目标，如`".L1"`。
- 间接跳转的写法是`'*'`后面跟一个操作数指示符。
- `jmp *%rax`以寄存器中的值作为跳转目标，`jmp *(%rax)`以寄存器`%rax`中的值作为地址，从内存中读出跳转目标。
- 表中其他跳转指令都是有条件的——它们根据条件码的某种组合，决定是跳转，还是继续执行代码序列中的下一条指令
- 跳转指令同样有同义名，与`SET`集类似。
- **条件跳转只能是直接跳转，也就是说条件跳转必须直接给出一个label**

### 3.6.4跳转指令的编码

虽然我们不关系机器代码的格式细节，但理解跳转指令的目标如何编码，对理解程序的链接非常重要。同样对理解反汇编器的输出很重要。

- 在汇编代码中，跳转目标用符号标号书写。汇编器以及后来的链接器会产生跳转目标的适当编码。
- 跳转指令有几种不同的编码，但最常用的都是PC相对的（PC-relative）。
- PC相对：将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码（所以PC应该是程序计数器而不是个人电脑）
- PC的值就是下一条将要执行的指令的地址，而紧跟在跳转指令后面那条指令的地址，就是PC保存的地址。
- 第二种编码方法是给出“绝对”地址，用4个字节直接指定目标。（为什么不是64位？）
- 汇编器和链接器会选择适当的跳转目的编码。
- 一个PC相对寻址的例子：

![PCEncodingexample](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/PCEncodingexample.jpg)

```c
/*个人关于反汇编文件的解析*/
//最左边的数字是行号
//次左边的0 3 5等是偏移量，同样也是每一行汇编出来的指令的地址
//原目标代码.o文件对应这个汇编命令序列的代码是：
//48 89 f8;eb 03;48 d1 f8; 48 85 c0; 7f f8;f3 c3，分号分段，十六进制，补码
```

- 反汇编器以16进制给出所有的数字
- 相对PC编码时，目标指令的地址等于PC的值加上编码（编码也就是差）。
- 字节序列都是十六进制的补码，单个数字相当于二进制4位，一个数刚好8位（一个字节），也就是一个字节。
- 执行到第2行的无条件跳转指令时，`eb 03`，(0x)03为目标指令的编码，相对跳转指令的下一条指令，也即PC目前的值，为第三行的地址0x05，二者相加结果为0x08，恰好为跳转目标的地址。
- 同样的分析第5行的有条件跳转，跳转目标的编码为补码的0xf8(十进制-8)，相对第5行的下一条指令的地址为0x0d(十进制13)，二者相加恰好为十进制的5，也是16进制的0x05，恰好为跳转目标的地址。
- 当执行PC相对寻址时，程序计数器的值是跳转指令的下一条指令的地址，而不是跳转指令本身的地址。与早期实现有关。 

![链接后的反汇编](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E9%93%BE%E6%8E%A5%E5%90%8E%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96.jpg)

### 3.6.5用条件控制来实现条件分支

将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

- 下列程序增加了两个用来计数的变量，分别记录两种分支情况出现的次数
- goto版本模拟的是汇编的条件分支

![条件分支](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF.jpg)

- 懒得写了，看图就好，关于如何利用跳转指令实现条件分支

![跳转指令实现条件分支](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF.jpg)

### 3.6.6用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，条件不满足时则走另外一条路径，这种机制在现代处理器上可能会非常低效。

- 替代策略是使用数据的条件转移。计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。只有在一些受限制的情况下有效。但是如果可行就可以用一条简单的条件传送指令来实现它。
- 条件传送指令更符合现代处理器的性能特性。
- 一个示例程序，b）是汇编代码的模拟

![条件传送实现条件分支](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E6%9D%A1%E4%BB%B6%E4%BC%A0%E9%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF.jpg)

- 先都计算了rval = y -x 和eval = x - y，再测试跳转条件，再确定返回哪个。

- 关于分支预测，由于现在知识有限，以后待补

### 3.6.7循环

C语言提供的循环语句在汇编中都没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。

- gcc和其他汇编器产生的循环代码主要基于两种基本的循环模式。

- 1.`do-while`循环

```c
/*通用形式如下：*/
do
    body-statement
    while(test-expr);//body-statement至少会执行一次
/*可以被翻译成如下的条件和goto语句*/
loop:
	body-statement
	t = test-expr;
	if(t)
        goto loop;
```

- 同样举个例子，用循环求阶乘，goto版本模拟汇编版本的行为。

![dowhile](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/dowhile.jpg)

- `%rax`用来存放返回值，所以很容易确定result存在`%rax`中。
- 逆向过程反汇编出来的汇编代码，需要确定哪个寄存器对应哪个程序值。

- 关于对汇编代码使用逆向工程：

 ![逆向工程](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B.jpg)

- 2.`while`循环
- 有很多种方法将while循环翻译成机器代码，gcc使用其中两种。这两种方法循环结构相同，实现初始测试的方法不同。
- 第一种：跳转到中间
- 第二种：guarded-do

```c
/*while通用形式如下：*/
while(test - expre) 
    bodyStatement;
/*与do-while不同，在第一次执行bodyStatement之前会先对test-expr求值*/
/*第一种翻译方法：跳转到中间（jump to middle）,先执行一个无条件跳转到循环结尾处的测试以实现初始的测试*/
goto test;
loop:
	body-statement;
test:
	t = test-expr;
if(t){
    goto loop;
}
```

```c
/*第二种：guarded-do，首先使用条件分支，如果初始条件不成立就跳过循环，把代码变成do-while循环*/
/*使用较高的优化等级编译时gcc会采取这种策略*/
//模板:
t = test-expre;
if(!t){
    goto done;
}
do:
	body-statement;
	while(t);
done:
/*机器级*/
t = test-expr;
if(!t) {
    goto done;
}
loop:
	body-statement;
	t = test-expr;
	if(t) {
        goto loop;
    }
done:
```

 3.for循环

- gcc为for循环产生的代码是while循环的两种翻译之一，取决于优化等级。

```c
/*通用形式*/
for (init-expr; test - expr; update-expr){
    body-statement;
}
//for循环的行为与如下while循环代码的行为一样：
init-expr;
while(test -expr) {
    body-statement;
    update-expr;
}
```

- 跳转到中间策略：

```c
init-expr;
goto test;
loop:
	body-statement;
	update-statement;
test:
	t = test-expr;
	if(t)
        goto test;
```

- guarded-do策略：

```c
init-expr;
t = test-expr;
if(!t) 
    goto done;
loop:
	body-statement;
	update-statement;
	t = test-expr;
	if(t)
        goto loop;
done:
```

- 练习题3-29还对涉及continue的循环做了些叙述：

![](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111061919104.jpg)

### 3.6.8Switch语句

- Switch(开关语句)语句可以根据一个整数索引值进行多重分支。在处理具有多种可能结果的测试时有用。
- 使用跳转表(jump-table)数据结构来使得实现更高效。
- 跳转表是一个数组，表项`i`是一个代码段的地址，这个代码段实现当开关索引值为`i`时程序应该采取的动作。
- 程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。
- 和使用一组很长的`if-else`语句相比，使用跳转表的优点在于执行Switch语句的时间与开关情况的数量无关。
- gcc根据开关情况的数量和开关值的系数程度来翻译开关语句。
- 当开关数量比较多(4个以上)且值的范围跨度较小时，就会使用跳转表。
- 一个Switch语句例子：

![微信图片_20211106194255](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111061943418.jpg)

- 关于例子的一些特征：
- 情况标号(case label)跨过一个不连续的区域（没有105和101）
- 有些情况有多个标号（104和106）
- 有些情况落入其他情况之中（102和103），因为对应该情况的代码段没有break语句结尾。
- `&&`为扩展的C语言运算符，创建一个指向代码位置的指针，称为代码指针。
- 图`3-22b`对应的汇编代码：使用了gcc提供的对跳转表的支持，这是对C的扩展。

![微信图片_20211106194929](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111061949467.jpg)

## 3.7过程

- 过程是软件中一种很重要的抽象，提供了一种封装代码的方式：一组指定的参数加可选的返回值实现某些功能。
- 设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。
- 要提供对过程的机器级支持，必须要处理许多不同的属性。
- 假设过程P调用过程Q，过程Q执行完毕后又返回到过程P，这些动作包含下面的数个机制。
  - 传递控制。在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器的值设置为P中`调用Q的那条指令`后面的那条指令的地址。
  - 传递数据。P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。
  - 分配和释放内存。在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。
- x86-64的过程实现包括一组特殊的指令和一些对机器资源（寄存器，内存等）使用的约定规则：最低要求策略。
  - 最低要求策略：只实现上述机制中过程所必需的那些。

接下来一步步描述过程的实现，先描述控制的传递，再描述数据传递，最后是内存管理。

### 3.7.1运行时栈

- C语言过程调用机制的一个关键特性是使用了`运行时栈`。利用栈数据结构后进先出的内存管理原则。
- 在过程P调用Q的例子中，Q在进行时，P及所有向上追溯到P的调用链中的过程，都被暂时挂起。
- Q运行时只需要为局部变量分配空间，或者设置到另外一个过程的调用。
- 当Q返回时，任何它所分配的局部存储空间都可以被释放。
- 因此程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。
- P调用Q时，控制和数据信息添加到栈尾。P返回时，这些信息会被释放掉。
- x86-64栈的栈顶指针向低地址方向增长，而栈顶指针`%rsp`指向栈顶元素，因此可以用`pushq`和`popq`指令将数据存入栈中或者从栈中取出。
- 将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似的可以通过增加栈指针来释放空间。
- **当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。**这个部分称为过程的栈帧(stack fram)。
- 运行时栈的通用结构：

![微信图片_20211106211342](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111062114774.jpg)

- 当前正在执行的过程的帧总是在栈顶
- 过程P调用过程Q时会把返回地址压入栈中，指明当Q返回时，要从P的哪个位置继续执行。这个返回地址看做是P栈帧的一部分。
- Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。
- 栈帧空间中，可以**保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。**
- 大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的栈帧(3.10.5)。
- P通过寄存器最多可以给Q传递6个整数值（指针和整数），如果Q需要更多参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。
- 为了提高时间和空间效率，x86-64过程只分配自己所需要的栈帧。
- 对于参数不超过6个的过程，所有的参数都可以通过寄存器来传递，图3-25某些栈帧其实是可以省略的（用寄存器替代掉就好）。
- 实际上有许多函数甚至根本不需要栈帧。当所有局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时可以这样处理。

### 3.7.2转移控制

- 将控制由P转移到Q只需要简单的将程序计数器设置为Q的代码的起始位置。
- 而从Q中返回时，处理器必须记录好它需要继续执行的P的代码位置。
  - x86-64中，这个信息用指令`call Q`调用过程Q来记录。
  - `call Q`指令会把返回地址A压入栈中，并将程序计数器设置为Q的起始地址。
  - 返回地址是紧跟在调用Q的指令后面的那条指令的地址。
  - 对应指令`ret`从栈中弹出返回地址A，并把程序计数器设置为A。

![微信图片_20211106214107](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111062141668.jpg)

- 关于`call`指令：
  - `call`指令可以有一个目标，即指明被调用过程起始的指令地址。
  - 同跳转一样，调用可以是直接的，也可以是间接的（所以上表call有两种形式）。
  - 汇编代码中直接调用的目标是一个label，间接调用则是`*`后面跟操作数指示符

一个关于`call`和`ret`的例子，懒得写。

![微信图片_20211106215040](https://raw.githubusercontent.com/CorneliaStreet1/PictureBed/master/202111062151706.jpg)

```c
//还有一个更详细的例子还没看，先往下一节去了
```

### 3.7.3数据传送

